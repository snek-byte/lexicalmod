{
  "version": 3,
  "sources": ["../../@lexical/history/LexicalHistory.dev.js", "../../@lexical/history/LexicalHistory.js", "../../@lexical/react/LexicalHistoryPlugin.dev.js", "../../@lexical/react/LexicalHistoryPlugin.js"],
  "sourcesContent": ["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar utils = require('@lexical/utils');\r\nvar lexical = require('lexical');\r\n\r\n/** @module @lexical/history */\r\nconst HISTORY_MERGE = 0;\r\nconst HISTORY_PUSH = 1;\r\nconst DISCARD_HISTORY_CANDIDATE = 2;\r\nconst OTHER = 0;\r\nconst COMPOSING_CHARACTER = 1;\r\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\r\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\r\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\r\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\r\n  const nodeMap = editorState._nodeMap;\r\n  const nodes = [];\r\n  for (const dirtyLeafKey of dirtyLeaves) {\r\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\r\n    if (dirtyLeaf !== undefined) {\r\n      nodes.push(dirtyLeaf);\r\n    }\r\n  }\r\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\r\n    if (!intentionallyMarkedAsDirty) {\r\n      continue;\r\n    }\r\n    const dirtyElement = nodeMap.get(dirtyElementKey);\r\n    if (dirtyElement !== undefined && !lexical.$isRootNode(dirtyElement)) {\r\n      nodes.push(dirtyElement);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\r\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\r\n    return OTHER;\r\n  }\r\n  const nextSelection = nextEditorState._selection;\r\n  const prevSelection = prevEditorState._selection;\r\n  if (isComposing) {\r\n    return COMPOSING_CHARACTER;\r\n  }\r\n  if (!lexical.$isRangeSelection(nextSelection) || !lexical.$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\r\n    return OTHER;\r\n  }\r\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\r\n  if (dirtyNodes.length === 0) {\r\n    return OTHER;\r\n  }\r\n\r\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\r\n  // or after existing node.\r\n  if (dirtyNodes.length > 1) {\r\n    const nextNodeMap = nextEditorState._nodeMap;\r\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\r\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\r\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && lexical.$isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\r\n      return INSERT_CHARACTER_AFTER_SELECTION;\r\n    }\r\n    return OTHER;\r\n  }\r\n  const nextDirtyNode = dirtyNodes[0];\r\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\r\n  if (!lexical.$isTextNode(prevDirtyNode) || !lexical.$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\r\n    return OTHER;\r\n  }\r\n  const prevText = prevDirtyNode.__text;\r\n  const nextText = nextDirtyNode.__text;\r\n  if (prevText === nextText) {\r\n    return OTHER;\r\n  }\r\n  const nextAnchor = nextSelection.anchor;\r\n  const prevAnchor = prevSelection.anchor;\r\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\r\n    return OTHER;\r\n  }\r\n  const nextAnchorOffset = nextAnchor.offset;\r\n  const prevAnchorOffset = prevAnchor.offset;\r\n  const textDiff = nextText.length - prevText.length;\r\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\r\n    return INSERT_CHARACTER_AFTER_SELECTION;\r\n  }\r\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\r\n    return DELETE_CHARACTER_BEFORE_SELECTION;\r\n  }\r\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\r\n    return DELETE_CHARACTER_AFTER_SELECTION;\r\n  }\r\n  return OTHER;\r\n}\r\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\r\n  const prevNode = prevEditorState._nodeMap.get(key);\r\n  const nextNode = nextEditorState._nodeMap.get(key);\r\n  const prevSelection = prevEditorState._selection;\r\n  const nextSelection = nextEditorState._selection;\r\n  let isDeletingLine = false;\r\n  if (lexical.$isRangeSelection(prevSelection) && lexical.$isRangeSelection(nextSelection)) {\r\n    isDeletingLine = prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\r\n  }\r\n  if (!isDeletingLine && lexical.$isTextNode(prevNode) && lexical.$isTextNode(nextNode)) {\r\n    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;\r\n  }\r\n  return false;\r\n}\r\nfunction createMergeActionGetter(editor, delay) {\r\n  let prevChangeTime = Date.now();\r\n  let prevChangeType = OTHER;\r\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\r\n    const changeTime = Date.now();\r\n\r\n    // If applying changes from history stack there's no need\r\n    // to run history logic again, as history entries already calculated\r\n    if (tags.has('historic')) {\r\n      prevChangeType = OTHER;\r\n      prevChangeTime = changeTime;\r\n      return DISCARD_HISTORY_CANDIDATE;\r\n    }\r\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\r\n    const mergeAction = (() => {\r\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\r\n      const shouldPushHistory = tags.has('history-push');\r\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\r\n      if (shouldMergeHistory) {\r\n        return HISTORY_MERGE;\r\n      }\r\n      if (prevEditorState === null) {\r\n        return HISTORY_PUSH;\r\n      }\r\n      const selection = nextEditorState._selection;\r\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\r\n      if (!hasDirtyNodes) {\r\n        if (selection !== null) {\r\n          return HISTORY_MERGE;\r\n        }\r\n        return DISCARD_HISTORY_CANDIDATE;\r\n      }\r\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\r\n        return HISTORY_MERGE;\r\n      }\r\n\r\n      // A single node might have been marked as dirty, but not have changed\r\n      // due to some node transform reverting the change.\r\n      if (dirtyLeaves.size === 1) {\r\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\r\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\r\n          return HISTORY_MERGE;\r\n        }\r\n      }\r\n      return HISTORY_PUSH;\r\n    })();\r\n    prevChangeTime = changeTime;\r\n    prevChangeType = changeType;\r\n    return mergeAction;\r\n  };\r\n}\r\nfunction redo(editor, historyState) {\r\n  const redoStack = historyState.redoStack;\r\n  const undoStack = historyState.undoStack;\r\n  if (redoStack.length !== 0) {\r\n    const current = historyState.current;\r\n    if (current !== null) {\r\n      undoStack.push(current);\r\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\r\n    }\r\n    const historyStateEntry = redoStack.pop();\r\n    if (redoStack.length === 0) {\r\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\r\n    }\r\n    historyState.current = historyStateEntry || null;\r\n    if (historyStateEntry) {\r\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\r\n        tag: 'historic'\r\n      });\r\n    }\r\n  }\r\n}\r\nfunction undo(editor, historyState) {\r\n  const redoStack = historyState.redoStack;\r\n  const undoStack = historyState.undoStack;\r\n  const undoStackLength = undoStack.length;\r\n  if (undoStackLength !== 0) {\r\n    const current = historyState.current;\r\n    const historyStateEntry = undoStack.pop();\r\n    if (current !== null) {\r\n      redoStack.push(current);\r\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, true);\r\n    }\r\n    if (undoStack.length === 0) {\r\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\r\n    }\r\n    historyState.current = historyStateEntry || null;\r\n    if (historyStateEntry) {\r\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\r\n        tag: 'historic'\r\n      });\r\n    }\r\n  }\r\n}\r\nfunction clearHistory(historyState) {\r\n  historyState.undoStack = [];\r\n  historyState.redoStack = [];\r\n  historyState.current = null;\r\n}\r\n\r\n/**\r\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\r\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\r\n * @param editor - The lexical editor.\r\n * @param historyState - The history state, containing the current state and the undo/redo stack.\r\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\r\n * instead of merging the current changes with the current stack.\r\n * @returns The listeners cleanup callback function.\r\n */\r\nfunction registerHistory(editor, historyState, delay) {\r\n  const getMergeAction = createMergeActionGetter(editor, delay);\r\n  const applyChange = ({\r\n    editorState,\r\n    prevEditorState,\r\n    dirtyLeaves,\r\n    dirtyElements,\r\n    tags\r\n  }) => {\r\n    const current = historyState.current;\r\n    const redoStack = historyState.redoStack;\r\n    const undoStack = historyState.undoStack;\r\n    const currentEditorState = current === null ? null : current.editorState;\r\n    if (current !== null && editorState === currentEditorState) {\r\n      return;\r\n    }\r\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\r\n    if (mergeAction === HISTORY_PUSH) {\r\n      if (redoStack.length !== 0) {\r\n        historyState.redoStack = [];\r\n        editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\r\n      }\r\n      if (current !== null) {\r\n        undoStack.push({\r\n          ...current\r\n        });\r\n        editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\r\n      }\r\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\r\n      return;\r\n    }\r\n\r\n    // Else we merge\r\n    historyState.current = {\r\n      editor,\r\n      editorState\r\n    };\r\n  };\r\n  const unregisterCommandListener = utils.mergeRegister(editor.registerCommand(lexical.UNDO_COMMAND, () => {\r\n    undo(editor, historyState);\r\n    return true;\r\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REDO_COMMAND, () => {\r\n    redo(editor, historyState);\r\n    return true;\r\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, () => {\r\n    clearHistory(historyState);\r\n    return false;\r\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_HISTORY_COMMAND, () => {\r\n    clearHistory(historyState);\r\n    editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\r\n    editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\r\n    return true;\r\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\r\n  const unregisterUpdateListener = editor.registerUpdateListener(applyChange);\r\n  return () => {\r\n    unregisterCommandListener();\r\n    unregisterUpdateListener();\r\n  };\r\n}\r\n\r\n/**\r\n * Creates an empty history state.\r\n * @returns - The empty history state, as an object.\r\n */\r\nfunction createEmptyHistoryState() {\r\n  return {\r\n    current: null,\r\n    redoStack: [],\r\n    undoStack: []\r\n  };\r\n}\r\n\r\nexports.createEmptyHistoryState = createEmptyHistoryState;\r\nexports.registerHistory = registerHistory;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst LexicalHistory = process.env.NODE_ENV === 'development' ? require('./LexicalHistory.dev.js') : require('./LexicalHistory.prod.js')\r\nmodule.exports = LexicalHistory;", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\r\nvar history = require('@lexical/history');\r\nvar react = require('react');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\r\n  const historyState = react.useMemo(() => externalHistoryState || history.createEmptyHistoryState(), [externalHistoryState]);\r\n  react.useEffect(() => {\r\n    return history.registerHistory(editor, historyState, delay);\r\n  }, [delay, editor, historyState]);\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction HistoryPlugin({\r\n  externalHistoryState\r\n}) {\r\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\r\n  useHistory(editor, externalHistoryState);\r\n  return null;\r\n}\r\n\r\nexports.createEmptyHistoryState = history.createEmptyHistoryState;\r\nexports.HistoryPlugin = HistoryPlugin;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst LexicalHistoryPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalHistoryPlugin.dev.js') : require('./LexicalHistoryPlugin.prod.js')\r\nmodule.exports = LexicalHistoryPlugin;"],
  "mappings": "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",
  "names": []
}
