import {
  require_LexicalRichText
} from "./chunk-PRA4JQTI.js";
import {
  require_react_dom
} from "./chunk-YQ5BCTVV.js";
import {
  require_LexicalComposerContext
} from "./chunk-U7AICSBZ.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  require_LexicalUtils
} from "./chunk-654INGXA.js";
import {
  require_Lexical
} from "./chunk-O75NZ7RX.js";
import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@lexical/react/useLexicalEditable.dev.js
var require_useLexicalEditable_dev = __commonJS({
  "node_modules/@lexical/react/useLexicalEditable.dev.js"(exports, module) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var react = require_react();
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;
    var useLayoutEffect = useLayoutEffectImpl;
    function useLexicalSubscription(subscription2) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const initializedSubscription = react.useMemo(() => subscription2(editor), [editor, subscription2]);
      const valueRef = react.useRef(initializedSubscription.initialValueFn());
      const [value, setValue] = react.useState(valueRef.current);
      useLayoutEffect(() => {
        const {
          initialValueFn,
          subscribe
        } = initializedSubscription;
        const currentValue = initialValueFn();
        if (valueRef.current !== currentValue) {
          valueRef.current = currentValue;
          setValue(currentValue);
        }
        return subscribe((newValue) => {
          valueRef.current = newValue;
          setValue(newValue);
        });
      }, [initializedSubscription, subscription2]);
      return value;
    }
    function subscription(editor) {
      return {
        initialValueFn: () => editor.isEditable(),
        subscribe: (callback) => {
          return editor.registerEditableListener(callback);
        }
      };
    }
    function useLexicalEditable() {
      return useLexicalSubscription(subscription);
    }
    module.exports = useLexicalEditable;
  }
});

// node_modules/@lexical/react/useLexicalEditable.js
var require_useLexicalEditable = __commonJS({
  "node_modules/@lexical/react/useLexicalEditable.js"(exports, module) {
    "use strict";
    var useLexicalEditable = true ? require_useLexicalEditable_dev() : null;
    module.exports = useLexicalEditable;
  }
});

// node_modules/@lexical/text/LexicalText.dev.js
var require_LexicalText_dev = __commonJS({
  "node_modules/@lexical/text/LexicalText.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    function $findTextIntersectionFromCharacters(root, targetCharacters) {
      let node = root.getFirstChild();
      let currentCharacters = 0;
      mainLoop: while (node !== null) {
        if (lexical.$isElementNode(node)) {
          const child = node.getFirstChild();
          if (child !== null) {
            node = child;
            continue;
          }
        } else if (lexical.$isTextNode(node)) {
          const characters = node.getTextContentSize();
          if (currentCharacters + characters > targetCharacters) {
            return {
              node,
              offset: targetCharacters - currentCharacters
            };
          }
          currentCharacters += characters;
        }
        const sibling = node.getNextSibling();
        if (sibling !== null) {
          node = sibling;
          continue;
        }
        let parent = node.getParent();
        while (parent !== null) {
          const parentSibling = parent.getNextSibling();
          if (parentSibling !== null) {
            node = parentSibling;
            continue mainLoop;
          }
          parent = parent.getParent();
        }
        break;
      }
      return null;
    }
    function $isRootTextContentEmpty(isEditorComposing, trim = true) {
      if (isEditorComposing) {
        return false;
      }
      let text = $rootTextContent();
      if (trim) {
        text = text.trim();
      }
      return text === "";
    }
    function $isRootTextContentEmptyCurry(isEditorComposing, trim) {
      return () => $isRootTextContentEmpty(isEditorComposing, trim);
    }
    function $rootTextContent() {
      const root = lexical.$getRoot();
      return root.getTextContent();
    }
    function $canShowPlaceholder(isComposing) {
      if (!$isRootTextContentEmpty(isComposing, false)) {
        return false;
      }
      const root = lexical.$getRoot();
      const children = root.getChildren();
      const childrenLength = children.length;
      if (childrenLength > 1) {
        return false;
      }
      for (let i = 0; i < childrenLength; i++) {
        const topBlock = children[i];
        if (lexical.$isDecoratorNode(topBlock)) {
          return false;
        }
        if (lexical.$isElementNode(topBlock)) {
          if (!lexical.$isParagraphNode(topBlock)) {
            return false;
          }
          if (topBlock.__indent !== 0) {
            return false;
          }
          const topBlockChildren = topBlock.getChildren();
          const topBlockChildrenLength = topBlockChildren.length;
          for (let s = 0; s < topBlockChildrenLength; s++) {
            const child = topBlockChildren[i];
            if (!lexical.$isTextNode(child)) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function $canShowPlaceholderCurry(isEditorComposing) {
      return () => $canShowPlaceholder(isEditorComposing);
    }
    function registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {
      const isTargetNode = (node) => {
        return node instanceof targetNode;
      };
      const replaceWithSimpleText = (node) => {
        const textNode = lexical.$createTextNode(node.getTextContent());
        textNode.setFormat(node.getFormat());
        node.replace(textNode);
      };
      const getMode = (node) => {
        return node.getLatest().__mode;
      };
      const textNodeTransform = (node) => {
        if (!node.isSimpleText()) {
          return;
        }
        const prevSibling = node.getPreviousSibling();
        let text = node.getTextContent();
        let currentNode = node;
        let match;
        if (lexical.$isTextNode(prevSibling)) {
          const previousText = prevSibling.getTextContent();
          const combinedText = previousText + text;
          const prevMatch = getMatch(combinedText);
          if (isTargetNode(prevSibling)) {
            if (prevMatch === null || getMode(prevSibling) !== 0) {
              replaceWithSimpleText(prevSibling);
              return;
            } else {
              const diff = prevMatch.end - previousText.length;
              if (diff > 0) {
                const concatText = text.slice(0, diff);
                const newTextContent = previousText + concatText;
                prevSibling.select();
                prevSibling.setTextContent(newTextContent);
                if (diff === text.length) {
                  node.remove();
                } else {
                  const remainingText = text.slice(diff);
                  node.setTextContent(remainingText);
                }
                return;
              }
            }
          } else if (prevMatch === null || prevMatch.start < previousText.length) {
            return;
          }
        }
        while (true) {
          match = getMatch(text);
          let nextText = match === null ? "" : text.slice(match.end);
          text = nextText;
          if (nextText === "") {
            const nextSibling = currentNode.getNextSibling();
            if (lexical.$isTextNode(nextSibling)) {
              nextText = currentNode.getTextContent() + nextSibling.getTextContent();
              const nextMatch = getMatch(nextText);
              if (nextMatch === null) {
                if (isTargetNode(nextSibling)) {
                  replaceWithSimpleText(nextSibling);
                } else {
                  nextSibling.markDirty();
                }
                return;
              } else if (nextMatch.start !== 0) {
                return;
              }
            }
          } else {
            const nextMatch = getMatch(nextText);
            if (nextMatch !== null && nextMatch.start === 0) {
              return;
            }
          }
          if (match === null) {
            return;
          }
          if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {
            continue;
          }
          let nodeToReplace;
          if (match.start === 0) {
            [nodeToReplace, currentNode] = currentNode.splitText(match.end);
          } else {
            [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);
          }
          const replacementNode = createNode(nodeToReplace);
          replacementNode.setFormat(nodeToReplace.getFormat());
          nodeToReplace.replace(replacementNode);
          if (currentNode == null) {
            return;
          }
        }
      };
      const reverseNodeTransform = (node) => {
        const text = node.getTextContent();
        const match = getMatch(text);
        if (match === null || match.start !== 0) {
          replaceWithSimpleText(node);
          return;
        }
        if (text.length > match.end) {
          node.splitText(match.end);
          return;
        }
        const prevSibling = node.getPreviousSibling();
        if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {
          replaceWithSimpleText(prevSibling);
          replaceWithSimpleText(node);
        }
        const nextSibling = node.getNextSibling();
        if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {
          replaceWithSimpleText(nextSibling);
          if (isTargetNode(node)) {
            replaceWithSimpleText(node);
          }
        }
      };
      const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);
      const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);
      return [removePlainTextTransform, removeReverseNodeTransform];
    }
    exports.$canShowPlaceholder = $canShowPlaceholder;
    exports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;
    exports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;
    exports.$isRootTextContentEmpty = $isRootTextContentEmpty;
    exports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;
    exports.$rootTextContent = $rootTextContent;
    exports.registerLexicalTextEntity = registerLexicalTextEntity;
  }
});

// node_modules/@lexical/text/LexicalText.js
var require_LexicalText = __commonJS({
  "node_modules/@lexical/text/LexicalText.js"(exports, module) {
    "use strict";
    var LexicalText = true ? require_LexicalText_dev() : null;
    module.exports = LexicalText;
  }
});

// node_modules/@lexical/dragon/LexicalDragon.dev.js
var require_LexicalDragon_dev = __commonJS({
  "node_modules/@lexical/dragon/LexicalDragon.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    function registerDragonSupport(editor) {
      const origin = window.location.origin;
      const handler = (event) => {
        if (event.origin !== origin) {
          return;
        }
        const rootElement = editor.getRootElement();
        if (document.activeElement !== rootElement) {
          return;
        }
        const data = event.data;
        if (typeof data === "string") {
          let parsedData;
          try {
            parsedData = JSON.parse(data);
          } catch (e) {
            return;
          }
          if (parsedData && parsedData.protocol === "nuanria_messaging" && parsedData.type === "request") {
            const payload = parsedData.payload;
            if (payload && payload.functionId === "makeChanges") {
              const args = payload.args;
              if (args) {
                const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;
                editor.update(() => {
                  const selection = lexical.$getSelection();
                  if (lexical.$isRangeSelection(selection)) {
                    const anchor = selection.anchor;
                    let anchorNode = anchor.getNode();
                    let setSelStart = 0;
                    let setSelEnd = 0;
                    if (lexical.$isTextNode(anchorNode)) {
                      if (elementStart >= 0 && elementLength >= 0) {
                        setSelStart = elementStart;
                        setSelEnd = elementStart + elementLength;
                        selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                      }
                    }
                    if (setSelStart !== setSelEnd || text !== "") {
                      selection.insertRawText(text);
                      anchorNode = anchor.getNode();
                    }
                    if (lexical.$isTextNode(anchorNode)) {
                      setSelStart = selStart;
                      setSelEnd = selStart + selLength;
                      const anchorNodeTextLength = anchorNode.getTextContentSize();
                      setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;
                      setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;
                      selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                    }
                    event.stopImmediatePropagation();
                  }
                });
              }
            }
          }
        }
      };
      window.addEventListener("message", handler, true);
      return () => {
        window.removeEventListener("message", handler, true);
      };
    }
    exports.registerDragonSupport = registerDragonSupport;
  }
});

// node_modules/@lexical/dragon/LexicalDragon.js
var require_LexicalDragon = __commonJS({
  "node_modules/@lexical/dragon/LexicalDragon.js"(exports, module) {
    "use strict";
    var LexicalDragon = true ? require_LexicalDragon_dev() : null;
    module.exports = LexicalDragon;
  }
});

// node_modules/@lexical/react/LexicalRichTextPlugin.dev.js
var require_LexicalRichTextPlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalRichTextPlugin.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var useLexicalEditable = require_useLexicalEditable();
    var React = require_react();
    var text = require_LexicalText();
    var utils = require_LexicalUtils();
    var reactDom = require_react_dom();
    var dragon = require_LexicalDragon();
    var richText = require_LexicalRichText();
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;
    var useLayoutEffect = useLayoutEffectImpl;
    function canShowPlaceholderFromCurrentEditorState(editor) {
      const currentCanShowPlaceholder = editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing()));
      return currentCanShowPlaceholder;
    }
    function useCanShowPlaceholder(editor) {
      const [canShowPlaceholder, setCanShowPlaceholder] = React.useState(() => canShowPlaceholderFromCurrentEditorState(editor));
      useLayoutEffect(() => {
        function resetCanShowPlaceholder() {
          const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);
          setCanShowPlaceholder(currentCanShowPlaceholder);
        }
        resetCanShowPlaceholder();
        return utils.mergeRegister(editor.registerUpdateListener(() => {
          resetCanShowPlaceholder();
        }), editor.registerEditableListener(() => {
          resetCanShowPlaceholder();
        }));
      }, [editor]);
      return canShowPlaceholder;
    }
    function useDecorators(editor, ErrorBoundary) {
      const [decorators, setDecorators] = React.useState(() => editor.getDecorators());
      useLayoutEffect(() => {
        return editor.registerDecoratorListener((nextDecorators) => {
          reactDom.flushSync(() => {
            setDecorators(nextDecorators);
          });
        });
      }, [editor]);
      React.useEffect(() => {
        setDecorators(editor.getDecorators());
      }, [editor]);
      return React.useMemo(() => {
        const decoratedPortals = [];
        const decoratorKeys = Object.keys(decorators);
        for (let i = 0; i < decoratorKeys.length; i++) {
          const nodeKey = decoratorKeys[i];
          const reactDecorator = React.createElement(ErrorBoundary, {
            onError: (e) => editor._onError(e)
          }, React.createElement(React.Suspense, {
            fallback: null
          }, decorators[nodeKey]));
          const element = editor.getElementByKey(nodeKey);
          if (element !== null) {
            decoratedPortals.push(reactDom.createPortal(reactDecorator, element, nodeKey));
          }
        }
        return decoratedPortals;
      }, [ErrorBoundary, decorators, editor]);
    }
    function useRichTextSetup(editor) {
      useLayoutEffect(() => {
        return utils.mergeRegister(richText.registerRichText(editor), dragon.registerDragonSupport(editor));
      }, [editor]);
    }
    function RichTextPlugin({
      contentEditable,
      placeholder,
      ErrorBoundary
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const decorators = useDecorators(editor, ErrorBoundary);
      useRichTextSetup(editor);
      return React.createElement(React.Fragment, null, contentEditable, React.createElement(Placeholder, {
        content: placeholder
      }), decorators);
    }
    function Placeholder({
      content
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const showPlaceholder = useCanShowPlaceholder(editor);
      const editable = useLexicalEditable();
      if (!showPlaceholder) {
        return null;
      }
      if (typeof content === "function") {
        return content(editable);
      } else {
        return content;
      }
    }
    exports.RichTextPlugin = RichTextPlugin;
  }
});

// node_modules/@lexical/react/LexicalRichTextPlugin.js
var require_LexicalRichTextPlugin = __commonJS({
  "node_modules/@lexical/react/LexicalRichTextPlugin.js"(exports, module) {
    var LexicalRichTextPlugin = true ? require_LexicalRichTextPlugin_dev() : null;
    module.exports = LexicalRichTextPlugin;
  }
});
export default require_LexicalRichTextPlugin();
//# sourceMappingURL=@lexical_react_LexicalRichTextPlugin.js.map
