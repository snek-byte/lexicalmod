{
  "version": 3,
  "sources": ["../../@lexical/react/useLexicalEditable.dev.js", "../../@lexical/react/useLexicalEditable.js", "../../@lexical/text/LexicalText.dev.js", "../../@lexical/text/LexicalText.js", "../../@lexical/dragon/LexicalDragon.dev.js", "../../@lexical/dragon/LexicalDragon.js", "../../@lexical/react/LexicalRichTextPlugin.dev.js", "../../@lexical/react/LexicalRichTextPlugin.js"],
  "sourcesContent": ["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\r\nvar react = require('react');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\r\nvar useLayoutEffect = useLayoutEffectImpl;\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/**\r\n * Shortcut to Lexical subscriptions when values are used for render.\r\n */\r\nfunction useLexicalSubscription(subscription) {\r\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\r\n  const initializedSubscription = react.useMemo(() => subscription(editor), [editor, subscription]);\r\n  const valueRef = react.useRef(initializedSubscription.initialValueFn());\r\n  const [value, setValue] = react.useState(valueRef.current);\r\n  useLayoutEffect(() => {\r\n    const {\r\n      initialValueFn,\r\n      subscribe\r\n    } = initializedSubscription;\r\n    const currentValue = initialValueFn();\r\n    if (valueRef.current !== currentValue) {\r\n      valueRef.current = currentValue;\r\n      setValue(currentValue);\r\n    }\r\n    return subscribe(newValue => {\r\n      valueRef.current = newValue;\r\n      setValue(newValue);\r\n    });\r\n  }, [initializedSubscription, subscription]);\r\n  return value;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction subscription(editor) {\r\n  return {\r\n    initialValueFn: () => editor.isEditable(),\r\n    subscribe: callback => {\r\n      return editor.registerEditableListener(callback);\r\n    }\r\n  };\r\n}\r\nfunction useLexicalEditable() {\r\n  return useLexicalSubscription(subscription);\r\n}\r\n\r\nmodule.exports = useLexicalEditable;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst useLexicalEditable = process.env.NODE_ENV === 'development' ? require('./useLexicalEditable.dev.js') : require('./useLexicalEditable.prod.js')\r\nmodule.exports = useLexicalEditable;", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar lexical = require('lexical');\r\n\r\n/** @module @lexical/text */\r\n/**\r\n * Finds a TextNode with a size larger than targetCharacters and returns\r\n * the node along with the remaining length of the text.\r\n * @param root - The RootNode.\r\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\r\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\r\n */\r\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\r\n  let node = root.getFirstChild();\r\n  let currentCharacters = 0;\r\n  mainLoop: while (node !== null) {\r\n    if (lexical.$isElementNode(node)) {\r\n      const child = node.getFirstChild();\r\n      if (child !== null) {\r\n        node = child;\r\n        continue;\r\n      }\r\n    } else if (lexical.$isTextNode(node)) {\r\n      const characters = node.getTextContentSize();\r\n      if (currentCharacters + characters > targetCharacters) {\r\n        return {\r\n          node,\r\n          offset: targetCharacters - currentCharacters\r\n        };\r\n      }\r\n      currentCharacters += characters;\r\n    }\r\n    const sibling = node.getNextSibling();\r\n    if (sibling !== null) {\r\n      node = sibling;\r\n      continue;\r\n    }\r\n    let parent = node.getParent();\r\n    while (parent !== null) {\r\n      const parentSibling = parent.getNextSibling();\r\n      if (parentSibling !== null) {\r\n        node = parentSibling;\r\n        continue mainLoop;\r\n      }\r\n      parent = parent.getParent();\r\n    }\r\n    break;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Determines if the root has any text content and can trim any whitespace if it does.\r\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\r\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\r\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\r\n */\r\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\r\n  if (isEditorComposing) {\r\n    return false;\r\n  }\r\n  let text = $rootTextContent();\r\n  if (trim) {\r\n    text = text.trim();\r\n  }\r\n  return text === '';\r\n}\r\n\r\n/**\r\n * Returns a function that executes {@link $isRootTextContentEmpty}\r\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\r\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\r\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\r\n */\r\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\r\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\r\n}\r\n\r\n/**\r\n * Returns the root's text content.\r\n * @returns The root's text content.\r\n */\r\nfunction $rootTextContent() {\r\n  const root = lexical.$getRoot();\r\n  return root.getTextContent();\r\n}\r\n\r\n/**\r\n * Determines if the input should show the placeholder. If anything is in\r\n * in the root the placeholder should not be shown.\r\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\r\n * @returns true if the input should show the placeholder, false otherwise.\r\n */\r\nfunction $canShowPlaceholder(isComposing) {\r\n  if (!$isRootTextContentEmpty(isComposing, false)) {\r\n    return false;\r\n  }\r\n  const root = lexical.$getRoot();\r\n  const children = root.getChildren();\r\n  const childrenLength = children.length;\r\n  if (childrenLength > 1) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < childrenLength; i++) {\r\n    const topBlock = children[i];\r\n    if (lexical.$isDecoratorNode(topBlock)) {\r\n      return false;\r\n    }\r\n    if (lexical.$isElementNode(topBlock)) {\r\n      if (!lexical.$isParagraphNode(topBlock)) {\r\n        return false;\r\n      }\r\n      if (topBlock.__indent !== 0) {\r\n        return false;\r\n      }\r\n      const topBlockChildren = topBlock.getChildren();\r\n      const topBlockChildrenLength = topBlockChildren.length;\r\n      for (let s = 0; s < topBlockChildrenLength; s++) {\r\n        const child = topBlockChildren[i];\r\n        if (!lexical.$isTextNode(child)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Returns a function that executes {@link $canShowPlaceholder}\r\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\r\n * @returns A function that executes $canShowPlaceholder with arguments.\r\n */\r\nfunction $canShowPlaceholderCurry(isEditorComposing) {\r\n  return () => $canShowPlaceholder(isEditorComposing);\r\n}\r\n/**\r\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\r\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\r\n * @example\r\n * ```ts\r\n *   useEffect(() => {\r\n    return mergeRegister(\r\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\r\n    );\r\n  }, [createNode, editor, getMatch, targetNode]);\r\n * ```\r\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\r\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\r\n * @param editor - The lexical editor.\r\n * @param getMatch - Finds a matching string that satisfies a regex expression.\r\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\r\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\r\n * @returns An array containing the plain text and reverse node transform listeners.\r\n */\r\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\r\n  const isTargetNode = node => {\r\n    return node instanceof targetNode;\r\n  };\r\n  const replaceWithSimpleText = node => {\r\n    const textNode = lexical.$createTextNode(node.getTextContent());\r\n    textNode.setFormat(node.getFormat());\r\n    node.replace(textNode);\r\n  };\r\n  const getMode = node => {\r\n    return node.getLatest().__mode;\r\n  };\r\n  const textNodeTransform = node => {\r\n    if (!node.isSimpleText()) {\r\n      return;\r\n    }\r\n    const prevSibling = node.getPreviousSibling();\r\n    let text = node.getTextContent();\r\n    let currentNode = node;\r\n    let match;\r\n    if (lexical.$isTextNode(prevSibling)) {\r\n      const previousText = prevSibling.getTextContent();\r\n      const combinedText = previousText + text;\r\n      const prevMatch = getMatch(combinedText);\r\n      if (isTargetNode(prevSibling)) {\r\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\r\n          replaceWithSimpleText(prevSibling);\r\n          return;\r\n        } else {\r\n          const diff = prevMatch.end - previousText.length;\r\n          if (diff > 0) {\r\n            const concatText = text.slice(0, diff);\r\n            const newTextContent = previousText + concatText;\r\n            prevSibling.select();\r\n            prevSibling.setTextContent(newTextContent);\r\n            if (diff === text.length) {\r\n              node.remove();\r\n            } else {\r\n              const remainingText = text.slice(diff);\r\n              node.setTextContent(remainingText);\r\n            }\r\n            return;\r\n          }\r\n        }\r\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n      match = getMatch(text);\r\n      let nextText = match === null ? '' : text.slice(match.end);\r\n      text = nextText;\r\n      if (nextText === '') {\r\n        const nextSibling = currentNode.getNextSibling();\r\n        if (lexical.$isTextNode(nextSibling)) {\r\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\r\n          const nextMatch = getMatch(nextText);\r\n          if (nextMatch === null) {\r\n            if (isTargetNode(nextSibling)) {\r\n              replaceWithSimpleText(nextSibling);\r\n            } else {\r\n              nextSibling.markDirty();\r\n            }\r\n            return;\r\n          } else if (nextMatch.start !== 0) {\r\n            return;\r\n          }\r\n        }\r\n      } else {\r\n        const nextMatch = getMatch(nextText);\r\n        if (nextMatch !== null && nextMatch.start === 0) {\r\n          return;\r\n        }\r\n      }\r\n      if (match === null) {\r\n        return;\r\n      }\r\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\r\n        continue;\r\n      }\r\n      let nodeToReplace;\r\n      if (match.start === 0) {\r\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\r\n      } else {\r\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\r\n      }\r\n      const replacementNode = createNode(nodeToReplace);\r\n      replacementNode.setFormat(nodeToReplace.getFormat());\r\n      nodeToReplace.replace(replacementNode);\r\n      if (currentNode == null) {\r\n        return;\r\n      }\r\n    }\r\n  };\r\n  const reverseNodeTransform = node => {\r\n    const text = node.getTextContent();\r\n    const match = getMatch(text);\r\n    if (match === null || match.start !== 0) {\r\n      replaceWithSimpleText(node);\r\n      return;\r\n    }\r\n    if (text.length > match.end) {\r\n      // This will split out the rest of the text as simple text\r\n      node.splitText(match.end);\r\n      return;\r\n    }\r\n    const prevSibling = node.getPreviousSibling();\r\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\r\n      replaceWithSimpleText(prevSibling);\r\n      replaceWithSimpleText(node);\r\n    }\r\n    const nextSibling = node.getNextSibling();\r\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\r\n      replaceWithSimpleText(nextSibling);\r\n\r\n      // This may have already been converted in the previous block\r\n      if (isTargetNode(node)) {\r\n        replaceWithSimpleText(node);\r\n      }\r\n    }\r\n  };\r\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\r\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\r\n  return [removePlainTextTransform, removeReverseNodeTransform];\r\n}\r\n\r\nexports.$canShowPlaceholder = $canShowPlaceholder;\r\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\r\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\r\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\r\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\r\nexports.$rootTextContent = $rootTextContent;\r\nexports.registerLexicalTextEntity = registerLexicalTextEntity;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst LexicalText = process.env.NODE_ENV === 'development' ? require('./LexicalText.dev.js') : require('./LexicalText.prod.js')\r\nmodule.exports = LexicalText;", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar lexical = require('lexical');\r\n\r\n/** @module @lexical/dragon */\r\nfunction registerDragonSupport(editor) {\r\n  const origin = window.location.origin;\r\n  const handler = event => {\r\n    if (event.origin !== origin) {\r\n      return;\r\n    }\r\n    const rootElement = editor.getRootElement();\r\n    if (document.activeElement !== rootElement) {\r\n      return;\r\n    }\r\n    const data = event.data;\r\n    if (typeof data === 'string') {\r\n      let parsedData;\r\n      try {\r\n        parsedData = JSON.parse(data);\r\n      } catch (e) {\r\n        return;\r\n      }\r\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\r\n        const payload = parsedData.payload;\r\n        if (payload && payload.functionId === 'makeChanges') {\r\n          const args = payload.args;\r\n          if (args) {\r\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\r\n            editor.update(() => {\r\n              const selection = lexical.$getSelection();\r\n              if (lexical.$isRangeSelection(selection)) {\r\n                const anchor = selection.anchor;\r\n                let anchorNode = anchor.getNode();\r\n                let setSelStart = 0;\r\n                let setSelEnd = 0;\r\n                if (lexical.$isTextNode(anchorNode)) {\r\n                  // set initial selection\r\n                  if (elementStart >= 0 && elementLength >= 0) {\r\n                    setSelStart = elementStart;\r\n                    setSelEnd = elementStart + elementLength;\r\n                    // If the offset is more than the end, make it the end\r\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\r\n                  }\r\n                }\r\n                if (setSelStart !== setSelEnd || text !== '') {\r\n                  selection.insertRawText(text);\r\n                  anchorNode = anchor.getNode();\r\n                }\r\n                if (lexical.$isTextNode(anchorNode)) {\r\n                  // set final selection\r\n                  setSelStart = selStart;\r\n                  setSelEnd = selStart + selLength;\r\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\r\n                  // If the offset is more than the end, make it the end\r\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\r\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\r\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\r\n                }\r\n\r\n                // block the chrome extension from handling this event\r\n                event.stopImmediatePropagation();\r\n              }\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n  window.addEventListener('message', handler, true);\r\n  return () => {\r\n    window.removeEventListener('message', handler, true);\r\n  };\r\n}\r\n\r\nexports.registerDragonSupport = registerDragonSupport;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst LexicalDragon = process.env.NODE_ENV === 'development' ? require('./LexicalDragon.dev.js') : require('./LexicalDragon.prod.js')\r\nmodule.exports = LexicalDragon;", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\r\nvar useLexicalEditable = require('@lexical/react/useLexicalEditable');\r\nvar React = require('react');\r\nvar text = require('@lexical/text');\r\nvar utils = require('@lexical/utils');\r\nvar reactDom = require('react-dom');\r\nvar dragon = require('@lexical/dragon');\r\nvar richText = require('@lexical/rich-text');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\r\nvar useLayoutEffect = useLayoutEffectImpl;\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\r\n  const currentCanShowPlaceholder = editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing()));\r\n  return currentCanShowPlaceholder;\r\n}\r\nfunction useCanShowPlaceholder(editor) {\r\n  const [canShowPlaceholder, setCanShowPlaceholder] = React.useState(() => canShowPlaceholderFromCurrentEditorState(editor));\r\n  useLayoutEffect(() => {\r\n    function resetCanShowPlaceholder() {\r\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\r\n      setCanShowPlaceholder(currentCanShowPlaceholder);\r\n    }\r\n    resetCanShowPlaceholder();\r\n    return utils.mergeRegister(editor.registerUpdateListener(() => {\r\n      resetCanShowPlaceholder();\r\n    }), editor.registerEditableListener(() => {\r\n      resetCanShowPlaceholder();\r\n    }));\r\n  }, [editor]);\r\n  return canShowPlaceholder;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction useDecorators(editor, ErrorBoundary) {\r\n  const [decorators, setDecorators] = React.useState(() => editor.getDecorators());\r\n\r\n  // Subscribe to changes\r\n  useLayoutEffect(() => {\r\n    return editor.registerDecoratorListener(nextDecorators => {\r\n      reactDom.flushSync(() => {\r\n        setDecorators(nextDecorators);\r\n      });\r\n    });\r\n  }, [editor]);\r\n  React.useEffect(() => {\r\n    // If the content editable mounts before the subscription is added, then\r\n    // nothing will be rendered on initial pass. We can get around that by\r\n    // ensuring that we set the value.\r\n    setDecorators(editor.getDecorators());\r\n  }, [editor]);\r\n\r\n  // Return decorators defined as React Portals\r\n  return React.useMemo(() => {\r\n    const decoratedPortals = [];\r\n    const decoratorKeys = Object.keys(decorators);\r\n    for (let i = 0; i < decoratorKeys.length; i++) {\r\n      const nodeKey = decoratorKeys[i];\r\n      const reactDecorator = /*#__PURE__*/React.createElement(ErrorBoundary, {\r\n        onError: e => editor._onError(e)\r\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\r\n        fallback: null\r\n      }, decorators[nodeKey]));\r\n      const element = editor.getElementByKey(nodeKey);\r\n      if (element !== null) {\r\n        decoratedPortals.push( /*#__PURE__*/reactDom.createPortal(reactDecorator, element, nodeKey));\r\n      }\r\n    }\r\n    return decoratedPortals;\r\n  }, [ErrorBoundary, decorators, editor]);\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction useRichTextSetup(editor) {\r\n  useLayoutEffect(() => {\r\n    return utils.mergeRegister(richText.registerRichText(editor), dragon.registerDragonSupport(editor));\r\n\r\n    // We only do this for init\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [editor]);\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction RichTextPlugin({\r\n  contentEditable,\r\n  placeholder,\r\n  ErrorBoundary\r\n}) {\r\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\r\n  const decorators = useDecorators(editor, ErrorBoundary);\r\n  useRichTextSetup(editor);\r\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentEditable, /*#__PURE__*/React.createElement(Placeholder, {\r\n    content: placeholder\r\n  }), decorators);\r\n}\r\nfunction Placeholder({\r\n  content\r\n}) {\r\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\r\n  const showPlaceholder = useCanShowPlaceholder(editor);\r\n  const editable = useLexicalEditable();\r\n  if (!showPlaceholder) {\r\n    return null;\r\n  }\r\n  if (typeof content === 'function') {\r\n    return content(editable);\r\n  } else {\r\n    return content;\r\n  }\r\n}\r\n\r\nexports.RichTextPlugin = RichTextPlugin;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst LexicalRichTextPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalRichTextPlugin.dev.js') : require('./LexicalRichTextPlugin.prod.js')\r\nmodule.exports = LexicalRichTextPlugin;"],
  "mappings": "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",
  "names": ["subscription"]
}
