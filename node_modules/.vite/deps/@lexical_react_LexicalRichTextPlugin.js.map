{
  "version": 3,
  "sources": ["../../@lexical/react/useLexicalEditable.dev.js", "../../@lexical/react/useLexicalEditable.js", "../../@lexical/text/LexicalText.dev.js", "../../@lexical/text/LexicalText.js", "../../@lexical/dragon/LexicalDragon.dev.js", "../../@lexical/dragon/LexicalDragon.js", "../../@lexical/react/LexicalRichTextPlugin.dev.js", "../../@lexical/react/LexicalRichTextPlugin.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const initializedSubscription = react.useMemo(() => subscription(editor), [editor, subscription]);\n  const valueRef = react.useRef(initializedSubscription.initialValueFn());\n  const [value, setValue] = react.useState(valueRef.current);\n  useLayoutEffect(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\nmodule.exports = useLexicalEditable;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst useLexicalEditable = process.env.NODE_ENV === 'development' ? require('./useLexicalEditable.dev.js') : require('./useLexicalEditable.prod.js')\nmodule.exports = useLexicalEditable;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/text */\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if (lexical.$isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if (lexical.$isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = lexical.$getRoot();\n  return root.getTextContent();\n}\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = lexical.$getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if (lexical.$isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if (lexical.$isElementNode(topBlock)) {\n      if (!lexical.$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!lexical.$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const replaceWithSimpleText = node => {\n    const textNode = lexical.$createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if (lexical.$isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if (lexical.$isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexports.$canShowPlaceholder = $canShowPlaceholder;\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\nexports.$rootTextContent = $rootTextContent;\nexports.registerLexicalTextEntity = registerLexicalTextEntity;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalText = process.env.NODE_ENV === 'development' ? require('./LexicalText.dev.js') : require('./LexicalText.prod.js')\nmodule.exports = LexicalText;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/dragon */\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = lexical.$getSelection();\n              if (lexical.$isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexports.registerDragonSupport = registerDragonSupport;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalDragon = process.env.NODE_ENV === 'development' ? require('./LexicalDragon.dev.js') : require('./LexicalDragon.prod.js')\nmodule.exports = LexicalDragon;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar useLexicalEditable = require('@lexical/react/useLexicalEditable');\nvar React = require('react');\nvar text = require('@lexical/text');\nvar utils = require('@lexical/utils');\nvar reactDom = require('react-dom');\nvar dragon = require('@lexical/dragon');\nvar richText = require('@lexical/rich-text');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = React.useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffect(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return utils.mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = React.useState(() => editor.getDecorators());\n\n  // Subscribe to changes\n  useLayoutEffect(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      reactDom.flushSync(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  React.useEffect(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]);\n\n  // Return decorators defined as React Portals\n  return React.useMemo(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/React.createElement(ErrorBoundary, {\n        onError: e => editor._onError(e)\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\n        fallback: null\n      }, decorators[nodeKey]));\n      const element = editor.getElementByKey(nodeKey);\n      if (element !== null) {\n        decoratedPortals.push( /*#__PURE__*/reactDom.createPortal(reactDecorator, element, nodeKey));\n      }\n    }\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useRichTextSetup(editor) {\n  useLayoutEffect(() => {\n    return utils.mergeRegister(richText.registerRichText(editor), dragon.registerDragonSupport(editor));\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction RichTextPlugin({\n  contentEditable,\n  placeholder,\n  ErrorBoundary\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  useRichTextSetup(editor);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentEditable, /*#__PURE__*/React.createElement(Placeholder, {\n    content: placeholder\n  }), decorators);\n}\nfunction Placeholder({\n  content\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = useLexicalEditable();\n  if (!showPlaceholder) {\n    return null;\n  }\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\nexports.RichTextPlugin = RichTextPlugin;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalRichTextPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalRichTextPlugin.dev.js') : require('./LexicalRichTextPlugin.prod.js')\nmodule.exports = LexicalRichTextPlugin;"],
  "mappings": "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",
  "names": ["subscription"]
}
