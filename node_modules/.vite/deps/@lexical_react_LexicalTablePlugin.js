import {
  require_LexicalTable
} from "./chunk-IJCDZDZ6.js";
import {
  require_LexicalComposerContext
} from "./chunk-U7AICSBZ.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  require_LexicalUtils
} from "./chunk-654INGXA.js";
import {
  require_Lexical
} from "./chunk-O75NZ7RX.js";
import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@lexical/react/LexicalTablePlugin.dev.js
var require_LexicalTablePlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalTablePlugin.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var table = require_LexicalTable();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var react = require_react();
    function TablePlugin({
      hasCellMerge = true,
      hasCellBackgroundColor = true,
      hasTabHandler = true
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      react.useEffect(() => {
        if (!editor.hasNodes([table.TableNode, table.TableCellNode, table.TableRowNode])) {
          {
            throw Error(`TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor`);
          }
        }
        return editor.registerCommand(table.INSERT_TABLE_COMMAND, ({
          columns,
          rows,
          includeHeaders
        }) => {
          const tableNode = table.$createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);
          utils.$insertNodeToNearestRoot(tableNode);
          const firstDescendant = tableNode.getFirstDescendant();
          if (lexical.$isTextNode(firstDescendant)) {
            firstDescendant.select();
          }
          return true;
        }, lexical.COMMAND_PRIORITY_EDITOR);
      }, [editor]);
      react.useEffect(() => {
        const tableSelections = /* @__PURE__ */ new Map();
        const initializeTableNode = (tableNode) => {
          const nodeKey = tableNode.getKey();
          const tableElement = editor.getElementByKey(nodeKey);
          if (tableElement && !tableSelections.has(nodeKey)) {
            const tableSelection = table.applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);
            tableSelections.set(nodeKey, tableSelection);
          }
        };
        editor.getEditorState().read(() => {
          const tableNodes = lexical.$nodesOfType(table.TableNode);
          for (const tableNode of tableNodes) {
            if (table.$isTableNode(tableNode)) {
              initializeTableNode(tableNode);
            }
          }
        });
        const unregisterMutationListener = editor.registerMutationListener(table.TableNode, (nodeMutations) => {
          for (const [nodeKey, mutation] of nodeMutations) {
            if (mutation === "created") {
              editor.getEditorState().read(() => {
                const tableNode = lexical.$getNodeByKey(nodeKey);
                if (table.$isTableNode(tableNode)) {
                  initializeTableNode(tableNode);
                }
              });
            } else if (mutation === "destroyed") {
              const tableSelection = tableSelections.get(nodeKey);
              if (tableSelection !== void 0) {
                tableSelection.removeListeners();
                tableSelections.delete(nodeKey);
              }
            }
          }
        });
        return () => {
          unregisterMutationListener();
          for (const [, tableSelection] of tableSelections) {
            tableSelection.removeListeners();
          }
        };
      }, [editor, hasTabHandler]);
      react.useEffect(() => {
        if (hasCellMerge) {
          return;
        }
        return editor.registerNodeTransform(table.TableCellNode, (node) => {
          if (node.getColSpan() > 1 || node.getRowSpan() > 1) {
            const [, , gridNode] = table.$getNodeTriplet(node);
            const [gridMap] = table.$computeTableMap(gridNode, node, node);
            const rowsCount = gridMap.length;
            const columnsCount = gridMap[0].length;
            let row = gridNode.getFirstChild();
            if (!table.$isTableRowNode(row)) {
              throw Error(`Expected TableNode first child to be a RowNode`);
            }
            const unmerged = [];
            for (let i = 0; i < rowsCount; i++) {
              if (i !== 0) {
                row = row.getNextSibling();
                if (!table.$isTableRowNode(row)) {
                  throw Error(`Expected TableNode first child to be a RowNode`);
                }
              }
              let lastRowCell = null;
              for (let j = 0; j < columnsCount; j++) {
                const cellMap = gridMap[i][j];
                const cell = cellMap.cell;
                if (cellMap.startRow === i && cellMap.startColumn === j) {
                  lastRowCell = cell;
                  unmerged.push(cell);
                } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {
                  if (!table.$isTableCellNode(cell)) {
                    throw Error(`Expected TableNode cell to be a TableCellNode`);
                  }
                  const newCell = table.$createTableCellNode(cell.__headerState);
                  if (lastRowCell !== null) {
                    lastRowCell.insertAfter(newCell);
                  } else {
                    utils.$insertFirst(row, newCell);
                  }
                }
              }
            }
            for (const cell of unmerged) {
              cell.setColSpan(1);
              cell.setRowSpan(1);
            }
          }
        });
      }, [editor, hasCellMerge]);
      react.useEffect(() => {
        if (hasCellBackgroundColor) {
          return;
        }
        return editor.registerNodeTransform(table.TableCellNode, (node) => {
          if (node.getBackgroundColor() !== null) {
            node.setBackgroundColor(null);
          }
        });
      }, [editor, hasCellBackgroundColor, hasCellMerge]);
      return null;
    }
    exports.TablePlugin = TablePlugin;
  }
});

// node_modules/@lexical/react/LexicalTablePlugin.js
var require_LexicalTablePlugin = __commonJS({
  "node_modules/@lexical/react/LexicalTablePlugin.js"(exports, module) {
    var LexicalTablePlugin = true ? require_LexicalTablePlugin_dev() : null;
    module.exports = LexicalTablePlugin;
  }
});
export default require_LexicalTablePlugin();
//# sourceMappingURL=@lexical_react_LexicalTablePlugin.js.map
