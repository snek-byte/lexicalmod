{
  "version": 3,
  "sources": ["../../@lexical/react/LexicalTablePlugin.dev.js", "../../@lexical/react/LexicalTablePlugin.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar table = require('@lexical/table');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction TablePlugin({\n  hasCellMerge = true,\n  hasCellBackgroundColor = true,\n  hasTabHandler = true\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([table.TableNode, table.TableCellNode, table.TableRowNode])) {\n      {\n        throw Error(`TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor`);\n      }\n    }\n    return editor.registerCommand(table.INSERT_TABLE_COMMAND, ({\n      columns,\n      rows,\n      includeHeaders\n    }) => {\n      const tableNode = table.$createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n      utils.$insertNodeToNearestRoot(tableNode);\n      const firstDescendant = tableNode.getFirstDescendant();\n      if (lexical.$isTextNode(firstDescendant)) {\n        firstDescendant.select();\n      }\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR);\n  }, [editor]);\n  react.useEffect(() => {\n    const tableSelections = new Map();\n    const initializeTableNode = tableNode => {\n      const nodeKey = tableNode.getKey();\n      const tableElement = editor.getElementByKey(nodeKey);\n      if (tableElement && !tableSelections.has(nodeKey)) {\n        const tableSelection = table.applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n        tableSelections.set(nodeKey, tableSelection);\n      }\n    };\n\n    // Plugins might be loaded _after_ initial content is set, hence existing table nodes\n    // won't be initialized from mutation[create] listener. Instead doing it here,\n    editor.getEditorState().read(() => {\n      const tableNodes = lexical.$nodesOfType(table.TableNode);\n      for (const tableNode of tableNodes) {\n        if (table.$isTableNode(tableNode)) {\n          initializeTableNode(tableNode);\n        }\n      }\n    });\n    const unregisterMutationListener = editor.registerMutationListener(table.TableNode, nodeMutations => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        if (mutation === 'created') {\n          editor.getEditorState().read(() => {\n            const tableNode = lexical.$getNodeByKey(nodeKey);\n            if (table.$isTableNode(tableNode)) {\n              initializeTableNode(tableNode);\n            }\n          });\n        } else if (mutation === 'destroyed') {\n          const tableSelection = tableSelections.get(nodeKey);\n          if (tableSelection !== undefined) {\n            tableSelection.removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    });\n    return () => {\n      unregisterMutationListener();\n      // Hook might be called multiple times so cleaning up tables listeners as well,\n      // as it'll be reinitialized during recurring call\n      for (const [, tableSelection] of tableSelections) {\n        tableSelection.removeListeners();\n      }\n    };\n  }, [editor, hasTabHandler]);\n\n  // Unmerge cells when the feature isn't enabled\n  react.useEffect(() => {\n    if (hasCellMerge) {\n      return;\n    }\n    return editor.registerNodeTransform(table.TableCellNode, node => {\n      if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n        // When we have rowSpan we have to map the entire Table to understand where the new Cells\n        // fit best; let's analyze all Cells at once to save us from further transform iterations\n        const [,, gridNode] = table.$getNodeTriplet(node);\n        const [gridMap] = table.$computeTableMap(gridNode, node, node);\n        // TODO this function expects Tables to be normalized. Look into this once it exists\n        const rowsCount = gridMap.length;\n        const columnsCount = gridMap[0].length;\n        let row = gridNode.getFirstChild();\n        if (!table.$isTableRowNode(row)) {\n          throw Error(`Expected TableNode first child to be a RowNode`);\n        }\n        const unmerged = [];\n        for (let i = 0; i < rowsCount; i++) {\n          if (i !== 0) {\n            row = row.getNextSibling();\n            if (!table.$isTableRowNode(row)) {\n              throw Error(`Expected TableNode first child to be a RowNode`);\n            }\n          }\n          let lastRowCell = null;\n          for (let j = 0; j < columnsCount; j++) {\n            const cellMap = gridMap[i][j];\n            const cell = cellMap.cell;\n            if (cellMap.startRow === i && cellMap.startColumn === j) {\n              lastRowCell = cell;\n              unmerged.push(cell);\n            } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n              if (!table.$isTableCellNode(cell)) {\n                throw Error(`Expected TableNode cell to be a TableCellNode`);\n              }\n              const newCell = table.$createTableCellNode(cell.__headerState);\n              if (lastRowCell !== null) {\n                lastRowCell.insertAfter(newCell);\n              } else {\n                utils.$insertFirst(row, newCell);\n              }\n            }\n          }\n        }\n        for (const cell of unmerged) {\n          cell.setColSpan(1);\n          cell.setRowSpan(1);\n        }\n      }\n    });\n  }, [editor, hasCellMerge]);\n\n  // Remove cell background color when feature is disabled\n  react.useEffect(() => {\n    if (hasCellBackgroundColor) {\n      return;\n    }\n    return editor.registerNodeTransform(table.TableCellNode, node => {\n      if (node.getBackgroundColor() !== null) {\n        node.setBackgroundColor(null);\n      }\n    });\n  }, [editor, hasCellBackgroundColor, hasCellMerge]);\n  return null;\n}\n\nexports.TablePlugin = TablePlugin;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalTablePlugin = process.env.NODE_ENV === 'development' ? require('./LexicalTablePlugin.dev.js') : require('./LexicalTablePlugin.prod.js')\nmodule.exports = LexicalTablePlugin;"],
  "mappings": "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",
  "names": []
}
