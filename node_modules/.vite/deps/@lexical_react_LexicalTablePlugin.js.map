{
  "version": 3,
  "sources": ["../../@lexical/react/LexicalTablePlugin.dev.js", "../../@lexical/react/LexicalTablePlugin.js"],
  "sourcesContent": ["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\r\nvar table = require('@lexical/table');\r\nvar utils = require('@lexical/utils');\r\nvar lexical = require('lexical');\r\nvar react = require('react');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction TablePlugin({\r\n  hasCellMerge = true,\r\n  hasCellBackgroundColor = true,\r\n  hasTabHandler = true\r\n}) {\r\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\r\n  react.useEffect(() => {\r\n    if (!editor.hasNodes([table.TableNode, table.TableCellNode, table.TableRowNode])) {\r\n      {\r\n        throw Error(`TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor`);\r\n      }\r\n    }\r\n    return editor.registerCommand(table.INSERT_TABLE_COMMAND, ({\r\n      columns,\r\n      rows,\r\n      includeHeaders\r\n    }) => {\r\n      const tableNode = table.$createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\r\n      utils.$insertNodeToNearestRoot(tableNode);\r\n      const firstDescendant = tableNode.getFirstDescendant();\r\n      if (lexical.$isTextNode(firstDescendant)) {\r\n        firstDescendant.select();\r\n      }\r\n      return true;\r\n    }, lexical.COMMAND_PRIORITY_EDITOR);\r\n  }, [editor]);\r\n  react.useEffect(() => {\r\n    const tableSelections = new Map();\r\n    const initializeTableNode = tableNode => {\r\n      const nodeKey = tableNode.getKey();\r\n      const tableElement = editor.getElementByKey(nodeKey);\r\n      if (tableElement && !tableSelections.has(nodeKey)) {\r\n        const tableSelection = table.applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\r\n        tableSelections.set(nodeKey, tableSelection);\r\n      }\r\n    };\r\n\r\n    // Plugins might be loaded _after_ initial content is set, hence existing table nodes\r\n    // won't be initialized from mutation[create] listener. Instead doing it here,\r\n    editor.getEditorState().read(() => {\r\n      const tableNodes = lexical.$nodesOfType(table.TableNode);\r\n      for (const tableNode of tableNodes) {\r\n        if (table.$isTableNode(tableNode)) {\r\n          initializeTableNode(tableNode);\r\n        }\r\n      }\r\n    });\r\n    const unregisterMutationListener = editor.registerMutationListener(table.TableNode, nodeMutations => {\r\n      for (const [nodeKey, mutation] of nodeMutations) {\r\n        if (mutation === 'created') {\r\n          editor.getEditorState().read(() => {\r\n            const tableNode = lexical.$getNodeByKey(nodeKey);\r\n            if (table.$isTableNode(tableNode)) {\r\n              initializeTableNode(tableNode);\r\n            }\r\n          });\r\n        } else if (mutation === 'destroyed') {\r\n          const tableSelection = tableSelections.get(nodeKey);\r\n          if (tableSelection !== undefined) {\r\n            tableSelection.removeListeners();\r\n            tableSelections.delete(nodeKey);\r\n          }\r\n        }\r\n      }\r\n    });\r\n    return () => {\r\n      unregisterMutationListener();\r\n      // Hook might be called multiple times so cleaning up tables listeners as well,\r\n      // as it'll be reinitialized during recurring call\r\n      for (const [, tableSelection] of tableSelections) {\r\n        tableSelection.removeListeners();\r\n      }\r\n    };\r\n  }, [editor, hasTabHandler]);\r\n\r\n  // Unmerge cells when the feature isn't enabled\r\n  react.useEffect(() => {\r\n    if (hasCellMerge) {\r\n      return;\r\n    }\r\n    return editor.registerNodeTransform(table.TableCellNode, node => {\r\n      if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\r\n        // When we have rowSpan we have to map the entire Table to understand where the new Cells\r\n        // fit best; let's analyze all Cells at once to save us from further transform iterations\r\n        const [,, gridNode] = table.$getNodeTriplet(node);\r\n        const [gridMap] = table.$computeTableMap(gridNode, node, node);\r\n        // TODO this function expects Tables to be normalized. Look into this once it exists\r\n        const rowsCount = gridMap.length;\r\n        const columnsCount = gridMap[0].length;\r\n        let row = gridNode.getFirstChild();\r\n        if (!table.$isTableRowNode(row)) {\r\n          throw Error(`Expected TableNode first child to be a RowNode`);\r\n        }\r\n        const unmerged = [];\r\n        for (let i = 0; i < rowsCount; i++) {\r\n          if (i !== 0) {\r\n            row = row.getNextSibling();\r\n            if (!table.$isTableRowNode(row)) {\r\n              throw Error(`Expected TableNode first child to be a RowNode`);\r\n            }\r\n          }\r\n          let lastRowCell = null;\r\n          for (let j = 0; j < columnsCount; j++) {\r\n            const cellMap = gridMap[i][j];\r\n            const cell = cellMap.cell;\r\n            if (cellMap.startRow === i && cellMap.startColumn === j) {\r\n              lastRowCell = cell;\r\n              unmerged.push(cell);\r\n            } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\r\n              if (!table.$isTableCellNode(cell)) {\r\n                throw Error(`Expected TableNode cell to be a TableCellNode`);\r\n              }\r\n              const newCell = table.$createTableCellNode(cell.__headerState);\r\n              if (lastRowCell !== null) {\r\n                lastRowCell.insertAfter(newCell);\r\n              } else {\r\n                utils.$insertFirst(row, newCell);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        for (const cell of unmerged) {\r\n          cell.setColSpan(1);\r\n          cell.setRowSpan(1);\r\n        }\r\n      }\r\n    });\r\n  }, [editor, hasCellMerge]);\r\n\r\n  // Remove cell background color when feature is disabled\r\n  react.useEffect(() => {\r\n    if (hasCellBackgroundColor) {\r\n      return;\r\n    }\r\n    return editor.registerNodeTransform(table.TableCellNode, node => {\r\n      if (node.getBackgroundColor() !== null) {\r\n        node.setBackgroundColor(null);\r\n      }\r\n    });\r\n  }, [editor, hasCellBackgroundColor, hasCellMerge]);\r\n  return null;\r\n}\r\n\r\nexports.TablePlugin = TablePlugin;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst LexicalTablePlugin = process.env.NODE_ENV === 'development' ? require('./LexicalTablePlugin.dev.js') : require('./LexicalTablePlugin.prod.js')\r\nmodule.exports = LexicalTablePlugin;"],
  "mappings": "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",
  "names": []
}
