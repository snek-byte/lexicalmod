import {
  require_Lexical
} from "./chunk-O75NZ7RX.js";
import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@lexical/selection/LexicalSelection.dev.js
var require_LexicalSelection_dev = __commonJS({
  "node_modules/@lexical/selection/LexicalSelection.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    var CSS_TO_STYLES = /* @__PURE__ */ new Map();
    function getDOMTextNode(element) {
      let node = element;
      while (node != null) {
        if (node.nodeType === Node.TEXT_NODE) {
          return node;
        }
        node = node.firstChild;
      }
      return null;
    }
    function getDOMIndexWithinParent(node) {
      const parent = node.parentNode;
      if (parent == null) {
        throw new Error("Should never happen");
      }
      return [parent, Array.from(parent.childNodes).indexOf(node)];
    }
    function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {
      const anchorKey = anchorNode.getKey();
      const focusKey = focusNode.getKey();
      const range = document.createRange();
      let anchorDOM = editor.getElementByKey(anchorKey);
      let focusDOM = editor.getElementByKey(focusKey);
      let anchorOffset = _anchorOffset;
      let focusOffset = _focusOffset;
      if (lexical.$isTextNode(anchorNode)) {
        anchorDOM = getDOMTextNode(anchorDOM);
      }
      if (lexical.$isTextNode(focusNode)) {
        focusDOM = getDOMTextNode(focusDOM);
      }
      if (anchorNode === void 0 || focusNode === void 0 || anchorDOM === null || focusDOM === null) {
        return null;
      }
      if (anchorDOM.nodeName === "BR") {
        [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);
      }
      if (focusDOM.nodeName === "BR") {
        [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);
      }
      const firstChild = anchorDOM.firstChild;
      if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === "BR" && anchorOffset === 0 && focusOffset === 0) {
        focusOffset = 1;
      }
      try {
        range.setStart(anchorDOM, anchorOffset);
        range.setEnd(focusDOM, focusOffset);
      } catch (e) {
        return null;
      }
      if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {
        range.setStart(focusDOM, focusOffset);
        range.setEnd(anchorDOM, anchorOffset);
      }
      return range;
    }
    function createRectsFromDOMRange(editor, range) {
      const rootElement = editor.getRootElement();
      if (rootElement === null) {
        return [];
      }
      const rootRect = rootElement.getBoundingClientRect();
      const computedStyle = getComputedStyle(rootElement);
      const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
      const selectionRects = Array.from(range.getClientRects());
      let selectionRectsLength = selectionRects.length;
      selectionRects.sort((a, b) => {
        const top = a.top - b.top;
        if (Math.abs(top) <= 3) {
          return a.left - b.left;
        }
        return top;
      });
      let prevRect;
      for (let i = 0; i < selectionRectsLength; i++) {
        const selectionRect = selectionRects[i];
        const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;
        const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;
        if (isOverlappingRect || selectionSpansElement) {
          selectionRects.splice(i--, 1);
          selectionRectsLength--;
          continue;
        }
        prevRect = selectionRect;
      }
      return selectionRects;
    }
    function getStyleObjectFromRawCSS(css) {
      const styleObject = {};
      const styles = css.split(";");
      for (const style of styles) {
        if (style !== "") {
          const [key, value] = style.split(/:([^]+)/);
          if (key && value) {
            styleObject[key.trim()] = value.trim();
          }
        }
      }
      return styleObject;
    }
    function getStyleObjectFromCSS(css) {
      let value = CSS_TO_STYLES.get(css);
      if (value === void 0) {
        value = getStyleObjectFromRawCSS(css);
        CSS_TO_STYLES.set(css, value);
      }
      {
        Object.freeze(value);
      }
      return value;
    }
    function getCSSFromStyleObject(styles) {
      let css = "";
      for (const style in styles) {
        if (style) {
          css += `${style}: ${styles[style]};`;
        }
      }
      return css;
    }
    function $updateElementNodeProperties(target, source) {
      target.__first = source.__first;
      target.__last = source.__last;
      target.__size = source.__size;
      target.__format = source.__format;
      target.__indent = source.__indent;
      target.__dir = source.__dir;
      return target;
    }
    function $updateTextNodeProperties(target, source) {
      target.__format = source.__format;
      target.__style = source.__style;
      target.__mode = source.__mode;
      target.__detail = source.__detail;
      return target;
    }
    function $cloneWithProperties(node) {
      const constructor = node.constructor;
      const clone = constructor.clone(node);
      clone.__parent = node.__parent;
      clone.__next = node.__next;
      clone.__prev = node.__prev;
      if (lexical.$isElementNode(node) && lexical.$isElementNode(clone)) {
        return $updateElementNodeProperties(clone, node);
      }
      if (lexical.$isTextNode(node) && lexical.$isTextNode(clone)) {
        return $updateTextNodeProperties(clone, node);
      }
      return clone;
    }
    function $sliceSelectedTextNodeContent(selection, textNode) {
      const anchorAndFocus = selection.getStartEndPoints();
      if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {
        const [anchor, focus] = anchorAndFocus;
        const isBackward = selection.isBackward();
        const anchorNode = anchor.getNode();
        const focusNode = focus.getNode();
        const isAnchor = textNode.is(anchorNode);
        const isFocus = textNode.is(focusNode);
        if (isAnchor || isFocus) {
          const [anchorOffset, focusOffset] = lexical.$getCharacterOffsets(selection);
          const isSame = anchorNode.is(focusNode);
          const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
          const isLast = textNode.is(isBackward ? anchorNode : focusNode);
          let startOffset = 0;
          let endOffset = void 0;
          if (isSame) {
            startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
            endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
          } else if (isFirst) {
            const offset = isBackward ? focusOffset : anchorOffset;
            startOffset = offset;
            endOffset = void 0;
          } else if (isLast) {
            const offset = isBackward ? anchorOffset : focusOffset;
            startOffset = 0;
            endOffset = offset;
          }
          textNode.__text = textNode.__text.slice(startOffset, endOffset);
          return textNode;
        }
      }
      return textNode;
    }
    function $isAtNodeEnd(point) {
      if (point.type === "text") {
        return point.offset === point.getNode().getTextContentSize();
      }
      const node = point.getNode();
      if (!lexical.$isElementNode(node)) {
        throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);
      }
      return point.offset === node.getChildrenSize();
    }
    function trimTextContentFromAnchor(editor, anchor, delCount) {
      let currentNode = anchor.getNode();
      let remaining = delCount;
      if (lexical.$isElementNode(currentNode)) {
        const descendantNode = currentNode.getDescendantByIndex(anchor.offset);
        if (descendantNode !== null) {
          currentNode = descendantNode;
        }
      }
      while (remaining > 0 && currentNode !== null) {
        if (lexical.$isElementNode(currentNode)) {
          const lastDescendant = currentNode.getLastDescendant();
          if (lastDescendant !== null) {
            currentNode = lastDescendant;
          }
        }
        let nextNode = currentNode.getPreviousSibling();
        let additionalElementWhitespace = 0;
        if (nextNode === null) {
          let parent = currentNode.getParentOrThrow();
          let parentSibling = parent.getPreviousSibling();
          while (parentSibling === null) {
            parent = parent.getParent();
            if (parent === null) {
              nextNode = null;
              break;
            }
            parentSibling = parent.getPreviousSibling();
          }
          if (parent !== null) {
            additionalElementWhitespace = parent.isInline() ? 0 : 2;
            nextNode = parentSibling;
          }
        }
        let text = currentNode.getTextContent();
        if (text === "" && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {
          text = "\n\n";
        }
        const currentNodeSize = text.length;
        if (!lexical.$isTextNode(currentNode) || remaining >= currentNodeSize) {
          const parent = currentNode.getParent();
          currentNode.remove();
          if (parent != null && parent.getChildrenSize() === 0 && !lexical.$isRootNode(parent)) {
            parent.remove();
          }
          remaining -= currentNodeSize + additionalElementWhitespace;
          currentNode = nextNode;
        } else {
          const key = currentNode.getKey();
          const prevTextContent = editor.getEditorState().read(() => {
            const prevNode = lexical.$getNodeByKey(key);
            if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {
              return prevNode.getTextContent();
            }
            return null;
          });
          const offset = currentNodeSize - remaining;
          const slicedText = text.slice(0, offset);
          if (prevTextContent !== null && prevTextContent !== text) {
            const prevSelection = lexical.$getPreviousSelection();
            let target = currentNode;
            if (!currentNode.isSimpleText()) {
              const textNode = lexical.$createTextNode(prevTextContent);
              currentNode.replace(textNode);
              target = textNode;
            } else {
              currentNode.setTextContent(prevTextContent);
            }
            if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {
              const prevOffset = prevSelection.anchor.offset;
              target.select(prevOffset, prevOffset);
            }
          } else if (currentNode.isSimpleText()) {
            const isSelected = anchor.key === key;
            let anchorOffset = anchor.offset;
            if (anchorOffset < remaining) {
              anchorOffset = currentNodeSize;
            }
            const splitStart = isSelected ? anchorOffset - remaining : 0;
            const splitEnd = isSelected ? anchorOffset : offset;
            if (isSelected && splitStart === 0) {
              const [excessNode] = currentNode.splitText(splitStart, splitEnd);
              excessNode.remove();
            } else {
              const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
              excessNode.remove();
            }
          } else {
            const textNode = lexical.$createTextNode(slicedText);
            currentNode.replace(textNode);
          }
          remaining = 0;
        }
      }
    }
    function $addNodeStyle(node) {
      const CSSText = node.getStyle();
      const styles = getStyleObjectFromRawCSS(CSSText);
      CSS_TO_STYLES.set(CSSText, styles);
    }
    function $patchStyle(target, patch) {
      const prevStyles = getStyleObjectFromCSS("getStyle" in target ? target.getStyle() : target.style);
      const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {
        if (value instanceof Function) {
          styles[key] = value(prevStyles[key]);
        } else if (value === null) {
          delete styles[key];
        } else {
          styles[key] = value;
        }
        return styles;
      }, {
        ...prevStyles
      });
      const newCSSText = getCSSFromStyleObject(newStyles);
      target.setStyle(newCSSText);
      CSS_TO_STYLES.set(newCSSText, newStyles);
    }
    function $patchStyleText(selection, patch) {
      const selectedNodes = selection.getNodes();
      const selectedNodesLength = selectedNodes.length;
      const anchorAndFocus = selection.getStartEndPoints();
      if (anchorAndFocus === null) {
        return;
      }
      const [anchor, focus] = anchorAndFocus;
      const lastIndex = selectedNodesLength - 1;
      let firstNode = selectedNodes[0];
      let lastNode = selectedNodes[lastIndex];
      if (selection.isCollapsed() && lexical.$isRangeSelection(selection)) {
        $patchStyle(selection, patch);
        return;
      }
      const firstNodeText = firstNode.getTextContent();
      const firstNodeTextLength = firstNodeText.length;
      const focusOffset = focus.offset;
      let anchorOffset = anchor.offset;
      const isBefore = anchor.isBefore(focus);
      let startOffset = isBefore ? anchorOffset : focusOffset;
      let endOffset = isBefore ? focusOffset : anchorOffset;
      const startType = isBefore ? anchor.type : focus.type;
      const endType = isBefore ? focus.type : anchor.type;
      const endKey = isBefore ? focus.key : anchor.key;
      if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {
        const nextSibling = firstNode.getNextSibling();
        if (lexical.$isTextNode(nextSibling)) {
          anchorOffset = 0;
          startOffset = 0;
          firstNode = nextSibling;
        }
      }
      if (selectedNodes.length === 1) {
        if (lexical.$isTextNode(firstNode) && firstNode.canHaveFormat()) {
          startOffset = startType === "element" ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;
          endOffset = endType === "element" ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;
          if (startOffset === endOffset) {
            return;
          }
          if (startOffset === 0 && endOffset === firstNodeTextLength) {
            $patchStyle(firstNode, patch);
            firstNode.select(startOffset, endOffset);
          } else {
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            $patchStyle(replacement, patch);
            replacement.select(0, endOffset - startOffset);
          }
        }
      } else {
        if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {
          if (startOffset !== 0) {
            firstNode = firstNode.splitText(startOffset)[1];
            startOffset = 0;
            anchor.set(firstNode.getKey(), startOffset, "text");
          }
          $patchStyle(firstNode, patch);
        }
        if (lexical.$isTextNode(lastNode) && lastNode.canHaveFormat()) {
          const lastNodeText = lastNode.getTextContent();
          const lastNodeTextLength = lastNodeText.length;
          if (lastNode.__key !== endKey && endOffset !== 0) {
            endOffset = lastNodeTextLength;
          }
          if (endOffset !== lastNodeTextLength) {
            [lastNode] = lastNode.splitText(endOffset);
          }
          if (endOffset !== 0 || endType === "element") {
            $patchStyle(lastNode, patch);
          }
        }
        for (let i = 1; i < lastIndex; i++) {
          const selectedNode = selectedNodes[i];
          const selectedNodeKey = selectedNode.getKey();
          if (lexical.$isTextNode(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {
            $patchStyle(selectedNode, patch);
          }
        }
      }
    }
    function $setBlocksType(selection, createElement) {
      if (selection === null) {
        return;
      }
      const anchorAndFocus = selection.getStartEndPoints();
      const anchor = anchorAndFocus ? anchorAndFocus[0] : null;
      if (anchor !== null && anchor.key === "root") {
        const element = createElement();
        const root = lexical.$getRoot();
        const firstChild = root.getFirstChild();
        if (firstChild) {
          firstChild.replace(element, true);
        } else {
          root.append(element);
        }
        return;
      }
      const nodes = selection.getNodes();
      const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;
      if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {
        nodes.push(firstSelectedBlock);
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!INTERNAL_$isBlock(node)) {
          continue;
        }
        if (!lexical.$isElementNode(node)) {
          throw Error(`Expected block node to be an ElementNode`);
        }
        const targetElement = createElement();
        targetElement.setFormat(node.getFormatType());
        targetElement.setIndent(node.getIndent());
        node.replace(targetElement, true);
      }
    }
    function isPointAttached(point) {
      return point.getNode().isAttached();
    }
    function $removeParentEmptyElements(startingNode) {
      let node = startingNode;
      while (node !== null && !lexical.$isRootOrShadowRoot(node)) {
        const latest = node.getLatest();
        const parentNode = node.getParent();
        if (latest.getChildrenSize() === 0) {
          node.remove(true);
        }
        node = parentNode;
      }
    }
    function $wrapNodes(selection, createElement, wrappingElement = null) {
      const anchorAndFocus = selection.getStartEndPoints();
      const anchor = anchorAndFocus ? anchorAndFocus[0] : null;
      const nodes = selection.getNodes();
      const nodesLength = nodes.length;
      if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === "element" && anchor.getNode().getChildrenSize() === 0)) {
        const target = anchor.type === "text" ? anchor.getNode().getParentOrThrow() : anchor.getNode();
        const children = target.getChildren();
        let element = createElement();
        element.setFormat(target.getFormatType());
        element.setIndent(target.getIndent());
        children.forEach((child) => element.append(child));
        if (wrappingElement) {
          element = wrappingElement.append(element);
        }
        target.replace(element);
        return;
      }
      let topLevelNode = null;
      let descendants = [];
      for (let i = 0; i < nodesLength; i++) {
        const node = nodes[i];
        if (lexical.$isRootOrShadowRoot(node)) {
          $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
          descendants = [];
          topLevelNode = node;
        } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {
          descendants.push(node);
        } else {
          $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
          descendants = [node];
        }
      }
      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
    }
    function $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {
      if (nodes.length === 0) {
        return;
      }
      const firstNode = nodes[0];
      const elementMapping = /* @__PURE__ */ new Map();
      const elements = [];
      let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
      if (target.isInline()) {
        target = target.getParentOrThrow();
      }
      let targetIsPrevSibling = false;
      while (target !== null) {
        const prevSibling = target.getPreviousSibling();
        if (prevSibling !== null) {
          target = prevSibling;
          targetIsPrevSibling = true;
          break;
        }
        target = target.getParentOrThrow();
        if (lexical.$isRootOrShadowRoot(target)) {
          break;
        }
      }
      const emptyElements = /* @__PURE__ */ new Set();
      for (let i = 0; i < nodesLength; i++) {
        const node = nodes[i];
        if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {
          emptyElements.add(node.getKey());
        }
      }
      const movedNodes = /* @__PURE__ */ new Set();
      for (let i = 0; i < nodesLength; i++) {
        const node = nodes[i];
        let parent = node.getParent();
        if (parent !== null && parent.isInline()) {
          parent = parent.getParent();
        }
        if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {
          const parentKey = parent.getKey();
          if (elementMapping.get(parentKey) === void 0) {
            const targetElement = createElement();
            targetElement.setFormat(parent.getFormatType());
            targetElement.setIndent(parent.getIndent());
            elements.push(targetElement);
            elementMapping.set(parentKey, targetElement);
            parent.getChildren().forEach((child) => {
              targetElement.append(child);
              movedNodes.add(child.getKey());
              if (lexical.$isElementNode(child)) {
                child.getChildrenKeys().forEach((key) => movedNodes.add(key));
              }
            });
            $removeParentEmptyElements(parent);
          }
        } else if (emptyElements.has(node.getKey())) {
          if (!lexical.$isElementNode(node)) {
            throw Error(`Expected node in emptyElements to be an ElementNode`);
          }
          const targetElement = createElement();
          targetElement.setFormat(node.getFormatType());
          targetElement.setIndent(node.getIndent());
          elements.push(targetElement);
          node.remove(true);
        }
      }
      if (wrappingElement !== null) {
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          wrappingElement.append(element);
        }
      }
      let lastElement = null;
      if (lexical.$isRootOrShadowRoot(target)) {
        if (targetIsPrevSibling) {
          if (wrappingElement !== null) {
            target.insertAfter(wrappingElement);
          } else {
            for (let i = elements.length - 1; i >= 0; i--) {
              const element = elements[i];
              target.insertAfter(element);
            }
          }
        } else {
          const firstChild = target.getFirstChild();
          if (lexical.$isElementNode(firstChild)) {
            target = firstChild;
          }
          if (firstChild === null) {
            if (wrappingElement) {
              target.append(wrappingElement);
            } else {
              for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                target.append(element);
                lastElement = element;
              }
            }
          } else {
            if (wrappingElement !== null) {
              firstChild.insertBefore(wrappingElement);
            } else {
              for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                firstChild.insertBefore(element);
                lastElement = element;
              }
            }
          }
        }
      } else {
        if (wrappingElement) {
          target.insertAfter(wrappingElement);
        } else {
          for (let i = elements.length - 1; i >= 0; i--) {
            const element = elements[i];
            target.insertAfter(element);
            lastElement = element;
          }
        }
      }
      const prevSelection = lexical.$getPreviousSelection();
      if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {
        lexical.$setSelection(prevSelection.clone());
      } else if (lastElement !== null) {
        lastElement.selectEnd();
      } else {
        selection.dirty = true;
      }
    }
    function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
      const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);
      return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();
    }
    function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
      selection.modify(isHoldingShift ? "extend" : "move", isBackward, granularity);
    }
    function $isParentElementRTL(selection) {
      const anchorNode = selection.anchor.getNode();
      const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();
      return parent.getDirection() === "rtl";
    }
    function $moveCharacter(selection, isHoldingShift, isBackward) {
      const isRTL = $isParentElementRTL(selection);
      $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, "character");
    }
    function $selectAll(selection) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const topParent = anchorNode.getTopLevelElementOrThrow();
      const root = topParent.getParentOrThrow();
      let firstNode = root.getFirstDescendant();
      let lastNode = root.getLastDescendant();
      let firstType = "element";
      let lastType = "element";
      let lastOffset = 0;
      if (lexical.$isTextNode(firstNode)) {
        firstType = "text";
      } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {
        firstNode = firstNode.getParentOrThrow();
      }
      if (lexical.$isTextNode(lastNode)) {
        lastType = "text";
        lastOffset = lastNode.getTextContentSize();
      } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {
        lastNode = lastNode.getParentOrThrow();
      }
      if (firstNode && lastNode) {
        anchor.set(firstNode.getKey(), 0, firstType);
        focus.set(lastNode.getKey(), lastOffset, lastType);
      }
    }
    function $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {
      const css = node.getStyle();
      const styleObject = getStyleObjectFromCSS(css);
      if (styleObject !== null) {
        return styleObject[styleProperty] || defaultValue;
      }
      return defaultValue;
    }
    function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = "") {
      let styleValue = null;
      const nodes = selection.getNodes();
      const anchor = selection.anchor;
      const focus = selection.focus;
      const isBackward = selection.isBackward();
      const endOffset = isBackward ? focus.offset : anchor.offset;
      const endNode = isBackward ? focus.getNode() : anchor.getNode();
      if (selection.isCollapsed() && selection.style !== "") {
        const css = selection.style;
        const styleObject = getStyleObjectFromCSS(css);
        if (styleObject !== null && styleProperty in styleObject) {
          return styleObject[styleProperty];
        }
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (i !== 0 && endOffset === 0 && node.is(endNode)) {
          continue;
        }
        if (lexical.$isTextNode(node)) {
          const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);
          if (styleValue === null) {
            styleValue = nodeStyleValue;
          } else if (styleValue !== nodeStyleValue) {
            styleValue = "";
            break;
          }
        }
      }
      return styleValue === null ? defaultValue : styleValue;
    }
    function INTERNAL_$isBlock(node) {
      if (lexical.$isDecoratorNode(node)) {
        return false;
      }
      if (!lexical.$isElementNode(node) || lexical.$isRootOrShadowRoot(node)) {
        return false;
      }
      const firstChild = node.getFirstChild();
      const isLeafElement = firstChild === null || lexical.$isLineBreakNode(firstChild) || lexical.$isTextNode(firstChild) || firstChild.isInline();
      return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;
    }
    function $getAncestor(node, predicate) {
      let parent = node;
      while (parent !== null && parent.getParent() !== null && !predicate(parent)) {
        parent = parent.getParentOrThrow();
      }
      return predicate(parent) ? parent : null;
    }
    exports.$addNodeStyle = $addNodeStyle;
    exports.$cloneWithProperties = $cloneWithProperties;
    exports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;
    exports.$isAtNodeEnd = $isAtNodeEnd;
    exports.$isParentElementRTL = $isParentElementRTL;
    exports.$moveCaretSelection = $moveCaretSelection;
    exports.$moveCharacter = $moveCharacter;
    exports.$patchStyleText = $patchStyleText;
    exports.$selectAll = $selectAll;
    exports.$setBlocksType = $setBlocksType;
    exports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;
    exports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;
    exports.$wrapNodes = $wrapNodes;
    exports.createDOMRange = createDOMRange;
    exports.createRectsFromDOMRange = createRectsFromDOMRange;
    exports.getStyleObjectFromCSS = getStyleObjectFromCSS;
    exports.trimTextContentFromAnchor = trimTextContentFromAnchor;
  }
});

// node_modules/@lexical/selection/LexicalSelection.js
var require_LexicalSelection = __commonJS({
  "node_modules/@lexical/selection/LexicalSelection.js"(exports, module) {
    "use strict";
    var LexicalSelection = true ? require_LexicalSelection_dev() : null;
    module.exports = LexicalSelection;
  }
});

// node_modules/@lexical/utils/LexicalUtils.dev.js
var require_LexicalUtils_dev = __commonJS({
  "node_modules/@lexical/utils/LexicalUtils.dev.js"(exports) {
    "use strict";
    var selection = require_LexicalSelection();
    var lexical = require_Lexical();
    function mergeRegister(...func) {
      return () => {
        func.forEach((f) => f());
      };
    }
    function px(value) {
      return `${value}px`;
    }
    var mutationObserverConfig = {
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true
    };
    function positionNodeOnRange(editor, range, onReposition) {
      let rootDOMNode = null;
      let parentDOMNode = null;
      let observer = null;
      let lastNodes = [];
      const wrapperNode = document.createElement("div");
      function position() {
        if (!(rootDOMNode !== null)) {
          throw Error(`Unexpected null rootDOMNode`);
        }
        if (!(parentDOMNode !== null)) {
          throw Error(`Unexpected null parentDOMNode`);
        }
        const {
          left: rootLeft,
          top: rootTop
        } = rootDOMNode.getBoundingClientRect();
        const parentDOMNode_ = parentDOMNode;
        const rects = selection.createRectsFromDOMRange(editor, range);
        if (!wrapperNode.isConnected) {
          parentDOMNode_.append(wrapperNode);
        }
        let hasRepositioned = false;
        for (let i = 0; i < rects.length; i++) {
          const rect = rects[i];
          const rectNode = lastNodes[i] || document.createElement("div");
          const rectNodeStyle = rectNode.style;
          if (rectNodeStyle.position !== "absolute") {
            rectNodeStyle.position = "absolute";
            hasRepositioned = true;
          }
          const left = px(rect.left - rootLeft);
          if (rectNodeStyle.left !== left) {
            rectNodeStyle.left = left;
            hasRepositioned = true;
          }
          const top = px(rect.top - rootTop);
          if (rectNodeStyle.top !== top) {
            rectNode.style.top = top;
            hasRepositioned = true;
          }
          const width = px(rect.width);
          if (rectNodeStyle.width !== width) {
            rectNode.style.width = width;
            hasRepositioned = true;
          }
          const height = px(rect.height);
          if (rectNodeStyle.height !== height) {
            rectNode.style.height = height;
            hasRepositioned = true;
          }
          if (rectNode.parentNode !== wrapperNode) {
            wrapperNode.append(rectNode);
            hasRepositioned = true;
          }
          lastNodes[i] = rectNode;
        }
        while (lastNodes.length > rects.length) {
          lastNodes.pop();
        }
        if (hasRepositioned) {
          onReposition(lastNodes);
        }
      }
      function stop() {
        parentDOMNode = null;
        rootDOMNode = null;
        if (observer !== null) {
          observer.disconnect();
        }
        observer = null;
        wrapperNode.remove();
        for (const node of lastNodes) {
          node.remove();
        }
        lastNodes = [];
      }
      function restart() {
        const currentRootDOMNode = editor.getRootElement();
        if (currentRootDOMNode === null) {
          return stop();
        }
        const currentParentDOMNode = currentRootDOMNode.parentElement;
        if (!(currentParentDOMNode instanceof HTMLElement)) {
          return stop();
        }
        stop();
        rootDOMNode = currentRootDOMNode;
        parentDOMNode = currentParentDOMNode;
        observer = new MutationObserver((mutations) => {
          const nextRootDOMNode = editor.getRootElement();
          const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;
          if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {
            return restart();
          }
          for (const mutation of mutations) {
            if (!wrapperNode.contains(mutation.target)) {
              return position();
            }
          }
        });
        observer.observe(currentParentDOMNode, mutationObserverConfig);
        position();
      }
      const removeRootListener = editor.registerRootListener(restart);
      return () => {
        removeRootListener();
        stop();
      };
    }
    function markSelection(editor, onReposition) {
      let previousAnchorNode = null;
      let previousAnchorOffset = null;
      let previousFocusNode = null;
      let previousFocusOffset = null;
      let removeRangeListener = () => {
      };
      function compute(editorState) {
        editorState.read(() => {
          const selection2 = lexical.$getSelection();
          if (!lexical.$isRangeSelection(selection2)) {
            previousAnchorNode = null;
            previousAnchorOffset = null;
            previousFocusNode = null;
            previousFocusOffset = null;
            removeRangeListener();
            removeRangeListener = () => {
            };
            return;
          }
          const {
            anchor,
            focus
          } = selection2;
          const currentAnchorNode = anchor.getNode();
          const currentAnchorNodeKey = currentAnchorNode.getKey();
          const currentAnchorOffset = anchor.offset;
          const currentFocusNode = focus.getNode();
          const currentFocusNodeKey = currentFocusNode.getKey();
          const currentFocusOffset = focus.offset;
          const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);
          const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);
          const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));
          const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));
          if (differentAnchorDOM || differentFocusDOM) {
            const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());
            const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());
            if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === "SPAN" && focusHTMLElement.tagName === "SPAN") {
              const range = document.createRange();
              let firstHTMLElement;
              let firstOffset;
              let lastHTMLElement;
              let lastOffset;
              if (focus.isBefore(anchor)) {
                firstHTMLElement = focusHTMLElement;
                firstOffset = focus.offset;
                lastHTMLElement = anchorHTMLElement;
                lastOffset = anchor.offset;
              } else {
                firstHTMLElement = anchorHTMLElement;
                firstOffset = anchor.offset;
                lastHTMLElement = focusHTMLElement;
                lastOffset = focus.offset;
              }
              const firstTextNode = firstHTMLElement.firstChild;
              if (!(firstTextNode !== null)) {
                throw Error(`Expected text node to be first child of span`);
              }
              const lastTextNode = lastHTMLElement.firstChild;
              if (!(lastTextNode !== null)) {
                throw Error(`Expected text node to be first child of span`);
              }
              range.setStart(firstTextNode, firstOffset);
              range.setEnd(lastTextNode, lastOffset);
              removeRangeListener();
              removeRangeListener = positionNodeOnRange(editor, range, (domNodes) => {
                for (const domNode of domNodes) {
                  const domNodeStyle = domNode.style;
                  if (domNodeStyle.background !== "Highlight") {
                    domNodeStyle.background = "Highlight";
                  }
                  if (domNodeStyle.color !== "HighlightText") {
                    domNodeStyle.color = "HighlightText";
                  }
                  if (domNodeStyle.zIndex !== "-1") {
                    domNodeStyle.zIndex = "-1";
                  }
                  if (domNodeStyle.pointerEvents !== "none") {
                    domNodeStyle.pointerEvents = "none";
                  }
                  if (domNodeStyle.marginTop !== px(-1.5)) {
                    domNodeStyle.marginTop = px(-1.5);
                  }
                  if (domNodeStyle.paddingTop !== px(4)) {
                    domNodeStyle.paddingTop = px(4);
                  }
                  if (domNodeStyle.paddingBottom !== px(0)) {
                    domNodeStyle.paddingBottom = px(0);
                  }
                }
                if (onReposition !== void 0) {
                  onReposition(domNodes);
                }
              });
            }
          }
          previousAnchorNode = currentAnchorNode;
          previousAnchorOffset = currentAnchorOffset;
          previousFocusNode = currentFocusNode;
          previousFocusOffset = currentFocusOffset;
        });
      }
      compute(editor.getEditorState());
      return mergeRegister(editor.registerUpdateListener(({
        editorState
      }) => compute(editorState)), removeRangeListener, () => {
        removeRangeListener();
      });
    }
    function addClassNamesToElement(element, ...classNames) {
      classNames.forEach((className) => {
        if (typeof className === "string") {
          const classesToAdd = className.split(" ").filter((n) => n !== "");
          element.classList.add(...classesToAdd);
        }
      });
    }
    function removeClassNamesFromElement(element, ...classNames) {
      classNames.forEach((className) => {
        if (typeof className === "string") {
          element.classList.remove(...className.split(" "));
        }
      });
    }
    function isMimeType(file, acceptableMimeTypes) {
      for (const acceptableType of acceptableMimeTypes) {
        if (file.type.startsWith(acceptableType)) {
          return true;
        }
      }
      return false;
    }
    function mediaFileReader(files, acceptableMimeTypes) {
      const filesIterator = files[Symbol.iterator]();
      return new Promise((resolve, reject) => {
        const processed = [];
        const handleNextFile = () => {
          const {
            done,
            value: file
          } = filesIterator.next();
          if (done) {
            return resolve(processed);
          }
          const fileReader = new FileReader();
          fileReader.addEventListener("error", reject);
          fileReader.addEventListener("load", () => {
            const result = fileReader.result;
            if (typeof result === "string") {
              processed.push({
                file,
                result
              });
            }
            handleNextFile();
          });
          if (isMimeType(file, acceptableMimeTypes)) {
            fileReader.readAsDataURL(file);
          } else {
            handleNextFile();
          }
        };
        handleNextFile();
      });
    }
    function $dfs(startingNode, endingNode) {
      const nodes = [];
      const start = (startingNode || lexical.$getRoot()).getLatest();
      const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);
      let node = start;
      let depth = $getDepth(node);
      while (node !== null && !node.is(end)) {
        nodes.push({
          depth,
          node
        });
        if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {
          node = node.getFirstChild();
          depth++;
        } else {
          let sibling = null;
          while (sibling === null && node !== null) {
            sibling = node.getNextSibling();
            if (sibling === null) {
              node = node.getParent();
              depth--;
            } else {
              node = sibling;
            }
          }
        }
      }
      if (node !== null && node.is(end)) {
        nodes.push({
          depth,
          node
        });
      }
      return nodes;
    }
    function $getDepth(node) {
      let innerNode = node;
      let depth = 0;
      while ((innerNode = innerNode.getParent()) !== null) {
        depth++;
      }
      return depth;
    }
    function $getNearestNodeOfType(node, klass) {
      let parent = node;
      while (parent != null) {
        if (parent instanceof klass) {
          return parent;
        }
        parent = parent.getParent();
      }
      return null;
    }
    function $getNearestBlockElementAncestorOrThrow(startNode) {
      const blockNode = $findMatchingParent(startNode, (node) => lexical.$isElementNode(node) && !node.isInline());
      if (!lexical.$isElementNode(blockNode)) {
        {
          throw Error(`Expected node ${startNode.__key} to have closest block element node.`);
        }
      }
      return blockNode;
    }
    var $findMatchingParent = (startingNode, findFn) => {
      let curr = startingNode;
      while (curr !== lexical.$getRoot() && curr != null) {
        if (findFn(curr)) {
          return curr;
        }
        curr = curr.getParent();
      }
      return null;
    };
    function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
      const $isTargetNode = (node) => {
        return node instanceof targetNode;
      };
      const $findMatch = (node) => {
        const children = node.getChildren();
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if ($isTargetNode(child)) {
            return null;
          }
        }
        let parentNode = node;
        let childNode = node;
        while (parentNode !== null) {
          childNode = parentNode;
          parentNode = parentNode.getParent();
          if ($isTargetNode(parentNode)) {
            return {
              child: childNode,
              parent: parentNode
            };
          }
        }
        return null;
      };
      const elementNodeTransform = (node) => {
        const match = $findMatch(node);
        if (match !== null) {
          const {
            child,
            parent
          } = match;
          if (child.is(node)) {
            handleOverlap(parent, node);
            const nextSiblings = child.getNextSiblings();
            const nextSiblingsLength = nextSiblings.length;
            parent.insertAfter(child);
            if (nextSiblingsLength !== 0) {
              const newParent = cloneNode(parent);
              child.insertAfter(newParent);
              for (let i = 0; i < nextSiblingsLength; i++) {
                newParent.append(nextSiblings[i]);
              }
            }
            if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
              parent.remove();
            }
          }
        }
      };
      return editor.registerNodeTransform(targetNode, elementNodeTransform);
    }
    function $restoreEditorState(editor, editorState) {
      const FULL_RECONCILE = 2;
      const nodeMap = /* @__PURE__ */ new Map();
      const activeEditorState = editor._pendingEditorState;
      for (const [key, node] of editorState._nodeMap) {
        const clone = selection.$cloneWithProperties(node);
        if (lexical.$isTextNode(clone)) {
          if (!lexical.$isTextNode(node)) {
            throw Error(`Expected node be a TextNode`);
          }
          clone.__text = node.__text;
        }
        nodeMap.set(key, clone);
      }
      if (activeEditorState) {
        activeEditorState._nodeMap = nodeMap;
      }
      editor._dirtyType = FULL_RECONCILE;
      const selection$1 = editorState._selection;
      lexical.$setSelection(selection$1 === null ? null : selection$1.clone());
    }
    function $insertNodeToNearestRoot(node) {
      const selection2 = lexical.$getSelection() || lexical.$getPreviousSelection();
      if (lexical.$isRangeSelection(selection2)) {
        const {
          focus
        } = selection2;
        const focusNode = focus.getNode();
        const focusOffset = focus.offset;
        if (lexical.$isRootOrShadowRoot(focusNode)) {
          const focusChild = focusNode.getChildAtIndex(focusOffset);
          if (focusChild == null) {
            focusNode.append(node);
          } else {
            focusChild.insertBefore(node);
          }
          node.selectNext();
        } else {
          let splitNode;
          let splitOffset;
          if (lexical.$isTextNode(focusNode)) {
            splitNode = focusNode.getParentOrThrow();
            splitOffset = focusNode.getIndexWithinParent();
            if (focusOffset > 0) {
              splitOffset += 1;
              focusNode.splitText(focusOffset);
            }
          } else {
            splitNode = focusNode;
            splitOffset = focusOffset;
          }
          const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);
          rightTree.insertBefore(node);
          rightTree.selectStart();
        }
      } else {
        if (selection2 != null) {
          const nodes = selection2.getNodes();
          nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);
        } else {
          const root = lexical.$getRoot();
          root.append(node);
        }
        const paragraphNode = lexical.$createParagraphNode();
        node.insertAfter(paragraphNode);
        paragraphNode.select();
      }
      return node.getLatest();
    }
    function $wrapNodeInElement(node, createElementNode) {
      const elementNode = createElementNode();
      node.replace(elementNode);
      elementNode.append(node);
      return elementNode;
    }
    function objectKlassEquals(object, objectClass) {
      return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
    }
    function $filter(nodes, filterFn) {
      const result = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = filterFn(nodes[i]);
        if (node !== null) {
          result.push(node);
        }
      }
      return result;
    }
    function $insertFirst(parent, node) {
      const firstChild = parent.getFirstChild();
      if (firstChild !== null) {
        firstChild.insertBefore(node);
      } else {
        parent.append(node);
      }
    }
    exports.$splitNode = lexical.$splitNode;
    exports.isHTMLAnchorElement = lexical.isHTMLAnchorElement;
    exports.isHTMLElement = lexical.isHTMLElement;
    exports.$dfs = $dfs;
    exports.$filter = $filter;
    exports.$findMatchingParent = $findMatchingParent;
    exports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;
    exports.$getNearestNodeOfType = $getNearestNodeOfType;
    exports.$insertFirst = $insertFirst;
    exports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;
    exports.$restoreEditorState = $restoreEditorState;
    exports.$wrapNodeInElement = $wrapNodeInElement;
    exports.addClassNamesToElement = addClassNamesToElement;
    exports.isMimeType = isMimeType;
    exports.markSelection = markSelection;
    exports.mediaFileReader = mediaFileReader;
    exports.mergeRegister = mergeRegister;
    exports.objectKlassEquals = objectKlassEquals;
    exports.positionNodeOnRange = positionNodeOnRange;
    exports.registerNestedElementResolver = registerNestedElementResolver;
    exports.removeClassNamesFromElement = removeClassNamesFromElement;
  }
});

// node_modules/@lexical/utils/LexicalUtils.js
var require_LexicalUtils = __commonJS({
  "node_modules/@lexical/utils/LexicalUtils.js"(exports, module) {
    "use strict";
    var LexicalUtils = true ? require_LexicalUtils_dev() : null;
    module.exports = LexicalUtils;
  }
});

export {
  require_LexicalSelection,
  require_LexicalUtils
};
//# sourceMappingURL=chunk-654INGXA.js.map
