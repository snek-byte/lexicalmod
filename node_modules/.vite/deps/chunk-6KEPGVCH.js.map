{
  "version": 3,
  "sources": ["../../@lexical/list/LexicalList.dev.js", "../../@lexical/list/LexicalList.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n  const siblings = listItem.getPreviousSiblings();\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n  return value;\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        throw Error(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      } else {\n        const handled = new Set();\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n            while (parent != null) {\n              const parentKey = parent.getKey();\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n                break;\n              } else {\n                const nextParent = parent.getParent();\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n    updateChildrenListItemValue(list1);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. If only certain children should be updated, they\n * can be passed optionally in an array.\n * @param list - The list whose children are updated.\n * @param children - An array of the children to be updated.\n */\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      updateChildrenListItemValue(innerList);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n      updateChildrenListItemValue(newList);\n    }\n  }\n  if ($isListNode(parent)) {\n    updateChildrenListItemValue(parent);\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n    updateChildrenListItemValue(parentList);\n    updateChildrenListItemValue(greatGrandparentList);\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n        if (!$isListItemNode(node)) {\n          throw Error(`node is not a ListItemNode`);\n        }\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) return replaceWithNode;\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!lexical.$isElementNode(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    const siblings = this.getNextSiblings();\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n      return after;\n    }\n\n    // Attempt to merge if the list is of the same type.\n\n    if ($isListNode(node)) {\n      let child = node;\n      const children = node.getChildren();\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n      return child;\n    }\n\n    // Otherwise, split the list\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    } else if (nextSibling) {\n      const parent = nextSibling.getParent();\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number' && indent > -1)) {\n      throw Error(`Invalid indent value.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n    return super.insertBefore(nodeToInsert);\n  }\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction convertListItemElement(domNode) {\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && utils.isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    updateChildrenListItemValue(this);\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push(wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType, start = 1) {\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\n\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.insertList = insertList;\nexports.removeList = removeList;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalList = process.env.NODE_ENV === 'development' ? require('./LexicalList.dev.js') : require('./LexicalList.prod.js')\nmodule.exports = LexicalList;"],
  "mappings": "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",
  "names": []
}
