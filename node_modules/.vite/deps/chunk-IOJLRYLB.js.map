{
  "version": 3,
  "sources": ["../../@lexical/selection/LexicalSelection.dev.js", "../../@lexical/selection/LexicalSelection.js", "../../@lexical/utils/LexicalUtils.dev.js", "../../@lexical/utils/LexicalUtils.js"],
  "sourcesContent": ["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar lexical = require('lexical');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst CSS_TO_STYLES = new Map();\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction getDOMTextNode(element) {\r\n  let node = element;\r\n  while (node != null) {\r\n    if (node.nodeType === Node.TEXT_NODE) {\r\n      return node;\r\n    }\r\n    node = node.firstChild;\r\n  }\r\n  return null;\r\n}\r\nfunction getDOMIndexWithinParent(node) {\r\n  const parent = node.parentNode;\r\n  if (parent == null) {\r\n    throw new Error('Should never happen');\r\n  }\r\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\r\n}\r\n\r\n/**\r\n * Creates a selection range for the DOM.\r\n * @param editor - The lexical editor.\r\n * @param anchorNode - The anchor node of a selection.\r\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\r\n * @param focusNode - The current focus.\r\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\r\n * @returns The range of selection for the DOM that was created.\r\n */\r\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\r\n  const anchorKey = anchorNode.getKey();\r\n  const focusKey = focusNode.getKey();\r\n  const range = document.createRange();\r\n  let anchorDOM = editor.getElementByKey(anchorKey);\r\n  let focusDOM = editor.getElementByKey(focusKey);\r\n  let anchorOffset = _anchorOffset;\r\n  let focusOffset = _focusOffset;\r\n  if (lexical.$isTextNode(anchorNode)) {\r\n    anchorDOM = getDOMTextNode(anchorDOM);\r\n  }\r\n  if (lexical.$isTextNode(focusNode)) {\r\n    focusDOM = getDOMTextNode(focusDOM);\r\n  }\r\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\r\n    return null;\r\n  }\r\n  if (anchorDOM.nodeName === 'BR') {\r\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\r\n  }\r\n  if (focusDOM.nodeName === 'BR') {\r\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\r\n  }\r\n  const firstChild = anchorDOM.firstChild;\r\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\r\n    focusOffset = 1;\r\n  }\r\n  try {\r\n    range.setStart(anchorDOM, anchorOffset);\r\n    range.setEnd(focusDOM, focusOffset);\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\r\n    // Range is backwards, we need to reverse it\r\n    range.setStart(focusDOM, focusOffset);\r\n    range.setEnd(anchorDOM, anchorOffset);\r\n  }\r\n  return range;\r\n}\r\n\r\n/**\r\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\r\n * @param editor - The lexical editor\r\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\r\n * @returns The selectionRects as an array.\r\n */\r\nfunction createRectsFromDOMRange(editor, range) {\r\n  const rootElement = editor.getRootElement();\r\n  if (rootElement === null) {\r\n    return [];\r\n  }\r\n  const rootRect = rootElement.getBoundingClientRect();\r\n  const computedStyle = getComputedStyle(rootElement);\r\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\r\n  const selectionRects = Array.from(range.getClientRects());\r\n  let selectionRectsLength = selectionRects.length;\r\n  //sort rects from top left to bottom right.\r\n  selectionRects.sort((a, b) => {\r\n    const top = a.top - b.top;\r\n    // Some rects match position closely, but not perfectly,\r\n    // so we give a 3px tolerance.\r\n    if (Math.abs(top) <= 3) {\r\n      return a.left - b.left;\r\n    }\r\n    return top;\r\n  });\r\n  let prevRect;\r\n  for (let i = 0; i < selectionRectsLength; i++) {\r\n    const selectionRect = selectionRects[i];\r\n    // Exclude rects that overlap preceding Rects in the sorted list.\r\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\r\n    // Exclude selections that span the entire element\r\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\r\n    if (isOverlappingRect || selectionSpansElement) {\r\n      selectionRects.splice(i--, 1);\r\n      selectionRectsLength--;\r\n      continue;\r\n    }\r\n    prevRect = selectionRect;\r\n  }\r\n  return selectionRects;\r\n}\r\n\r\n/**\r\n * Creates an object containing all the styles and their values provided in the CSS string.\r\n * @param css - The CSS string of styles and their values.\r\n * @returns The styleObject containing all the styles and their values.\r\n */\r\nfunction getStyleObjectFromRawCSS(css) {\r\n  const styleObject = {};\r\n  const styles = css.split(';');\r\n  for (const style of styles) {\r\n    if (style !== '') {\r\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\r\n      if (key && value) {\r\n        styleObject[key.trim()] = value.trim();\r\n      }\r\n    }\r\n  }\r\n  return styleObject;\r\n}\r\n\r\n/**\r\n * Given a CSS string, returns an object from the style cache.\r\n * @param css - The CSS property as a string.\r\n * @returns The value of the given CSS property.\r\n */\r\nfunction getStyleObjectFromCSS(css) {\r\n  let value = CSS_TO_STYLES.get(css);\r\n  if (value === undefined) {\r\n    value = getStyleObjectFromRawCSS(css);\r\n    CSS_TO_STYLES.set(css, value);\r\n  }\r\n  {\r\n    // Freeze the value in DEV to prevent accidental mutations\r\n    Object.freeze(value);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Gets the CSS styles from the style object.\r\n * @param styles - The style object containing the styles to get.\r\n * @returns A string containing the CSS styles and their values.\r\n */\r\nfunction getCSSFromStyleObject(styles) {\r\n  let css = '';\r\n  for (const style in styles) {\r\n    if (style) {\r\n      css += `${style}: ${styles[style]};`;\r\n    }\r\n  }\r\n  return css;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction $updateElementNodeProperties(target, source) {\r\n  target.__first = source.__first;\r\n  target.__last = source.__last;\r\n  target.__size = source.__size;\r\n  target.__format = source.__format;\r\n  target.__indent = source.__indent;\r\n  target.__dir = source.__dir;\r\n  return target;\r\n}\r\nfunction $updateTextNodeProperties(target, source) {\r\n  target.__format = source.__format;\r\n  target.__style = source.__style;\r\n  target.__mode = source.__mode;\r\n  target.__detail = source.__detail;\r\n  return target;\r\n}\r\n\r\n/**\r\n * Returns a copy of a node, but generates a new key for the copy.\r\n * @param node - The node to be cloned.\r\n * @returns The clone of the node.\r\n */\r\nfunction $cloneWithProperties(node) {\r\n  const constructor = node.constructor;\r\n  // @ts-expect-error\r\n  const clone = constructor.clone(node);\r\n  clone.__parent = node.__parent;\r\n  clone.__next = node.__next;\r\n  clone.__prev = node.__prev;\r\n  if (lexical.$isElementNode(node) && lexical.$isElementNode(clone)) {\r\n    return $updateElementNodeProperties(clone, node);\r\n  }\r\n  if (lexical.$isTextNode(node) && lexical.$isTextNode(clone)) {\r\n    return $updateTextNodeProperties(clone, node);\r\n  }\r\n  return clone;\r\n}\r\n\r\n/**\r\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\r\n * it to be generated into the new TextNode.\r\n * @param selection - The selection containing the node whose TextNode is to be edited.\r\n * @param textNode - The TextNode to be edited.\r\n * @returns The updated TextNode.\r\n */\r\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\r\n  const anchorAndFocus = selection.getStartEndPoints();\r\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\r\n    const [anchor, focus] = anchorAndFocus;\r\n    const isBackward = selection.isBackward();\r\n    const anchorNode = anchor.getNode();\r\n    const focusNode = focus.getNode();\r\n    const isAnchor = textNode.is(anchorNode);\r\n    const isFocus = textNode.is(focusNode);\r\n    if (isAnchor || isFocus) {\r\n      const [anchorOffset, focusOffset] = lexical.$getCharacterOffsets(selection);\r\n      const isSame = anchorNode.is(focusNode);\r\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\r\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\r\n      let startOffset = 0;\r\n      let endOffset = undefined;\r\n      if (isSame) {\r\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\r\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\r\n      } else if (isFirst) {\r\n        const offset = isBackward ? focusOffset : anchorOffset;\r\n        startOffset = offset;\r\n        endOffset = undefined;\r\n      } else if (isLast) {\r\n        const offset = isBackward ? anchorOffset : focusOffset;\r\n        startOffset = 0;\r\n        endOffset = offset;\r\n      }\r\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\r\n      return textNode;\r\n    }\r\n  }\r\n  return textNode;\r\n}\r\n\r\n/**\r\n * Determines if the current selection is at the end of the node.\r\n * @param point - The point of the selection to test.\r\n * @returns true if the provided point offset is in the last possible position, false otherwise.\r\n */\r\nfunction $isAtNodeEnd(point) {\r\n  if (point.type === 'text') {\r\n    return point.offset === point.getNode().getTextContentSize();\r\n  }\r\n  const node = point.getNode();\r\n  if (!lexical.$isElementNode(node)) {\r\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\r\n  }\r\n  return point.offset === node.getChildrenSize();\r\n}\r\n\r\n/**\r\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\r\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\r\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\r\n * @param editor - The lexical editor.\r\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\r\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\r\n */\r\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\r\n  // Work from the current selection anchor point\r\n  let currentNode = anchor.getNode();\r\n  let remaining = delCount;\r\n  if (lexical.$isElementNode(currentNode)) {\r\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\r\n    if (descendantNode !== null) {\r\n      currentNode = descendantNode;\r\n    }\r\n  }\r\n  while (remaining > 0 && currentNode !== null) {\r\n    if (lexical.$isElementNode(currentNode)) {\r\n      const lastDescendant = currentNode.getLastDescendant();\r\n      if (lastDescendant !== null) {\r\n        currentNode = lastDescendant;\r\n      }\r\n    }\r\n    let nextNode = currentNode.getPreviousSibling();\r\n    let additionalElementWhitespace = 0;\r\n    if (nextNode === null) {\r\n      let parent = currentNode.getParentOrThrow();\r\n      let parentSibling = parent.getPreviousSibling();\r\n      while (parentSibling === null) {\r\n        parent = parent.getParent();\r\n        if (parent === null) {\r\n          nextNode = null;\r\n          break;\r\n        }\r\n        parentSibling = parent.getPreviousSibling();\r\n      }\r\n      if (parent !== null) {\r\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\r\n        nextNode = parentSibling;\r\n      }\r\n    }\r\n    let text = currentNode.getTextContent();\r\n    // If the text is empty, we need to consider adding in two line breaks to match\r\n    // the content if we were to get it from its parent.\r\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\r\n      // TODO: should this be handled in core?\r\n      text = '\\n\\n';\r\n    }\r\n    const currentNodeSize = text.length;\r\n    if (!lexical.$isTextNode(currentNode) || remaining >= currentNodeSize) {\r\n      const parent = currentNode.getParent();\r\n      currentNode.remove();\r\n      if (parent != null && parent.getChildrenSize() === 0 && !lexical.$isRootNode(parent)) {\r\n        parent.remove();\r\n      }\r\n      remaining -= currentNodeSize + additionalElementWhitespace;\r\n      currentNode = nextNode;\r\n    } else {\r\n      const key = currentNode.getKey();\r\n      // See if we can just revert it to what was in the last editor state\r\n      const prevTextContent = editor.getEditorState().read(() => {\r\n        const prevNode = lexical.$getNodeByKey(key);\r\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\r\n          return prevNode.getTextContent();\r\n        }\r\n        return null;\r\n      });\r\n      const offset = currentNodeSize - remaining;\r\n      const slicedText = text.slice(0, offset);\r\n      if (prevTextContent !== null && prevTextContent !== text) {\r\n        const prevSelection = lexical.$getPreviousSelection();\r\n        let target = currentNode;\r\n        if (!currentNode.isSimpleText()) {\r\n          const textNode = lexical.$createTextNode(prevTextContent);\r\n          currentNode.replace(textNode);\r\n          target = textNode;\r\n        } else {\r\n          currentNode.setTextContent(prevTextContent);\r\n        }\r\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\r\n          const prevOffset = prevSelection.anchor.offset;\r\n          target.select(prevOffset, prevOffset);\r\n        }\r\n      } else if (currentNode.isSimpleText()) {\r\n        // Split text\r\n        const isSelected = anchor.key === key;\r\n        let anchorOffset = anchor.offset;\r\n        // Move offset to end if it's less than the remaining number, otherwise\r\n        // we'll have a negative splitStart.\r\n        if (anchorOffset < remaining) {\r\n          anchorOffset = currentNodeSize;\r\n        }\r\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\r\n        const splitEnd = isSelected ? anchorOffset : offset;\r\n        if (isSelected && splitStart === 0) {\r\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\r\n          excessNode.remove();\r\n        } else {\r\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\r\n          excessNode.remove();\r\n        }\r\n      } else {\r\n        const textNode = lexical.$createTextNode(slicedText);\r\n        currentNode.replace(textNode);\r\n      }\r\n      remaining = 0;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the TextNode's style object and adds the styles to the CSS.\r\n * @param node - The TextNode to add styles to.\r\n */\r\nfunction $addNodeStyle(node) {\r\n  const CSSText = node.getStyle();\r\n  const styles = getStyleObjectFromRawCSS(CSSText);\r\n  CSS_TO_STYLES.set(CSSText, styles);\r\n}\r\nfunction $patchStyle(target, patch) {\r\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\r\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\r\n    if (value instanceof Function) {\r\n      styles[key] = value(prevStyles[key]);\r\n    } else if (value === null) {\r\n      delete styles[key];\r\n    } else {\r\n      styles[key] = value;\r\n    }\r\n    return styles;\r\n  }, {\r\n    ...prevStyles\r\n  } || {});\r\n  const newCSSText = getCSSFromStyleObject(newStyles);\r\n  target.setStyle(newCSSText);\r\n  CSS_TO_STYLES.set(newCSSText, newStyles);\r\n}\r\n\r\n/**\r\n * Applies the provided styles to the TextNodes in the provided Selection.\r\n * Will update partially selected TextNodes by splitting the TextNode and applying\r\n * the styles to the appropriate one.\r\n * @param selection - The selected node(s) to update.\r\n * @param patch - The patch to apply, which can include multiple styles. { CSSProperty: value }. Can also accept a function that returns the new property value.\r\n */\r\nfunction $patchStyleText(selection, patch) {\r\n  const selectedNodes = selection.getNodes();\r\n  const selectedNodesLength = selectedNodes.length;\r\n  const anchorAndFocus = selection.getStartEndPoints();\r\n  if (anchorAndFocus === null) {\r\n    return;\r\n  }\r\n  const [anchor, focus] = anchorAndFocus;\r\n  const lastIndex = selectedNodesLength - 1;\r\n  let firstNode = selectedNodes[0];\r\n  let lastNode = selectedNodes[lastIndex];\r\n  if (selection.isCollapsed() && lexical.$isRangeSelection(selection)) {\r\n    $patchStyle(selection, patch);\r\n    return;\r\n  }\r\n  const firstNodeText = firstNode.getTextContent();\r\n  const firstNodeTextLength = firstNodeText.length;\r\n  const focusOffset = focus.offset;\r\n  let anchorOffset = anchor.offset;\r\n  const isBefore = anchor.isBefore(focus);\r\n  let startOffset = isBefore ? anchorOffset : focusOffset;\r\n  let endOffset = isBefore ? focusOffset : anchorOffset;\r\n  const startType = isBefore ? anchor.type : focus.type;\r\n  const endType = isBefore ? focus.type : anchor.type;\r\n  const endKey = isBefore ? focus.key : anchor.key;\r\n\r\n  // This is the case where the user only selected the very end of the\r\n  // first node so we don't want to include it in the formatting change.\r\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\r\n    const nextSibling = firstNode.getNextSibling();\r\n    if (lexical.$isTextNode(nextSibling)) {\r\n      // we basically make the second node the firstNode, changing offsets accordingly\r\n      anchorOffset = 0;\r\n      startOffset = 0;\r\n      firstNode = nextSibling;\r\n    }\r\n  }\r\n\r\n  // This is the case where we only selected a single node\r\n  if (selectedNodes.length === 1) {\r\n    if (lexical.$isTextNode(firstNode) && firstNode.canHaveFormat()) {\r\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\r\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\r\n\r\n      // No actual text is selected, so do nothing.\r\n      if (startOffset === endOffset) {\r\n        return;\r\n      }\r\n\r\n      // The entire node is selected, so just format it\r\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\r\n        $patchStyle(firstNode, patch);\r\n        firstNode.select(startOffset, endOffset);\r\n      } else {\r\n        // The node is partially selected, so split it into two nodes\r\n        // and style the selected one.\r\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\r\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\r\n        $patchStyle(replacement, patch);\r\n        replacement.select(0, endOffset - startOffset);\r\n      }\r\n    } // multiple nodes selected.\r\n  } else {\r\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\r\n      if (startOffset !== 0) {\r\n        // the entire first node isn't selected, so split it\r\n        firstNode = firstNode.splitText(startOffset)[1];\r\n        startOffset = 0;\r\n        anchor.set(firstNode.getKey(), startOffset, 'text');\r\n      }\r\n      $patchStyle(firstNode, patch);\r\n    }\r\n    if (lexical.$isTextNode(lastNode) && lastNode.canHaveFormat()) {\r\n      const lastNodeText = lastNode.getTextContent();\r\n      const lastNodeTextLength = lastNodeText.length;\r\n\r\n      // The last node might not actually be the end node\r\n      //\r\n      // If not, assume the last node is fully-selected unless the end offset is\r\n      // zero.\r\n      if (lastNode.__key !== endKey && endOffset !== 0) {\r\n        endOffset = lastNodeTextLength;\r\n      }\r\n\r\n      // if the entire last node isn't selected, split it\r\n      if (endOffset !== lastNodeTextLength) {\r\n        [lastNode] = lastNode.splitText(endOffset);\r\n      }\r\n      if (endOffset !== 0 || endType === 'element') {\r\n        $patchStyle(lastNode, patch);\r\n      }\r\n    }\r\n\r\n    // style all the text nodes in between\r\n    for (let i = 1; i < lastIndex; i++) {\r\n      const selectedNode = selectedNodes[i];\r\n      const selectedNodeKey = selectedNode.getKey();\r\n      if (lexical.$isTextNode(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\r\n        $patchStyle(selectedNode, patch);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n/**\r\n * Converts all nodes in the selection that are of one block type to another.\r\n * @param selection - The selected blocks to be converted.\r\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\r\n */\r\nfunction $setBlocksType(selection, createElement) {\r\n  if (selection === null) {\r\n    return;\r\n  }\r\n  const anchorAndFocus = selection.getStartEndPoints();\r\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\r\n  if (anchor !== null && anchor.key === 'root') {\r\n    const element = createElement();\r\n    const root = lexical.$getRoot();\r\n    const firstChild = root.getFirstChild();\r\n    if (firstChild) {\r\n      firstChild.replace(element, true);\r\n    } else {\r\n      root.append(element);\r\n    }\r\n    return;\r\n  }\r\n  const nodes = selection.getNodes();\r\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\r\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\r\n    nodes.push(firstSelectedBlock);\r\n  }\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n    if (!INTERNAL_$isBlock(node)) {\r\n      continue;\r\n    }\r\n    if (!lexical.$isElementNode(node)) {\r\n      throw Error(`Expected block node to be an ElementNode`);\r\n    }\r\n    const targetElement = createElement();\r\n    targetElement.setFormat(node.getFormatType());\r\n    targetElement.setIndent(node.getIndent());\r\n    node.replace(targetElement, true);\r\n  }\r\n}\r\nfunction isPointAttached(point) {\r\n  return point.getNode().isAttached();\r\n}\r\nfunction $removeParentEmptyElements(startingNode) {\r\n  let node = startingNode;\r\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\r\n    const latest = node.getLatest();\r\n    const parentNode = node.getParent();\r\n    if (latest.getChildrenSize() === 0) {\r\n      node.remove(true);\r\n    }\r\n    node = parentNode;\r\n  }\r\n}\r\n\r\n/**\r\n * @deprecated\r\n * Wraps all nodes in the selection into another node of the type returned by createElement.\r\n * @param selection - The selection of nodes to be wrapped.\r\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\r\n * @param wrappingElement - An element to append the wrapped selection and its children to.\r\n */\r\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\r\n  const anchorAndFocus = selection.getStartEndPoints();\r\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\r\n  const nodes = selection.getNodes();\r\n  const nodesLength = nodes.length;\r\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\r\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\r\n    const children = target.getChildren();\r\n    let element = createElement();\r\n    element.setFormat(target.getFormatType());\r\n    element.setIndent(target.getIndent());\r\n    children.forEach(child => element.append(child));\r\n    if (wrappingElement) {\r\n      element = wrappingElement.append(element);\r\n    }\r\n    target.replace(element);\r\n    return;\r\n  }\r\n  let topLevelNode = null;\r\n  let descendants = [];\r\n  for (let i = 0; i < nodesLength; i++) {\r\n    const node = nodes[i];\r\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\r\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\r\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\r\n    // of each of the cell nodes.\r\n    if (lexical.$isRootOrShadowRoot(node)) {\r\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\r\n      descendants = [];\r\n      topLevelNode = node;\r\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\r\n      descendants.push(node);\r\n    } else {\r\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\r\n      descendants = [node];\r\n    }\r\n  }\r\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\r\n}\r\n\r\n/**\r\n * Wraps each node into a new ElementNode.\r\n * @param selection - The selection of nodes to wrap.\r\n * @param nodes - An array of nodes, generally the descendants of the selection.\r\n * @param nodesLength - The length of nodes.\r\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\r\n * @param wrappingElement - An element to wrap all the nodes into.\r\n * @returns\r\n */\r\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\r\n  if (nodes.length === 0) {\r\n    return;\r\n  }\r\n  const firstNode = nodes[0];\r\n  const elementMapping = new Map();\r\n  const elements = [];\r\n  // The below logic is to find the right target for us to\r\n  // either insertAfter/insertBefore/append the corresponding\r\n  // elements to. This is made more complicated due to nested\r\n  // structures.\r\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\r\n  if (target.isInline()) {\r\n    target = target.getParentOrThrow();\r\n  }\r\n  let targetIsPrevSibling = false;\r\n  while (target !== null) {\r\n    const prevSibling = target.getPreviousSibling();\r\n    if (prevSibling !== null) {\r\n      target = prevSibling;\r\n      targetIsPrevSibling = true;\r\n      break;\r\n    }\r\n    target = target.getParentOrThrow();\r\n    if (lexical.$isRootOrShadowRoot(target)) {\r\n      break;\r\n    }\r\n  }\r\n  const emptyElements = new Set();\r\n\r\n  // Find any top level empty elements\r\n  for (let i = 0; i < nodesLength; i++) {\r\n    const node = nodes[i];\r\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\r\n      emptyElements.add(node.getKey());\r\n    }\r\n  }\r\n  const movedNodes = new Set();\r\n\r\n  // Move out all leaf nodes into our elements array.\r\n  // If we find a top level empty element, also move make\r\n  // an element for that.\r\n  for (let i = 0; i < nodesLength; i++) {\r\n    const node = nodes[i];\r\n    let parent = node.getParent();\r\n    if (parent !== null && parent.isInline()) {\r\n      parent = parent.getParent();\r\n    }\r\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\r\n      const parentKey = parent.getKey();\r\n      if (elementMapping.get(parentKey) === undefined) {\r\n        const targetElement = createElement();\r\n        targetElement.setFormat(parent.getFormatType());\r\n        targetElement.setIndent(parent.getIndent());\r\n        elements.push(targetElement);\r\n        elementMapping.set(parentKey, targetElement);\r\n        // Move node and its siblings to the new\r\n        // element.\r\n        parent.getChildren().forEach(child => {\r\n          targetElement.append(child);\r\n          movedNodes.add(child.getKey());\r\n          if (lexical.$isElementNode(child)) {\r\n            // Skip nested leaf nodes if the parent has already been moved\r\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\r\n          }\r\n        });\r\n        $removeParentEmptyElements(parent);\r\n      }\r\n    } else if (emptyElements.has(node.getKey())) {\r\n      if (!lexical.$isElementNode(node)) {\r\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\r\n      }\r\n      const targetElement = createElement();\r\n      targetElement.setFormat(node.getFormatType());\r\n      targetElement.setIndent(node.getIndent());\r\n      elements.push(targetElement);\r\n      node.remove(true);\r\n    }\r\n  }\r\n  if (wrappingElement !== null) {\r\n    for (let i = 0; i < elements.length; i++) {\r\n      const element = elements[i];\r\n      wrappingElement.append(element);\r\n    }\r\n  }\r\n  let lastElement = null;\r\n\r\n  // If our target is Root-like, let's see if we can re-adjust\r\n  // so that the target is the first child instead.\r\n  if (lexical.$isRootOrShadowRoot(target)) {\r\n    if (targetIsPrevSibling) {\r\n      if (wrappingElement !== null) {\r\n        target.insertAfter(wrappingElement);\r\n      } else {\r\n        for (let i = elements.length - 1; i >= 0; i--) {\r\n          const element = elements[i];\r\n          target.insertAfter(element);\r\n        }\r\n      }\r\n    } else {\r\n      const firstChild = target.getFirstChild();\r\n      if (lexical.$isElementNode(firstChild)) {\r\n        target = firstChild;\r\n      }\r\n      if (firstChild === null) {\r\n        if (wrappingElement) {\r\n          target.append(wrappingElement);\r\n        } else {\r\n          for (let i = 0; i < elements.length; i++) {\r\n            const element = elements[i];\r\n            target.append(element);\r\n            lastElement = element;\r\n          }\r\n        }\r\n      } else {\r\n        if (wrappingElement !== null) {\r\n          firstChild.insertBefore(wrappingElement);\r\n        } else {\r\n          for (let i = 0; i < elements.length; i++) {\r\n            const element = elements[i];\r\n            firstChild.insertBefore(element);\r\n            lastElement = element;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    if (wrappingElement) {\r\n      target.insertAfter(wrappingElement);\r\n    } else {\r\n      for (let i = elements.length - 1; i >= 0; i--) {\r\n        const element = elements[i];\r\n        target.insertAfter(element);\r\n        lastElement = element;\r\n      }\r\n    }\r\n  }\r\n  const prevSelection = lexical.$getPreviousSelection();\r\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\r\n    lexical.$setSelection(prevSelection.clone());\r\n  } else if (lastElement !== null) {\r\n    lastElement.selectEnd();\r\n  } else {\r\n    selection.dirty = true;\r\n  }\r\n}\r\n\r\n/**\r\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\r\n * @param selection - The selection whose default character selection may need to be overridden.\r\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\r\n * @returns true if it should be overridden, false if not.\r\n */\r\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\r\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\r\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\r\n}\r\n\r\n/**\r\n * Moves the selection according to the arguments.\r\n * @param selection - The selected text or nodes.\r\n * @param isHoldingShift - Is the shift key being held down during the operation.\r\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\r\n * @param granularity - The distance to adjust the current selection.\r\n */\r\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\r\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\r\n}\r\n\r\n/**\r\n * Tests a parent element for right to left direction.\r\n * @param selection - The selection whose parent is to be tested.\r\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\r\n */\r\nfunction $isParentElementRTL(selection) {\r\n  const anchorNode = selection.anchor.getNode();\r\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\r\n  return parent.getDirection() === 'rtl';\r\n}\r\n\r\n/**\r\n * Moves selection by character according to arguments.\r\n * @param selection - The selection of the characters to move.\r\n * @param isHoldingShift - Is the shift key being held down during the operation.\r\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\r\n */\r\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\r\n  const isRTL = $isParentElementRTL(selection);\r\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\r\n}\r\n\r\n/**\r\n * Expands the current Selection to cover all of the content in the editor.\r\n * @param selection - The current selection.\r\n */\r\nfunction $selectAll(selection) {\r\n  const anchor = selection.anchor;\r\n  const focus = selection.focus;\r\n  const anchorNode = anchor.getNode();\r\n  const topParent = anchorNode.getTopLevelElementOrThrow();\r\n  const root = topParent.getParentOrThrow();\r\n  let firstNode = root.getFirstDescendant();\r\n  let lastNode = root.getLastDescendant();\r\n  let firstType = 'element';\r\n  let lastType = 'element';\r\n  let lastOffset = 0;\r\n  if (lexical.$isTextNode(firstNode)) {\r\n    firstType = 'text';\r\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\r\n    firstNode = firstNode.getParentOrThrow();\r\n  }\r\n  if (lexical.$isTextNode(lastNode)) {\r\n    lastType = 'text';\r\n    lastOffset = lastNode.getTextContentSize();\r\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\r\n    lastNode = lastNode.getParentOrThrow();\r\n  }\r\n  if (firstNode && lastNode) {\r\n    anchor.set(firstNode.getKey(), 0, firstType);\r\n    focus.set(lastNode.getKey(), lastOffset, lastType);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\r\n * @param node - The node whose style value to get.\r\n * @param styleProperty - The CSS style property.\r\n * @param defaultValue - The default value for the property.\r\n * @returns The value of the property for node.\r\n */\r\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\r\n  const css = node.getStyle();\r\n  const styleObject = getStyleObjectFromCSS(css);\r\n  if (styleObject !== null) {\r\n    return styleObject[styleProperty] || defaultValue;\r\n  }\r\n  return defaultValue;\r\n}\r\n\r\n/**\r\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\r\n * If all TextNodes do not have the same value, it returns an empty string.\r\n * @param selection - The selection of TextNodes whose value to find.\r\n * @param styleProperty - The CSS style property.\r\n * @param defaultValue - The default value for the property, defaults to an empty string.\r\n * @returns The value of the property for the selected TextNodes.\r\n */\r\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\r\n  let styleValue = null;\r\n  const nodes = selection.getNodes();\r\n  const anchor = selection.anchor;\r\n  const focus = selection.focus;\r\n  const isBackward = selection.isBackward();\r\n  const endOffset = isBackward ? focus.offset : anchor.offset;\r\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\r\n  if (selection.isCollapsed() && selection.style !== '') {\r\n    const css = selection.style;\r\n    const styleObject = getStyleObjectFromCSS(css);\r\n    if (styleObject !== null && styleProperty in styleObject) {\r\n      return styleObject[styleProperty];\r\n    }\r\n  }\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n\r\n    // if no actual characters in the end node are selected, we don't\r\n    // include it in the selection for purposes of determining style\r\n    // value\r\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\r\n      continue;\r\n    }\r\n    if (lexical.$isTextNode(node)) {\r\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\r\n      if (styleValue === null) {\r\n        styleValue = nodeStyleValue;\r\n      } else if (styleValue !== nodeStyleValue) {\r\n        // multiple text nodes are in the selection and they don't all\r\n        // have the same style.\r\n        styleValue = '';\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return styleValue === null ? defaultValue : styleValue;\r\n}\r\n\r\n/**\r\n * This function is for internal use of the library.\r\n * Please do not use it as it may change in the future.\r\n */\r\nfunction INTERNAL_$isBlock(node) {\r\n  if (lexical.$isDecoratorNode(node)) {\r\n    return false;\r\n  }\r\n  if (!lexical.$isElementNode(node) || lexical.$isRootOrShadowRoot(node)) {\r\n    return false;\r\n  }\r\n  const firstChild = node.getFirstChild();\r\n  const isLeafElement = firstChild === null || lexical.$isLineBreakNode(firstChild) || lexical.$isTextNode(firstChild) || firstChild.isInline();\r\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\r\n}\r\nfunction $getAncestor(node, predicate) {\r\n  let parent = node;\r\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\r\n    parent = parent.getParentOrThrow();\r\n  }\r\n  return predicate(parent) ? parent : null;\r\n}\r\n\r\nexports.$addNodeStyle = $addNodeStyle;\r\nexports.$cloneWithProperties = $cloneWithProperties;\r\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\r\nexports.$isAtNodeEnd = $isAtNodeEnd;\r\nexports.$isParentElementRTL = $isParentElementRTL;\r\nexports.$moveCaretSelection = $moveCaretSelection;\r\nexports.$moveCharacter = $moveCharacter;\r\nexports.$patchStyleText = $patchStyleText;\r\nexports.$selectAll = $selectAll;\r\nexports.$setBlocksType = $setBlocksType;\r\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\r\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\r\nexports.$wrapNodes = $wrapNodes;\r\nexports.createDOMRange = createDOMRange;\r\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\r\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\r\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst LexicalSelection = process.env.NODE_ENV === 'development' ? require('./LexicalSelection.dev.js') : require('./LexicalSelection.prod.js')\r\nmodule.exports = LexicalSelection;", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar selection = require('@lexical/selection');\r\nvar lexical = require('lexical');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n/**\r\n * Returns a function that will execute all functions passed when called. It is generally used\r\n * to register multiple lexical listeners and then tear them down with a single function call, such\r\n * as React's useEffect hook.\r\n * @example\r\n * ```ts\r\n * useEffect(() => {\r\n *   return mergeRegister(\r\n *     editor.registerCommand(...registerCommand1 logic),\r\n *     editor.registerCommand(...registerCommand2 logic),\r\n *     editor.registerCommand(...registerCommand3 logic)\r\n *   )\r\n * }, [editor])\r\n * ```\r\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\r\n * function to be executed after either the useEffect runs again (due to one of its dependencies\r\n * updating) or the component it resides in unmounts.\r\n * Note the functions don't neccesarily need to be in an array as all arguements\r\n * are considered to be the func argument and spread from there.\r\n * @param func - An array of functions meant to be executed by the returned function.\r\n * @returns the function which executes all the passed register command functions.\r\n */\r\nfunction mergeRegister(...func) {\r\n  return () => {\r\n    func.forEach(f => f());\r\n  };\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nfunction px(value) {\r\n  return `${value}px`;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst mutationObserverConfig = {\r\n  attributes: true,\r\n  characterData: true,\r\n  childList: true,\r\n  subtree: true\r\n};\r\nfunction positionNodeOnRange(editor, range, onReposition) {\r\n  let rootDOMNode = null;\r\n  let parentDOMNode = null;\r\n  let observer = null;\r\n  let lastNodes = [];\r\n  const wrapperNode = document.createElement('div');\r\n  function position() {\r\n    if (!(rootDOMNode !== null)) {\r\n      throw Error(`Unexpected null rootDOMNode`);\r\n    }\r\n    if (!(parentDOMNode !== null)) {\r\n      throw Error(`Unexpected null parentDOMNode`);\r\n    }\r\n    const {\r\n      left: rootLeft,\r\n      top: rootTop\r\n    } = rootDOMNode.getBoundingClientRect();\r\n    const parentDOMNode_ = parentDOMNode;\r\n    const rects = selection.createRectsFromDOMRange(editor, range);\r\n    if (!wrapperNode.isConnected) {\r\n      parentDOMNode_.append(wrapperNode);\r\n    }\r\n    let hasRepositioned = false;\r\n    for (let i = 0; i < rects.length; i++) {\r\n      const rect = rects[i];\r\n      // Try to reuse the previously created Node when possible, no need to\r\n      // remove/create on the most common case reposition case\r\n      const rectNode = lastNodes[i] || document.createElement('div');\r\n      const rectNodeStyle = rectNode.style;\r\n      if (rectNodeStyle.position !== 'absolute') {\r\n        rectNodeStyle.position = 'absolute';\r\n        hasRepositioned = true;\r\n      }\r\n      const left = px(rect.left - rootLeft);\r\n      if (rectNodeStyle.left !== left) {\r\n        rectNodeStyle.left = left;\r\n        hasRepositioned = true;\r\n      }\r\n      const top = px(rect.top - rootTop);\r\n      if (rectNodeStyle.top !== top) {\r\n        rectNode.style.top = top;\r\n        hasRepositioned = true;\r\n      }\r\n      const width = px(rect.width);\r\n      if (rectNodeStyle.width !== width) {\r\n        rectNode.style.width = width;\r\n        hasRepositioned = true;\r\n      }\r\n      const height = px(rect.height);\r\n      if (rectNodeStyle.height !== height) {\r\n        rectNode.style.height = height;\r\n        hasRepositioned = true;\r\n      }\r\n      if (rectNode.parentNode !== wrapperNode) {\r\n        wrapperNode.append(rectNode);\r\n        hasRepositioned = true;\r\n      }\r\n      lastNodes[i] = rectNode;\r\n    }\r\n    while (lastNodes.length > rects.length) {\r\n      lastNodes.pop();\r\n    }\r\n    if (hasRepositioned) {\r\n      onReposition(lastNodes);\r\n    }\r\n  }\r\n  function stop() {\r\n    parentDOMNode = null;\r\n    rootDOMNode = null;\r\n    if (observer !== null) {\r\n      observer.disconnect();\r\n    }\r\n    observer = null;\r\n    wrapperNode.remove();\r\n    for (const node of lastNodes) {\r\n      node.remove();\r\n    }\r\n    lastNodes = [];\r\n  }\r\n  function restart() {\r\n    const currentRootDOMNode = editor.getRootElement();\r\n    if (currentRootDOMNode === null) {\r\n      return stop();\r\n    }\r\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\r\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\r\n      return stop();\r\n    }\r\n    stop();\r\n    rootDOMNode = currentRootDOMNode;\r\n    parentDOMNode = currentParentDOMNode;\r\n    observer = new MutationObserver(mutations => {\r\n      const nextRootDOMNode = editor.getRootElement();\r\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\r\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\r\n        return restart();\r\n      }\r\n      for (const mutation of mutations) {\r\n        if (!wrapperNode.contains(mutation.target)) {\r\n          // TODO throttle\r\n          return position();\r\n        }\r\n      }\r\n    });\r\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\r\n    position();\r\n  }\r\n  const removeRootListener = editor.registerRootListener(restart);\r\n  return () => {\r\n    removeRootListener();\r\n    stop();\r\n  };\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction markSelection(editor, onReposition) {\r\n  let previousAnchorNode = null;\r\n  let previousAnchorOffset = null;\r\n  let previousFocusNode = null;\r\n  let previousFocusOffset = null;\r\n  let removeRangeListener = () => {};\r\n  function compute(editorState) {\r\n    editorState.read(() => {\r\n      const selection = lexical.$getSelection();\r\n      if (!lexical.$isRangeSelection(selection)) {\r\n        // TODO\r\n        previousAnchorNode = null;\r\n        previousAnchorOffset = null;\r\n        previousFocusNode = null;\r\n        previousFocusOffset = null;\r\n        removeRangeListener();\r\n        removeRangeListener = () => {};\r\n        return;\r\n      }\r\n      const {\r\n        anchor,\r\n        focus\r\n      } = selection;\r\n      const currentAnchorNode = anchor.getNode();\r\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\r\n      const currentAnchorOffset = anchor.offset;\r\n      const currentFocusNode = focus.getNode();\r\n      const currentFocusNodeKey = currentFocusNode.getKey();\r\n      const currentFocusOffset = focus.offset;\r\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\r\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\r\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\r\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\r\n      if (differentAnchorDOM || differentFocusDOM) {\r\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\r\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\r\n        // TODO handle selection beyond the common TextNode\r\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\r\n          const range = document.createRange();\r\n          let firstHTMLElement;\r\n          let firstOffset;\r\n          let lastHTMLElement;\r\n          let lastOffset;\r\n          if (focus.isBefore(anchor)) {\r\n            firstHTMLElement = focusHTMLElement;\r\n            firstOffset = focus.offset;\r\n            lastHTMLElement = anchorHTMLElement;\r\n            lastOffset = anchor.offset;\r\n          } else {\r\n            firstHTMLElement = anchorHTMLElement;\r\n            firstOffset = anchor.offset;\r\n            lastHTMLElement = focusHTMLElement;\r\n            lastOffset = focus.offset;\r\n          }\r\n          const firstTextNode = firstHTMLElement.firstChild;\r\n          if (!(firstTextNode !== null)) {\r\n            throw Error(`Expected text node to be first child of span`);\r\n          }\r\n          const lastTextNode = lastHTMLElement.firstChild;\r\n          if (!(lastTextNode !== null)) {\r\n            throw Error(`Expected text node to be first child of span`);\r\n          }\r\n          range.setStart(firstTextNode, firstOffset);\r\n          range.setEnd(lastTextNode, lastOffset);\r\n          removeRangeListener();\r\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\r\n            for (const domNode of domNodes) {\r\n              const domNodeStyle = domNode.style;\r\n              if (domNodeStyle.background !== 'Highlight') {\r\n                domNodeStyle.background = 'Highlight';\r\n              }\r\n              if (domNodeStyle.color !== 'HighlightText') {\r\n                domNodeStyle.color = 'HighlightText';\r\n              }\r\n              if (domNodeStyle.zIndex !== '-1') {\r\n                domNodeStyle.zIndex = '-1';\r\n              }\r\n              if (domNodeStyle.pointerEvents !== 'none') {\r\n                domNodeStyle.pointerEvents = 'none';\r\n              }\r\n              if (domNodeStyle.marginTop !== px(-1.5)) {\r\n                domNodeStyle.marginTop = px(-1.5);\r\n              }\r\n              if (domNodeStyle.paddingTop !== px(4)) {\r\n                domNodeStyle.paddingTop = px(4);\r\n              }\r\n              if (domNodeStyle.paddingBottom !== px(0)) {\r\n                domNodeStyle.paddingBottom = px(0);\r\n              }\r\n            }\r\n            if (onReposition !== undefined) {\r\n              onReposition(domNodes);\r\n            }\r\n          });\r\n        }\r\n      }\r\n      previousAnchorNode = currentAnchorNode;\r\n      previousAnchorOffset = currentAnchorOffset;\r\n      previousFocusNode = currentFocusNode;\r\n      previousFocusOffset = currentFocusOffset;\r\n    });\r\n  }\r\n  compute(editor.getEditorState());\r\n  return mergeRegister(editor.registerUpdateListener(({\r\n    editorState\r\n  }) => compute(editorState)), removeRangeListener, () => {\r\n    removeRangeListener();\r\n  });\r\n}\r\n\r\n/** @module @lexical/utils */\r\n/**\r\n * Takes an HTML element and adds the classNames passed within an array,\r\n * ignoring any non-string types. A space can be used to add multiple classes\r\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\r\n * will add both 'element-inner' and 'active' as classes to that element.\r\n * @param element - The element in which the classes are added\r\n * @param classNames - An array defining the class names to add to the element\r\n */\r\nfunction addClassNamesToElement(element, ...classNames) {\r\n  classNames.forEach(className => {\r\n    if (typeof className === 'string') {\r\n      const classesToAdd = className.split(' ').filter(n => n !== '');\r\n      element.classList.add(...classesToAdd);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Takes an HTML element and removes the classNames passed within an array,\r\n * ignoring any non-string types. A space can be used to remove multiple classes\r\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\r\n * will remove both the 'active' and 'small' classes from that element.\r\n * @param element - The element in which the classes are removed\r\n * @param classNames - An array defining the class names to remove from the element\r\n */\r\nfunction removeClassNamesFromElement(element, ...classNames) {\r\n  classNames.forEach(className => {\r\n    if (typeof className === 'string') {\r\n      element.classList.remove(...className.split(' '));\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\r\n * The types passed must be strings and are CASE-SENSITIVE.\r\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\r\n * @param file - The file you want to type check.\r\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\r\n * @returns true if the file is an acceptable mime type, false otherwise.\r\n */\r\nfunction isMimeType(file, acceptableMimeTypes) {\r\n  for (const acceptableType of acceptableMimeTypes) {\r\n    if (file.type.startsWith(acceptableType)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Lexical File Reader with:\r\n *  1. MIME type support\r\n *  2. batched results (HistoryPlugin compatibility)\r\n *  3. Order aware (respects the order when multiple Files are passed)\r\n *\r\n * const filesResult = await mediaFileReader(files, ['image/']);\r\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\r\n *   src: file.result,\r\n * }));\r\n */\r\nfunction mediaFileReader(files, acceptableMimeTypes) {\r\n  const filesIterator = files[Symbol.iterator]();\r\n  return new Promise((resolve, reject) => {\r\n    const processed = [];\r\n    const handleNextFile = () => {\r\n      const {\r\n        done,\r\n        value: file\r\n      } = filesIterator.next();\r\n      if (done) {\r\n        return resolve(processed);\r\n      }\r\n      const fileReader = new FileReader();\r\n      fileReader.addEventListener('error', reject);\r\n      fileReader.addEventListener('load', () => {\r\n        const result = fileReader.result;\r\n        if (typeof result === 'string') {\r\n          processed.push({\r\n            file,\r\n            result\r\n          });\r\n        }\r\n        handleNextFile();\r\n      });\r\n      if (isMimeType(file, acceptableMimeTypes)) {\r\n        fileReader.readAsDataURL(file);\r\n      } else {\r\n        handleNextFile();\r\n      }\r\n    };\r\n    handleNextFile();\r\n  });\r\n}\r\n\r\n/**\r\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\r\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\r\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\r\n * It will then return all the nodes found in the search in an array of objects.\r\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\r\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\r\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\r\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\r\n */\r\nfunction $dfs(startingNode, endingNode) {\r\n  const nodes = [];\r\n  const start = (startingNode || lexical.$getRoot()).getLatest();\r\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\r\n  let node = start;\r\n  let depth = $getDepth(node);\r\n  while (node !== null && !node.is(end)) {\r\n    nodes.push({\r\n      depth,\r\n      node\r\n    });\r\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\r\n      node = node.getFirstChild();\r\n      depth++;\r\n    } else {\r\n      // Find immediate sibling or nearest parent sibling\r\n      let sibling = null;\r\n      while (sibling === null && node !== null) {\r\n        sibling = node.getNextSibling();\r\n        if (sibling === null) {\r\n          node = node.getParent();\r\n          depth--;\r\n        } else {\r\n          node = sibling;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (node !== null && node.is(end)) {\r\n    nodes.push({\r\n      depth,\r\n      node\r\n    });\r\n  }\r\n  return nodes;\r\n}\r\nfunction $getDepth(node) {\r\n  let innerNode = node;\r\n  let depth = 0;\r\n  while ((innerNode = innerNode.getParent()) !== null) {\r\n    depth++;\r\n  }\r\n  return depth;\r\n}\r\n\r\n/**\r\n * Takes a node and traverses up its ancestors (toward the root node)\r\n * in order to find a specific type of node.\r\n * @param node - the node to begin searching.\r\n * @param klass - an instance of the type of node to look for.\r\n * @returns the node of type klass that was passed, or null if none exist.\r\n */\r\nfunction $getNearestNodeOfType(node, klass) {\r\n  let parent = node;\r\n  while (parent != null) {\r\n    if (parent instanceof klass) {\r\n      return parent;\r\n    }\r\n    parent = parent.getParent();\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Returns the element node of the nearest ancestor, otherwise throws an error.\r\n * @param startNode - The starting node of the search\r\n * @returns The ancestor node found\r\n */\r\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\r\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\r\n  if (!lexical.$isElementNode(blockNode)) {\r\n    {\r\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\r\n    }\r\n  }\r\n  return blockNode;\r\n}\r\n/**\r\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\r\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\r\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\r\n * @param startingNode - The node where the search starts.\r\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\r\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\r\n */\r\nconst $findMatchingParent = (startingNode, findFn) => {\r\n  let curr = startingNode;\r\n  while (curr !== lexical.$getRoot() && curr != null) {\r\n    if (findFn(curr)) {\r\n      return curr;\r\n    }\r\n    curr = curr.getParent();\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\r\n * It is generally used for marks/commenting\r\n * @param editor - The lexical editor\r\n * @param targetNode - The target for the nested element to be extracted from.\r\n * @param cloneNode - See {@link $createMarkNode}\r\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\r\n * @returns The lexical editor\r\n */\r\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\r\n  const $isTargetNode = node => {\r\n    return node instanceof targetNode;\r\n  };\r\n  const $findMatch = node => {\r\n    // First validate we don't have any children that are of the target,\r\n    // as we need to handle them first.\r\n    const children = node.getChildren();\r\n    for (let i = 0; i < children.length; i++) {\r\n      const child = children[i];\r\n      if ($isTargetNode(child)) {\r\n        return null;\r\n      }\r\n    }\r\n    let parentNode = node;\r\n    let childNode = node;\r\n    while (parentNode !== null) {\r\n      childNode = parentNode;\r\n      parentNode = parentNode.getParent();\r\n      if ($isTargetNode(parentNode)) {\r\n        return {\r\n          child: childNode,\r\n          parent: parentNode\r\n        };\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n  const elementNodeTransform = node => {\r\n    const match = $findMatch(node);\r\n    if (match !== null) {\r\n      const {\r\n        child,\r\n        parent\r\n      } = match;\r\n\r\n      // Simple path, we can move child out and siblings into a new parent.\r\n\r\n      if (child.is(node)) {\r\n        handleOverlap(parent, node);\r\n        const nextSiblings = child.getNextSiblings();\r\n        const nextSiblingsLength = nextSiblings.length;\r\n        parent.insertAfter(child);\r\n        if (nextSiblingsLength !== 0) {\r\n          const newParent = cloneNode(parent);\r\n          child.insertAfter(newParent);\r\n          for (let i = 0; i < nextSiblingsLength; i++) {\r\n            newParent.append(nextSiblings[i]);\r\n          }\r\n        }\r\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\r\n          parent.remove();\r\n        }\r\n      }\r\n    }\r\n  };\r\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\r\n}\r\n\r\n/**\r\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\r\n * it would be set back to its previous state, or null otherwise.\r\n * @param editor - The lexical editor\r\n * @param editorState - The editor's state\r\n */\r\nfunction $restoreEditorState(editor, editorState) {\r\n  const FULL_RECONCILE = 2;\r\n  const nodeMap = new Map();\r\n  const activeEditorState = editor._pendingEditorState;\r\n  for (const [key, node] of editorState._nodeMap) {\r\n    const clone = selection.$cloneWithProperties(node);\r\n    if (lexical.$isTextNode(clone)) {\r\n      if (!lexical.$isTextNode(node)) {\r\n        throw Error(`Expected node be a TextNode`);\r\n      }\r\n      clone.__text = node.__text;\r\n    }\r\n    nodeMap.set(key, clone);\r\n  }\r\n  if (activeEditorState) {\r\n    activeEditorState._nodeMap = nodeMap;\r\n  }\r\n  editor._dirtyType = FULL_RECONCILE;\r\n  const selection$1 = editorState._selection;\r\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\r\n}\r\n\r\n/**\r\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\r\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\r\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\r\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\r\n * @param node - The node to be inserted\r\n * @returns The node after its insertion\r\n */\r\nfunction $insertNodeToNearestRoot(node) {\r\n  const selection = lexical.$getSelection() || lexical.$getPreviousSelection();\r\n  if (lexical.$isRangeSelection(selection)) {\r\n    const {\r\n      focus\r\n    } = selection;\r\n    const focusNode = focus.getNode();\r\n    const focusOffset = focus.offset;\r\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\r\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\r\n      if (focusChild == null) {\r\n        focusNode.append(node);\r\n      } else {\r\n        focusChild.insertBefore(node);\r\n      }\r\n      node.selectNext();\r\n    } else {\r\n      let splitNode;\r\n      let splitOffset;\r\n      if (lexical.$isTextNode(focusNode)) {\r\n        splitNode = focusNode.getParentOrThrow();\r\n        splitOffset = focusNode.getIndexWithinParent();\r\n        if (focusOffset > 0) {\r\n          splitOffset += 1;\r\n          focusNode.splitText(focusOffset);\r\n        }\r\n      } else {\r\n        splitNode = focusNode;\r\n        splitOffset = focusOffset;\r\n      }\r\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\r\n      rightTree.insertBefore(node);\r\n      rightTree.selectStart();\r\n    }\r\n  } else {\r\n    if (selection != null) {\r\n      const nodes = selection.getNodes();\r\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\r\n    } else {\r\n      const root = lexical.$getRoot();\r\n      root.append(node);\r\n    }\r\n    const paragraphNode = lexical.$createParagraphNode();\r\n    node.insertAfter(paragraphNode);\r\n    paragraphNode.select();\r\n  }\r\n  return node.getLatest();\r\n}\r\n\r\n/**\r\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\r\n * @param node - Node to be wrapped.\r\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\r\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\r\n */\r\nfunction $wrapNodeInElement(node, createElementNode) {\r\n  const elementNode = createElementNode();\r\n  node.replace(elementNode);\r\n  elementNode.append(node);\r\n  return elementNode;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\r\n/**\r\n * @param object = The instance of the type\r\n * @param objectClass = The class of the type\r\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\r\n */\r\nfunction objectKlassEquals(object, objectClass) {\r\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\r\n}\r\n\r\n/**\r\n * Filter the nodes\r\n * @param nodes Array of nodes that needs to be filtered\r\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\r\n * @returns Array of filtered nodes\r\n */\r\n\r\nfunction $filter(nodes, filterFn) {\r\n  const result = [];\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = filterFn(nodes[i]);\r\n    if (node !== null) {\r\n      result.push(node);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n/**\r\n * Appends the node before the first child of the parent node\r\n * @param parent A parent node\r\n * @param node Node that needs to be appended\r\n */\r\nfunction $insertFirst(parent, node) {\r\n  const firstChild = parent.getFirstChild();\r\n  if (firstChild !== null) {\r\n    firstChild.insertBefore(node);\r\n  } else {\r\n    parent.append(node);\r\n  }\r\n}\r\n\r\nexports.$splitNode = lexical.$splitNode;\r\nexports.isHTMLAnchorElement = lexical.isHTMLAnchorElement;\r\nexports.isHTMLElement = lexical.isHTMLElement;\r\nexports.$dfs = $dfs;\r\nexports.$filter = $filter;\r\nexports.$findMatchingParent = $findMatchingParent;\r\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\r\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\r\nexports.$insertFirst = $insertFirst;\r\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\r\nexports.$restoreEditorState = $restoreEditorState;\r\nexports.$wrapNodeInElement = $wrapNodeInElement;\r\nexports.addClassNamesToElement = addClassNamesToElement;\r\nexports.isMimeType = isMimeType;\r\nexports.markSelection = markSelection;\r\nexports.mediaFileReader = mediaFileReader;\r\nexports.mergeRegister = mergeRegister;\r\nexports.objectKlassEquals = objectKlassEquals;\r\nexports.positionNodeOnRange = positionNodeOnRange;\r\nexports.registerNestedElementResolver = registerNestedElementResolver;\r\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst LexicalUtils = process.env.NODE_ENV === 'development' ? require('./LexicalUtils.dev.js') : require('./LexicalUtils.prod.js')\r\nmodule.exports = LexicalUtils;"],
  "mappings": "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",
  "names": ["selection"]
}
