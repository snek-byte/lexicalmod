{
  "version": 3,
  "sources": ["../../@lexical/table/LexicalTable.dev.js", "../../@lexical/table/LexicalTable.js"],
  "sourcesContent": ["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar utils = require('@lexical/utils');\r\nvar lexical = require('lexical');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst TableCellHeaderStates = {\r\n  BOTH: 3,\r\n  COLUMN: 2,\r\n  NO_STATUS: 0,\r\n  ROW: 1\r\n};\r\n/** @noInheritDoc */\r\nclass TableCellNode extends lexical.ElementNode {\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  static getType() {\r\n    return 'tablecell';\r\n  }\r\n  static clone(node) {\r\n    const cellNode = new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\r\n    cellNode.__rowSpan = node.__rowSpan;\r\n    cellNode.__backgroundColor = node.__backgroundColor;\r\n    return cellNode;\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      td: node => ({\r\n        conversion: convertTableCellNodeElement,\r\n        priority: 0\r\n      }),\r\n      th: node => ({\r\n        conversion: convertTableCellNodeElement,\r\n        priority: 0\r\n      })\r\n    };\r\n  }\r\n  static importJSON(serializedNode) {\r\n    const colSpan = serializedNode.colSpan || 1;\r\n    const rowSpan = serializedNode.rowSpan || 1;\r\n    const cellNode = $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined);\r\n    cellNode.__rowSpan = rowSpan;\r\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\r\n    return cellNode;\r\n  }\r\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\r\n    super(key);\r\n    this.__colSpan = colSpan;\r\n    this.__rowSpan = 1;\r\n    this.__headerState = headerState;\r\n    this.__width = width;\r\n    this.__backgroundColor = null;\r\n  }\r\n  createDOM(config) {\r\n    const element = document.createElement(this.getTag());\r\n    if (this.__width) {\r\n      element.style.width = `${this.__width}px`;\r\n    }\r\n    if (this.__colSpan > 1) {\r\n      element.colSpan = this.__colSpan;\r\n    }\r\n    if (this.__rowSpan > 1) {\r\n      element.rowSpan = this.__rowSpan;\r\n    }\r\n    if (this.__backgroundColor !== null) {\r\n      element.style.backgroundColor = this.__backgroundColor;\r\n    }\r\n    utils.addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\r\n    return element;\r\n  }\r\n  exportDOM(editor) {\r\n    const {\r\n      element\r\n    } = super.exportDOM(editor);\r\n    if (element) {\r\n      const element_ = element;\r\n      const maxWidth = 700;\r\n      const colCount = this.getParentOrThrow().getChildrenSize();\r\n      element_.style.border = '1px solid black';\r\n      if (this.__colSpan > 1) {\r\n        element_.colSpan = this.__colSpan;\r\n      }\r\n      if (this.__rowSpan > 1) {\r\n        element_.rowSpan = this.__rowSpan;\r\n      }\r\n      element_.style.width = `${this.getWidth() || Math.max(90, maxWidth / colCount)}px`;\r\n      element_.style.verticalAlign = 'top';\r\n      element_.style.textAlign = 'start';\r\n      const backgroundColor = this.getBackgroundColor();\r\n      if (backgroundColor !== null) {\r\n        element_.style.backgroundColor = backgroundColor;\r\n      } else if (this.hasHeader()) {\r\n        element_.style.backgroundColor = '#f2f3f5';\r\n      }\r\n    }\r\n    return {\r\n      element\r\n    };\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      backgroundColor: this.getBackgroundColor(),\r\n      colSpan: this.__colSpan,\r\n      headerState: this.__headerState,\r\n      rowSpan: this.__rowSpan,\r\n      type: 'tablecell',\r\n      width: this.getWidth()\r\n    };\r\n  }\r\n  getColSpan() {\r\n    return this.__colSpan;\r\n  }\r\n  setColSpan(colSpan) {\r\n    this.getWritable().__colSpan = colSpan;\r\n    return this;\r\n  }\r\n  getRowSpan() {\r\n    return this.__rowSpan;\r\n  }\r\n  setRowSpan(rowSpan) {\r\n    this.getWritable().__rowSpan = rowSpan;\r\n    return this;\r\n  }\r\n  getTag() {\r\n    return this.hasHeader() ? 'th' : 'td';\r\n  }\r\n  setHeaderStyles(headerState) {\r\n    const self = this.getWritable();\r\n    self.__headerState = headerState;\r\n    return this.__headerState;\r\n  }\r\n  getHeaderStyles() {\r\n    return this.getLatest().__headerState;\r\n  }\r\n  setWidth(width) {\r\n    const self = this.getWritable();\r\n    self.__width = width;\r\n    return this.__width;\r\n  }\r\n  getWidth() {\r\n    return this.getLatest().__width;\r\n  }\r\n  getBackgroundColor() {\r\n    return this.getLatest().__backgroundColor;\r\n  }\r\n  setBackgroundColor(newBackgroundColor) {\r\n    this.getWritable().__backgroundColor = newBackgroundColor;\r\n  }\r\n  toggleHeaderStyle(headerStateToToggle) {\r\n    const self = this.getWritable();\r\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\r\n      self.__headerState -= headerStateToToggle;\r\n    } else {\r\n      self.__headerState += headerStateToToggle;\r\n    }\r\n    return self;\r\n  }\r\n  hasHeaderState(headerState) {\r\n    return (this.getHeaderStyles() & headerState) === headerState;\r\n  }\r\n  hasHeader() {\r\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\r\n  }\r\n  updateDOM(prevNode) {\r\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\r\n  }\r\n  isShadowRoot() {\r\n    return true;\r\n  }\r\n  collapseAtStart() {\r\n    return true;\r\n  }\r\n  canBeEmpty() {\r\n    return false;\r\n  }\r\n  canIndent() {\r\n    return false;\r\n  }\r\n}\r\nfunction convertTableCellNodeElement(domNode) {\r\n  const domNode_ = domNode;\r\n  const nodeName = domNode.nodeName.toLowerCase();\r\n  let width = undefined;\r\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\r\n    width = parseFloat(domNode_.style.width);\r\n  }\r\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\r\n  tableCellNode.__rowSpan = domNode_.rowSpan;\r\n  const backgroundColor = domNode_.style.backgroundColor;\r\n  if (backgroundColor !== '') {\r\n    tableCellNode.__backgroundColor = backgroundColor;\r\n  }\r\n  return {\r\n    forChild: (lexicalNode, parentLexicalNode) => {\r\n      if ($isTableCellNode(parentLexicalNode) && !lexical.$isElementNode(lexicalNode)) {\r\n        const paragraphNode = lexical.$createParagraphNode();\r\n        if (lexical.$isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\r\n          return null;\r\n        }\r\n        paragraphNode.append(lexicalNode);\r\n        return paragraphNode;\r\n      }\r\n      return lexicalNode;\r\n    },\r\n    node: tableCellNode\r\n  };\r\n}\r\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\r\n  return lexical.$applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\r\n}\r\nfunction $isTableCellNode(node) {\r\n  return node instanceof TableCellNode;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst INSERT_TABLE_COMMAND = lexical.createCommand('INSERT_TABLE_COMMAND');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass TableRowNode extends lexical.ElementNode {\r\n  /** @internal */\r\n\r\n  static getType() {\r\n    return 'tablerow';\r\n  }\r\n  static clone(node) {\r\n    return new TableRowNode(node.__height, node.__key);\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      tr: node => ({\r\n        conversion: convertTableRowElement,\r\n        priority: 0\r\n      })\r\n    };\r\n  }\r\n  static importJSON(serializedNode) {\r\n    return $createTableRowNode(serializedNode.height);\r\n  }\r\n  constructor(height, key) {\r\n    super(key);\r\n    this.__height = height;\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      type: 'tablerow',\r\n      version: 1\r\n    };\r\n  }\r\n  createDOM(config) {\r\n    const element = document.createElement('tr');\r\n    if (this.__height) {\r\n      element.style.height = `${this.__height}px`;\r\n    }\r\n    utils.addClassNamesToElement(element, config.theme.tableRow);\r\n    return element;\r\n  }\r\n  isShadowRoot() {\r\n    return true;\r\n  }\r\n  setHeight(height) {\r\n    const self = this.getWritable();\r\n    self.__height = height;\r\n    return this.__height;\r\n  }\r\n  getHeight() {\r\n    return this.getLatest().__height;\r\n  }\r\n  updateDOM(prevNode) {\r\n    return prevNode.__height !== this.__height;\r\n  }\r\n  canBeEmpty() {\r\n    return false;\r\n  }\r\n  canIndent() {\r\n    return false;\r\n  }\r\n}\r\nfunction convertTableRowElement(domNode) {\r\n  const domNode_ = domNode;\r\n  let height = undefined;\r\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\r\n    height = parseFloat(domNode_.style.height);\r\n  }\r\n  return {\r\n    node: $createTableRowNode(height)\r\n  };\r\n}\r\nfunction $createTableRowNode(height) {\r\n  return lexical.$applyNodeReplacement(new TableRowNode(height));\r\n}\r\nfunction $isTableRowNode(node) {\r\n  return node instanceof TableRowNode;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\r\n  const tableNode = $createTableNode();\r\n  for (let iRow = 0; iRow < rowCount; iRow++) {\r\n    const tableRowNode = $createTableRowNode();\r\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\r\n      let headerState = TableCellHeaderStates.NO_STATUS;\r\n      if (typeof includeHeaders === 'object') {\r\n        if (iRow === 0 && includeHeaders.rows) headerState |= TableCellHeaderStates.ROW;\r\n        if (iColumn === 0 && includeHeaders.columns) headerState |= TableCellHeaderStates.COLUMN;\r\n      } else if (includeHeaders) {\r\n        if (iRow === 0) headerState |= TableCellHeaderStates.ROW;\r\n        if (iColumn === 0) headerState |= TableCellHeaderStates.COLUMN;\r\n      }\r\n      const tableCellNode = $createTableCellNode(headerState);\r\n      const paragraphNode = lexical.$createParagraphNode();\r\n      paragraphNode.append(lexical.$createTextNode());\r\n      tableCellNode.append(paragraphNode);\r\n      tableRowNode.append(tableCellNode);\r\n    }\r\n    tableNode.append(tableRowNode);\r\n  }\r\n  return tableNode;\r\n}\r\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\r\n  const node = utils.$findMatchingParent(startingNode, n => $isTableCellNode(n));\r\n  if ($isTableCellNode(node)) {\r\n    return node;\r\n  }\r\n  return null;\r\n}\r\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\r\n  const node = utils.$findMatchingParent(startingNode, n => $isTableRowNode(n));\r\n  if ($isTableRowNode(node)) {\r\n    return node;\r\n  }\r\n  throw new Error('Expected table cell to be inside of table row.');\r\n}\r\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\r\n  const node = utils.$findMatchingParent(startingNode, n => $isTableNode(n));\r\n  if ($isTableNode(node)) {\r\n    return node;\r\n  }\r\n  throw new Error('Expected table cell to be inside of table.');\r\n}\r\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\r\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\r\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\r\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\r\n}\r\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\r\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\r\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\r\n}\r\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\r\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\r\n  const {\r\n    x,\r\n    y\r\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\r\n  return {\r\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\r\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\r\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\r\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\r\n  };\r\n}\r\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\r\n  const tableRows = tableNode.getChildren();\r\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\r\n    throw new Error('Expected table cell to be inside of table row.');\r\n  }\r\n  const targetRowNode = tableRows[indexToDelete];\r\n  targetRowNode.remove();\r\n  return tableNode;\r\n}\r\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\r\n  const tableRows = tableNode.getChildren();\r\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\r\n    throw new Error('Table row target index out of range');\r\n  }\r\n  const targetRowNode = tableRows[targetIndex];\r\n  if ($isTableRowNode(targetRowNode)) {\r\n    for (let r = 0; r < rowCount; r++) {\r\n      const tableRowCells = targetRowNode.getChildren();\r\n      const tableColumnCount = tableRowCells.length;\r\n      const newTableRowNode = $createTableRowNode();\r\n      for (let c = 0; c < tableColumnCount; c++) {\r\n        const tableCellFromTargetRow = tableRowCells[c];\r\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\r\n          throw Error(`Expected table cell`);\r\n        }\r\n        const {\r\n          above,\r\n          below\r\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\r\n        let headerState = TableCellHeaderStates.NO_STATUS;\r\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\r\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\r\n          headerState |= TableCellHeaderStates.COLUMN;\r\n        }\r\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\r\n        tableCellNode.append(lexical.$createParagraphNode());\r\n        newTableRowNode.append(tableCellNode);\r\n      }\r\n      if (shouldInsertAfter) {\r\n        targetRowNode.insertAfter(newTableRowNode);\r\n      } else {\r\n        targetRowNode.insertBefore(newTableRowNode);\r\n      }\r\n    }\r\n  } else {\r\n    throw new Error('Row before insertion index does not exist.');\r\n  }\r\n  return tableNode;\r\n}\r\nconst getHeaderState = (currentState, possibleState) => {\r\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\r\n    return possibleState;\r\n  }\r\n  return TableCellHeaderStates.NO_STATUS;\r\n};\r\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\r\n  const selection = lexical.$getSelection();\r\n  if (!(lexical.$isRangeSelection(selection) || $isTableSelection(selection))) {\r\n    throw Error(`Expected a RangeSelection or GridSelection`);\r\n  }\r\n  const focus = selection.focus.getNode();\r\n  const [focusCell,, grid] = $getNodeTriplet(focus);\r\n  const [gridMap, focusCellMap] = $computeTableMap(grid, focusCell, focusCell);\r\n  const columnCount = gridMap[0].length;\r\n  const {\r\n    startRow: focusStartRow\r\n  } = focusCellMap;\r\n  if (insertAfter) {\r\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\r\n    const focusEndRowMap = gridMap[focusEndRow];\r\n    const newRow = $createTableRowNode();\r\n    for (let i = 0; i < columnCount; i++) {\r\n      const {\r\n        cell,\r\n        startRow\r\n      } = focusEndRowMap[i];\r\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\r\n        const currentCell = focusEndRowMap[i].cell;\r\n        const currentCellHeaderState = currentCell.__headerState;\r\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\r\n        newRow.append($createTableCellNode(headerState).append(lexical.$createParagraphNode()));\r\n      } else {\r\n        cell.setRowSpan(cell.__rowSpan + 1);\r\n      }\r\n    }\r\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\r\n    if (!$isTableRowNode(focusEndRowNode)) {\r\n      throw Error(`focusEndRow is not a TableRowNode`);\r\n    }\r\n    focusEndRowNode.insertAfter(newRow);\r\n  } else {\r\n    const focusStartRowMap = gridMap[focusStartRow];\r\n    const newRow = $createTableRowNode();\r\n    for (let i = 0; i < columnCount; i++) {\r\n      const {\r\n        cell,\r\n        startRow\r\n      } = focusStartRowMap[i];\r\n      if (startRow === focusStartRow) {\r\n        const currentCell = focusStartRowMap[i].cell;\r\n        const currentCellHeaderState = currentCell.__headerState;\r\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\r\n        newRow.append($createTableCellNode(headerState).append(lexical.$createParagraphNode()));\r\n      } else {\r\n        cell.setRowSpan(cell.__rowSpan + 1);\r\n      }\r\n    }\r\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\r\n    if (!$isTableRowNode(focusStartRowNode)) {\r\n      throw Error(`focusEndRow is not a TableRowNode`);\r\n    }\r\n    focusStartRowNode.insertBefore(newRow);\r\n  }\r\n}\r\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\r\n  const tableRows = tableNode.getChildren();\r\n  const tableCellsToBeInserted = [];\r\n  for (let r = 0; r < tableRows.length; r++) {\r\n    const currentTableRowNode = tableRows[r];\r\n    if ($isTableRowNode(currentTableRowNode)) {\r\n      for (let c = 0; c < columnCount; c++) {\r\n        const tableRowChildren = currentTableRowNode.getChildren();\r\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\r\n          throw new Error('Table column target index out of range');\r\n        }\r\n        const targetCell = tableRowChildren[targetIndex];\r\n        if (!$isTableCellNode(targetCell)) {\r\n          throw Error(`Expected table cell`);\r\n        }\r\n        const {\r\n          left,\r\n          right\r\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\r\n        let headerState = TableCellHeaderStates.NO_STATUS;\r\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\r\n          headerState |= TableCellHeaderStates.ROW;\r\n        }\r\n        const newTableCell = $createTableCellNode(headerState);\r\n        newTableCell.append(lexical.$createParagraphNode());\r\n        tableCellsToBeInserted.push({\r\n          newTableCell,\r\n          targetCell\r\n        });\r\n      }\r\n    }\r\n  }\r\n  tableCellsToBeInserted.forEach(({\r\n    newTableCell,\r\n    targetCell\r\n  }) => {\r\n    if (shouldInsertAfter) {\r\n      targetCell.insertAfter(newTableCell);\r\n    } else {\r\n      targetCell.insertBefore(newTableCell);\r\n    }\r\n  });\r\n  return tableNode;\r\n}\r\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\r\n  const selection = lexical.$getSelection();\r\n  if (!(lexical.$isRangeSelection(selection) || $isTableSelection(selection))) {\r\n    throw Error(`Expected a RangeSelection or GridSelection`);\r\n  }\r\n  const anchor = selection.anchor.getNode();\r\n  const focus = selection.focus.getNode();\r\n  const [anchorCell] = $getNodeTriplet(anchor);\r\n  const [focusCell,, grid] = $getNodeTriplet(focus);\r\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\r\n  const rowCount = gridMap.length;\r\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\r\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\r\n  const gridFirstChild = grid.getFirstChild();\r\n  if (!$isTableRowNode(gridFirstChild)) {\r\n    throw Error(`Expected firstTable child to be a row`);\r\n  }\r\n  let firstInsertedCell = null;\r\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\r\n    const cell = $createTableCellNode(headerState).append(lexical.$createParagraphNode());\r\n    if (firstInsertedCell === null) {\r\n      firstInsertedCell = cell;\r\n    }\r\n    return cell;\r\n  }\r\n  let loopRow = gridFirstChild;\r\n  rowLoop: for (let i = 0; i < rowCount; i++) {\r\n    if (i !== 0) {\r\n      const currentRow = loopRow.getNextSibling();\r\n      if (!$isTableRowNode(currentRow)) {\r\n        throw Error(`Expected row nextSibling to be a row`);\r\n      }\r\n      loopRow = currentRow;\r\n    }\r\n    const rowMap = gridMap[i];\r\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\r\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\r\n    if (insertAfterColumn < 0) {\r\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\r\n      continue;\r\n    }\r\n    const {\r\n      cell: currentCell,\r\n      startColumn: currentStartColumn,\r\n      startRow: currentStartRow\r\n    } = rowMap[insertAfterColumn];\r\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\r\n      let insertAfterCell = currentCell;\r\n      let insertAfterCellRowStart = currentStartRow;\r\n      let prevCellIndex = insertAfterColumn;\r\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\r\n        prevCellIndex -= currentCell.__colSpan;\r\n        if (prevCellIndex >= 0) {\r\n          const {\r\n            cell: cell_,\r\n            startRow: startRow_\r\n          } = rowMap[prevCellIndex];\r\n          insertAfterCell = cell_;\r\n          insertAfterCellRowStart = startRow_;\r\n        } else {\r\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\r\n          continue rowLoop;\r\n        }\r\n      }\r\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\r\n    } else {\r\n      currentCell.setColSpan(currentCell.__colSpan + 1);\r\n    }\r\n  }\r\n  if (firstInsertedCell !== null) {\r\n    $moveSelectionToCell(firstInsertedCell);\r\n  }\r\n}\r\nfunction $deleteTableColumn(tableNode, targetIndex) {\r\n  const tableRows = tableNode.getChildren();\r\n  for (let i = 0; i < tableRows.length; i++) {\r\n    const currentTableRowNode = tableRows[i];\r\n    if ($isTableRowNode(currentTableRowNode)) {\r\n      const tableRowChildren = currentTableRowNode.getChildren();\r\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\r\n        throw new Error('Table column target index out of range');\r\n      }\r\n      tableRowChildren[targetIndex].remove();\r\n    }\r\n  }\r\n  return tableNode;\r\n}\r\nfunction $deleteTableRow__EXPERIMENTAL() {\r\n  const selection = lexical.$getSelection();\r\n  if (!(lexical.$isRangeSelection(selection) || $isTableSelection(selection))) {\r\n    throw Error(`Expected a RangeSelection or GridSelection`);\r\n  }\r\n  const anchor = selection.anchor.getNode();\r\n  const focus = selection.focus.getNode();\r\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\r\n  const [focusCell] = $getNodeTriplet(focus);\r\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\r\n  const {\r\n    startRow: anchorStartRow\r\n  } = anchorCellMap;\r\n  const {\r\n    startRow: focusStartRow\r\n  } = focusCellMap;\r\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\r\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\r\n    // Empty grid\r\n    grid.remove();\r\n    return;\r\n  }\r\n  const columnCount = gridMap[0].length;\r\n  const nextRow = gridMap[focusEndRow + 1];\r\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\r\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\r\n    for (let column = columnCount - 1; column >= 0; column--) {\r\n      const {\r\n        cell,\r\n        startRow: cellStartRow,\r\n        startColumn: cellStartColumn\r\n      } = gridMap[row][column];\r\n      if (cellStartColumn !== column) {\r\n        // Don't repeat work for the same Cell\r\n        continue;\r\n      }\r\n      // Rows overflowing top have to be trimmed\r\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\r\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\r\n      }\r\n      // Rows overflowing bottom have to be trimmed and moved to the next row\r\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\r\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\r\n        if (!(nextRowNode !== null)) {\r\n          throw Error(`Expected nextRowNode not to be null`);\r\n        }\r\n        if (column === 0) {\r\n          $insertFirst(nextRowNode, cell);\r\n        } else {\r\n          const {\r\n            cell: previousCell\r\n          } = nextRow[column - 1];\r\n          previousCell.insertAfter(cell);\r\n        }\r\n      }\r\n    }\r\n    const rowNode = grid.getChildAtIndex(row);\r\n    if (!$isTableRowNode(rowNode)) {\r\n      throw Error(`Expected GridNode childAtIndex(${String(row)}) to be RowNode`);\r\n    }\r\n    rowNode.remove();\r\n  }\r\n  if (nextRow !== undefined) {\r\n    const {\r\n      cell\r\n    } = nextRow[0];\r\n    $moveSelectionToCell(cell);\r\n  } else {\r\n    const previousRow = gridMap[anchorStartRow - 1];\r\n    const {\r\n      cell\r\n    } = previousRow[0];\r\n    $moveSelectionToCell(cell);\r\n  }\r\n}\r\nfunction $deleteTableColumn__EXPERIMENTAL() {\r\n  const selection = lexical.$getSelection();\r\n  if (!(lexical.$isRangeSelection(selection) || $isTableSelection(selection))) {\r\n    throw Error(`Expected a RangeSelection or GridSelection`);\r\n  }\r\n  const anchor = selection.anchor.getNode();\r\n  const focus = selection.focus.getNode();\r\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\r\n  const [focusCell] = $getNodeTriplet(focus);\r\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\r\n  const {\r\n    startColumn: anchorStartColumn\r\n  } = anchorCellMap;\r\n  const {\r\n    startRow: focusStartRow,\r\n    startColumn: focusStartColumn\r\n  } = focusCellMap;\r\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\r\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\r\n  const selectedColumnCount = endColumn - startColumn + 1;\r\n  const columnCount = gridMap[0].length;\r\n  if (columnCount === endColumn - startColumn + 1) {\r\n    // Empty grid\r\n    grid.selectPrevious();\r\n    grid.remove();\r\n    return;\r\n  }\r\n  const rowCount = gridMap.length;\r\n  for (let row = 0; row < rowCount; row++) {\r\n    for (let column = startColumn; column <= endColumn; column++) {\r\n      const {\r\n        cell,\r\n        startColumn: cellStartColumn\r\n      } = gridMap[row][column];\r\n      if (cellStartColumn < startColumn) {\r\n        if (column === startColumn) {\r\n          const overflowLeft = startColumn - cellStartColumn;\r\n          // Overflowing left\r\n          cell.setColSpan(cell.__colSpan -\r\n          // Possible overflow right too\r\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\r\n        }\r\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\r\n        if (column === endColumn) {\r\n          // Overflowing right\r\n          const inSelectedArea = endColumn - cellStartColumn + 1;\r\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\r\n        }\r\n      } else {\r\n        cell.remove();\r\n      }\r\n    }\r\n  }\r\n  const focusRowMap = gridMap[focusStartRow];\r\n  const nextColumn = focusRowMap[focusStartColumn + focusCell.__colSpan];\r\n  if (nextColumn !== undefined) {\r\n    const {\r\n      cell\r\n    } = nextColumn;\r\n    $moveSelectionToCell(cell);\r\n  } else {\r\n    const previousRow = focusRowMap[focusStartColumn - 1];\r\n    const {\r\n      cell\r\n    } = previousRow;\r\n    $moveSelectionToCell(cell);\r\n  }\r\n}\r\nfunction $moveSelectionToCell(cell) {\r\n  const firstDescendant = cell.getFirstDescendant();\r\n  if (firstDescendant == null) {\r\n    cell.selectStart();\r\n  } else {\r\n    firstDescendant.getParentOrThrow().selectStart();\r\n  }\r\n}\r\nfunction $insertFirst(parent, node) {\r\n  const firstChild = parent.getFirstChild();\r\n  if (firstChild !== null) {\r\n    firstChild.insertBefore(node);\r\n  } else {\r\n    parent.append(node);\r\n  }\r\n}\r\nfunction $unmergeCell() {\r\n  const selection = lexical.$getSelection();\r\n  if (!(lexical.$isRangeSelection(selection) || $isTableSelection(selection))) {\r\n    throw Error(`Expected a RangeSelection or GridSelection`);\r\n  }\r\n  const anchor = selection.anchor.getNode();\r\n  const [cell, row, grid] = $getNodeTriplet(anchor);\r\n  const colSpan = cell.__colSpan;\r\n  const rowSpan = cell.__rowSpan;\r\n  if (colSpan > 1) {\r\n    for (let i = 1; i < colSpan; i++) {\r\n      cell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\r\n    }\r\n    cell.setColSpan(1);\r\n  }\r\n  if (rowSpan > 1) {\r\n    const [map, cellMap] = $computeTableMap(grid, cell, cell);\r\n    const {\r\n      startColumn,\r\n      startRow\r\n    } = cellMap;\r\n    let currentRowNode;\r\n    for (let i = 1; i < rowSpan; i++) {\r\n      const currentRow = startRow + i;\r\n      const currentRowMap = map[currentRow];\r\n      currentRowNode = (currentRowNode || row).getNextSibling();\r\n      if (!$isTableRowNode(currentRowNode)) {\r\n        throw Error(`Expected row next sibling to be a row`);\r\n      }\r\n      let insertAfterCell = null;\r\n      for (let column = 0; column < startColumn; column++) {\r\n        const currentCellMap = currentRowMap[column];\r\n        const currentCell = currentCellMap.cell;\r\n        if (currentCellMap.startRow === currentRow) {\r\n          insertAfterCell = currentCell;\r\n        }\r\n        if (currentCell.__colSpan > 1) {\r\n          column += currentCell.__colSpan - 1;\r\n        }\r\n      }\r\n      if (insertAfterCell === null) {\r\n        for (let j = 0; j < colSpan; j++) {\r\n          $insertFirst(currentRowNode, $createTableCellNode(TableCellHeaderStates.NO_STATUS));\r\n        }\r\n      } else {\r\n        for (let j = 0; j < colSpan; j++) {\r\n          insertAfterCell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\r\n        }\r\n      }\r\n    }\r\n    cell.setRowSpan(1);\r\n  }\r\n}\r\nfunction $computeTableMap(grid, cellA, cellB) {\r\n  const tableMap = [];\r\n  let cellAValue = null;\r\n  let cellBValue = null;\r\n  function write(startRow, startColumn, cell) {\r\n    const value = {\r\n      cell,\r\n      startColumn,\r\n      startRow\r\n    };\r\n    const rowSpan = cell.__rowSpan;\r\n    const colSpan = cell.__colSpan;\r\n    for (let i = 0; i < rowSpan; i++) {\r\n      if (tableMap[startRow + i] === undefined) {\r\n        tableMap[startRow + i] = [];\r\n      }\r\n      for (let j = 0; j < colSpan; j++) {\r\n        tableMap[startRow + i][startColumn + j] = value;\r\n      }\r\n    }\r\n    if (cellA.is(cell)) {\r\n      cellAValue = value;\r\n    }\r\n    if (cellB.is(cell)) {\r\n      cellBValue = value;\r\n    }\r\n  }\r\n  function isEmpty(row, column) {\r\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\r\n  }\r\n  const gridChildren = grid.getChildren();\r\n  for (let i = 0; i < gridChildren.length; i++) {\r\n    const row = gridChildren[i];\r\n    if (!$isTableRowNode(row)) {\r\n      throw Error(`Expected GridNode children to be TableRowNode`);\r\n    }\r\n    const rowChildren = row.getChildren();\r\n    let j = 0;\r\n    for (const cell of rowChildren) {\r\n      if (!$isTableCellNode(cell)) {\r\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\r\n      }\r\n      while (!isEmpty(i, j)) {\r\n        j++;\r\n      }\r\n      write(i, j, cell);\r\n      j += cell.__colSpan;\r\n    }\r\n  }\r\n  if (!(cellAValue !== null)) {\r\n    throw Error(`Anchor not found in Grid`);\r\n  }\r\n  if (!(cellBValue !== null)) {\r\n    throw Error(`Focus not found in Grid`);\r\n  }\r\n  return [tableMap, cellAValue, cellBValue];\r\n}\r\nfunction $getNodeTriplet(source) {\r\n  let cell;\r\n  if (source instanceof TableCellNode) {\r\n    cell = source;\r\n  } else if ('__type' in source) {\r\n    const cell_ = utils.$findMatchingParent(source, $isTableCellNode);\r\n    if (!$isTableCellNode(cell_)) {\r\n      throw Error(`Expected to find a parent TableCellNode`);\r\n    }\r\n    cell = cell_;\r\n  } else {\r\n    const cell_ = utils.$findMatchingParent(source.getNode(), $isTableCellNode);\r\n    if (!$isTableCellNode(cell_)) {\r\n      throw Error(`Expected to find a parent TableCellNode`);\r\n    }\r\n    cell = cell_;\r\n  }\r\n  const row = cell.getParent();\r\n  if (!$isTableRowNode(row)) {\r\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\r\n  }\r\n  const grid = row.getParent();\r\n  if (!$isTableNode(grid)) {\r\n    throw Error(`Expected TableRowNode to have a parent GridNode`);\r\n  }\r\n  return [cell, row, grid];\r\n}\r\nfunction $getTableCellNodeRect(tableCellNode) {\r\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\r\n  const rows = gridNode.getChildren();\r\n  const rowCount = rows.length;\r\n  const columnCount = rows[0].getChildren().length;\r\n\r\n  // Create a matrix of the same size as the table to track the position of each cell\r\n  const cellMatrix = new Array(rowCount);\r\n  for (let i = 0; i < rowCount; i++) {\r\n    cellMatrix[i] = new Array(columnCount);\r\n  }\r\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\r\n    const row = rows[rowIndex];\r\n    const cells = row.getChildren();\r\n    let columnIndex = 0;\r\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\r\n      // Find the next available position in the matrix, skip the position of merged cells\r\n      while (cellMatrix[rowIndex][columnIndex]) {\r\n        columnIndex++;\r\n      }\r\n      const cell = cells[cellIndex];\r\n      const rowSpan = cell.__rowSpan || 1;\r\n      const colSpan = cell.__colSpan || 1;\r\n\r\n      // Put the cell into the corresponding position in the matrix\r\n      for (let i = 0; i < rowSpan; i++) {\r\n        for (let j = 0; j < colSpan; j++) {\r\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\r\n        }\r\n      }\r\n\r\n      // Return to the original index, row span and column span of the cell.\r\n      if (cellNode === cell) {\r\n        return {\r\n          colSpan,\r\n          columnIndex,\r\n          rowIndex,\r\n          rowSpan\r\n        };\r\n      }\r\n      columnIndex += colSpan;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nclass TableSelection {\r\n  constructor(tableKey, anchor, focus) {\r\n    this.anchor = anchor;\r\n    this.focus = focus;\r\n    anchor._selection = this;\r\n    focus._selection = this;\r\n    this._cachedNodes = null;\r\n    this.dirty = false;\r\n    this.tableKey = tableKey;\r\n  }\r\n  getStartEndPoints() {\r\n    return [this.anchor, this.focus];\r\n  }\r\n\r\n  /**\r\n   * Returns whether the Selection is \"backwards\", meaning the focus\r\n   * logically precedes the anchor in the EditorState.\r\n   * @returns true if the Selection is backwards, false otherwise.\r\n   */\r\n  isBackward() {\r\n    return this.focus.isBefore(this.anchor);\r\n  }\r\n  getCachedNodes() {\r\n    return this._cachedNodes;\r\n  }\r\n  setCachedNodes(nodes) {\r\n    this._cachedNodes = nodes;\r\n  }\r\n  is(selection) {\r\n    if (!$isTableSelection(selection)) {\r\n      return false;\r\n    }\r\n    return this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\r\n  }\r\n  set(tableKey, anchorCellKey, focusCellKey) {\r\n    this.dirty = true;\r\n    this.tableKey = tableKey;\r\n    this.anchor.key = anchorCellKey;\r\n    this.focus.key = focusCellKey;\r\n    this._cachedNodes = null;\r\n  }\r\n  clone() {\r\n    return new TableSelection(this.tableKey, this.anchor, this.focus);\r\n  }\r\n  isCollapsed() {\r\n    return false;\r\n  }\r\n  extract() {\r\n    return this.getNodes();\r\n  }\r\n  insertRawText(text) {\r\n    // Do nothing?\r\n  }\r\n  insertText() {\r\n    // Do nothing?\r\n  }\r\n  insertNodes(nodes) {\r\n    const focusNode = this.focus.getNode();\r\n    if (!lexical.$isElementNode(focusNode)) {\r\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\r\n    }\r\n    const selection = lexical.$normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\r\n    selection.insertNodes(nodes);\r\n  }\r\n\r\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\r\n  getShape() {\r\n    const anchorCellNode = lexical.$getNodeByKey(this.anchor.key);\r\n    if (!$isTableCellNode(anchorCellNode)) {\r\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\r\n    }\r\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCellNode);\r\n    if (!(anchorCellNodeRect !== null)) {\r\n      throw Error(`getCellRect: expected to find AnchorNode`);\r\n    }\r\n    const focusCellNode = lexical.$getNodeByKey(this.focus.key);\r\n    if (!$isTableCellNode(focusCellNode)) {\r\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\r\n    }\r\n    const focusCellNodeRect = $getTableCellNodeRect(focusCellNode);\r\n    if (!(focusCellNodeRect !== null)) {\r\n      throw Error(`getCellRect: expected to find focusCellNode`);\r\n    }\r\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\r\n    const stopX = Math.max(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\r\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\r\n    const stopY = Math.max(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\r\n    return {\r\n      fromX: Math.min(startX, stopX),\r\n      fromY: Math.min(startY, stopY),\r\n      toX: Math.max(startX, stopX),\r\n      toY: Math.max(startY, stopY)\r\n    };\r\n  }\r\n  getNodes() {\r\n    const cachedNodes = this._cachedNodes;\r\n    if (cachedNodes !== null) {\r\n      return cachedNodes;\r\n    }\r\n    const anchorNode = this.anchor.getNode();\r\n    const focusNode = this.focus.getNode();\r\n    const anchorCell = utils.$findMatchingParent(anchorNode, $isTableCellNode);\r\n    // todo replace with triplet\r\n    const focusCell = utils.$findMatchingParent(focusNode, $isTableCellNode);\r\n    if (!$isTableCellNode(anchorCell)) {\r\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\r\n    }\r\n    if (!$isTableCellNode(focusCell)) {\r\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\r\n    }\r\n    const anchorRow = anchorCell.getParent();\r\n    if (!$isTableRowNode(anchorRow)) {\r\n      throw Error(`Expected anchorCell to have a parent TableRowNode`);\r\n    }\r\n    const tableNode = anchorRow.getParent();\r\n    if (!$isTableNode(tableNode)) {\r\n      throw Error(`Expected tableNode to have a parent TableNode`);\r\n    }\r\n    const focusCellGrid = focusCell.getParents()[1];\r\n    if (focusCellGrid !== tableNode) {\r\n      if (!tableNode.isParentOf(focusCell)) {\r\n        // focus is on higher Grid level than anchor\r\n        const gridParent = tableNode.getParent();\r\n        if (!(gridParent != null)) {\r\n          throw Error(`Expected gridParent to have a parent`);\r\n        }\r\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\r\n      } else {\r\n        // anchor is on higher Grid level than focus\r\n        const focusCellParent = focusCellGrid.getParent();\r\n        if (!(focusCellParent != null)) {\r\n          throw Error(`Expected focusCellParent to have a parent`);\r\n        }\r\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\r\n      }\r\n      return this.getNodes();\r\n    }\r\n\r\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\r\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\r\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\r\n    // this possible.\r\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\r\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\r\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\r\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\r\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\r\n    let exploredMinColumn = minColumn;\r\n    let exploredMinRow = minRow;\r\n    let exploredMaxColumn = minColumn;\r\n    let exploredMaxRow = minRow;\r\n    function expandBoundary(mapValue) {\r\n      const {\r\n        cell,\r\n        startColumn: cellStartColumn,\r\n        startRow: cellStartRow\r\n      } = mapValue;\r\n      minColumn = Math.min(minColumn, cellStartColumn);\r\n      minRow = Math.min(minRow, cellStartRow);\r\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\r\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\r\n    }\r\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\r\n      if (minColumn < exploredMinColumn) {\r\n        // Expand on the left\r\n        const rowDiff = exploredMaxRow - exploredMinRow;\r\n        const previousColumn = exploredMinColumn - 1;\r\n        for (let i = 0; i <= rowDiff; i++) {\r\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\r\n        }\r\n        exploredMinColumn = previousColumn;\r\n      }\r\n      if (minRow < exploredMinRow) {\r\n        // Expand on top\r\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\r\n        const previousRow = exploredMinRow - 1;\r\n        for (let i = 0; i <= columnDiff; i++) {\r\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\r\n        }\r\n        exploredMinRow = previousRow;\r\n      }\r\n      if (maxColumn > exploredMaxColumn) {\r\n        // Expand on the right\r\n        const rowDiff = exploredMaxRow - exploredMinRow;\r\n        const nextColumn = exploredMaxColumn + 1;\r\n        for (let i = 0; i <= rowDiff; i++) {\r\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\r\n        }\r\n        exploredMaxColumn = nextColumn;\r\n      }\r\n      if (maxRow > exploredMaxRow) {\r\n        // Expand on the bottom\r\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\r\n        const nextRow = exploredMaxRow + 1;\r\n        for (let i = 0; i <= columnDiff; i++) {\r\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\r\n        }\r\n        exploredMaxRow = nextRow;\r\n      }\r\n    }\r\n    const nodes = [tableNode];\r\n    let lastRow = null;\r\n    for (let i = minRow; i <= maxRow; i++) {\r\n      for (let j = minColumn; j <= maxColumn; j++) {\r\n        const {\r\n          cell\r\n        } = map[i][j];\r\n        const currentRow = cell.getParent();\r\n        if (!$isTableRowNode(currentRow)) {\r\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\r\n        }\r\n        if (currentRow !== lastRow) {\r\n          nodes.push(currentRow);\r\n        }\r\n        nodes.push(cell, ...$getChildrenRecursively(cell));\r\n        lastRow = currentRow;\r\n      }\r\n    }\r\n    if (!lexical.isCurrentlyReadOnlyMode()) {\r\n      this._cachedNodes = nodes;\r\n    }\r\n    return nodes;\r\n  }\r\n  getTextContent() {\r\n    const nodes = this.getNodes();\r\n    let textContent = '';\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      textContent += nodes[i].getTextContent();\r\n    }\r\n    return textContent;\r\n  }\r\n}\r\nfunction $isTableSelection(x) {\r\n  return x instanceof TableSelection;\r\n}\r\nfunction $createTableSelection() {\r\n  const anchor = lexical.$createPoint('root', 0, 'element');\r\n  const focus = lexical.$createPoint('root', 0, 'element');\r\n  return new TableSelection('root', anchor, focus);\r\n}\r\nfunction $getChildrenRecursively(node) {\r\n  const nodes = [];\r\n  const stack = [node];\r\n  while (stack.length > 0) {\r\n    const currentNode = stack.pop();\r\n    if (!(currentNode !== undefined)) {\r\n      throw Error(`Stack.length > 0; can't be undefined`);\r\n    }\r\n    if (lexical.$isElementNode(currentNode)) {\r\n      stack.unshift(...currentNode.getChildren());\r\n    }\r\n    if (currentNode !== node) {\r\n      nodes.push(currentNode);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\r\nclass TableObserver {\r\n  constructor(editor, tableNodeKey) {\r\n    this.isHighlightingCells = false;\r\n    this.anchorX = -1;\r\n    this.anchorY = -1;\r\n    this.focusX = -1;\r\n    this.focusY = -1;\r\n    this.listenersToRemove = new Set();\r\n    this.tableNodeKey = tableNodeKey;\r\n    this.editor = editor;\r\n    this.table = {\r\n      columns: 0,\r\n      domRows: [],\r\n      rows: 0\r\n    };\r\n    this.tableSelection = null;\r\n    this.anchorCellNodeKey = null;\r\n    this.focusCellNodeKey = null;\r\n    this.anchorCell = null;\r\n    this.focusCell = null;\r\n    this.hasHijackedSelectionStyles = false;\r\n    this.trackTable();\r\n  }\r\n  getTable() {\r\n    return this.table;\r\n  }\r\n  removeListeners() {\r\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\r\n  }\r\n  trackTable() {\r\n    const observer = new MutationObserver(records => {\r\n      this.editor.update(() => {\r\n        let gridNeedsRedraw = false;\r\n        for (let i = 0; i < records.length; i++) {\r\n          const record = records[i];\r\n          const target = record.target;\r\n          const nodeName = target.nodeName;\r\n          if (nodeName === 'TABLE' || nodeName === 'TR') {\r\n            gridNeedsRedraw = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!gridNeedsRedraw) {\r\n          return;\r\n        }\r\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\r\n        if (!tableElement) {\r\n          throw new Error('Expected to find TableElement in DOM');\r\n        }\r\n        this.table = getTable(tableElement);\r\n      });\r\n    });\r\n    this.editor.update(() => {\r\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\r\n      if (!tableElement) {\r\n        throw new Error('Expected to find TableElement in DOM');\r\n      }\r\n      this.table = getTable(tableElement);\r\n      observer.observe(tableElement, {\r\n        childList: true,\r\n        subtree: true\r\n      });\r\n    });\r\n  }\r\n  clearHighlight() {\r\n    const editor = this.editor;\r\n    this.isHighlightingCells = false;\r\n    this.anchorX = -1;\r\n    this.anchorY = -1;\r\n    this.focusX = -1;\r\n    this.focusY = -1;\r\n    this.tableSelection = null;\r\n    this.anchorCellNodeKey = null;\r\n    this.focusCellNodeKey = null;\r\n    this.anchorCell = null;\r\n    this.focusCell = null;\r\n    this.hasHijackedSelectionStyles = false;\r\n    this.enableHighlightStyle();\r\n    editor.update(() => {\r\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\r\n      if (!$isTableNode(tableNode)) {\r\n        throw new Error('Expected TableNode.');\r\n      }\r\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\r\n      if (!tableElement) {\r\n        throw new Error('Expected to find TableElement in DOM');\r\n      }\r\n      const grid = getTable(tableElement);\r\n      $updateDOMForSelection(editor, grid, null);\r\n      lexical.$setSelection(null);\r\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\r\n    });\r\n  }\r\n  enableHighlightStyle() {\r\n    const editor = this.editor;\r\n    editor.update(() => {\r\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\r\n      if (!tableElement) {\r\n        throw new Error('Expected to find TableElement in DOM');\r\n      }\r\n      utils.removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\r\n      tableElement.classList.remove('disable-selection');\r\n      this.hasHijackedSelectionStyles = false;\r\n    });\r\n  }\r\n  disableHighlightStyle() {\r\n    const editor = this.editor;\r\n    editor.update(() => {\r\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\r\n      if (!tableElement) {\r\n        throw new Error('Expected to find TableElement in DOM');\r\n      }\r\n      utils.addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\r\n      this.hasHijackedSelectionStyles = true;\r\n    });\r\n  }\r\n  updateTableTableSelection(selection) {\r\n    if (selection !== null && selection.tableKey === this.tableNodeKey) {\r\n      const editor = this.editor;\r\n      this.tableSelection = selection;\r\n      this.isHighlightingCells = true;\r\n      this.disableHighlightStyle();\r\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\r\n    } else if (selection == null) {\r\n      this.clearHighlight();\r\n    } else {\r\n      this.tableNodeKey = selection.tableKey;\r\n      this.updateTableTableSelection(selection);\r\n    }\r\n  }\r\n  setFocusCellForSelection(cell, ignoreStart = false) {\r\n    const editor = this.editor;\r\n    editor.update(() => {\r\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\r\n      if (!$isTableNode(tableNode)) {\r\n        throw new Error('Expected TableNode.');\r\n      }\r\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\r\n      if (!tableElement) {\r\n        throw new Error('Expected to find TableElement in DOM');\r\n      }\r\n      const cellX = cell.x;\r\n      const cellY = cell.y;\r\n      this.focusCell = cell;\r\n      if (this.anchorCell !== null) {\r\n        const domSelection = getDOMSelection(editor._window);\r\n        // Collapse the selection\r\n        if (domSelection) {\r\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\r\n        }\r\n      }\r\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\r\n        this.isHighlightingCells = true;\r\n        this.disableHighlightStyle();\r\n      } else if (cellX === this.focusX && cellY === this.focusY) {\r\n        return;\r\n      }\r\n      this.focusX = cellX;\r\n      this.focusY = cellY;\r\n      if (this.isHighlightingCells) {\r\n        const focusTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\r\n        if (this.tableSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode)) {\r\n          const focusNodeKey = focusTableCellNode.getKey();\r\n          this.tableSelection = this.tableSelection.clone() || $createTableSelection();\r\n          this.focusCellNodeKey = focusNodeKey;\r\n          this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\r\n          lexical.$setSelection(this.tableSelection);\r\n          editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\r\n          $updateDOMForSelection(editor, this.table, this.tableSelection);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  setAnchorCellForSelection(cell) {\r\n    this.isHighlightingCells = false;\r\n    this.anchorCell = cell;\r\n    this.anchorX = cell.x;\r\n    this.anchorY = cell.y;\r\n    this.editor.update(() => {\r\n      const anchorTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\r\n      if ($isTableCellNode(anchorTableCellNode)) {\r\n        const anchorNodeKey = anchorTableCellNode.getKey();\r\n        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\r\n        this.anchorCellNodeKey = anchorNodeKey;\r\n      }\r\n    });\r\n  }\r\n  formatCells(type) {\r\n    this.editor.update(() => {\r\n      const selection = lexical.$getSelection();\r\n      if (!$isTableSelection(selection)) {\r\n        {\r\n          throw Error(`Expected grid selection`);\r\n        }\r\n      }\r\n      const formatSelection = lexical.$createRangeSelection();\r\n      const anchor = formatSelection.anchor;\r\n      const focus = formatSelection.focus;\r\n      selection.getNodes().forEach(cellNode => {\r\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\r\n          anchor.set(cellNode.getKey(), 0, 'element');\r\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\r\n          formatSelection.formatText(type);\r\n        }\r\n      });\r\n      lexical.$setSelection(selection);\r\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\r\n    });\r\n  }\r\n  clearText() {\r\n    const editor = this.editor;\r\n    editor.update(() => {\r\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\r\n      if (!$isTableNode(tableNode)) {\r\n        throw new Error('Expected TableNode.');\r\n      }\r\n      const selection = lexical.$getSelection();\r\n      if (!$isTableSelection(selection)) {\r\n        {\r\n          throw Error(`Expected grid selection`);\r\n        }\r\n      }\r\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\r\n      if (selectedNodes.length === this.table.columns * this.table.rows) {\r\n        tableNode.selectPrevious();\r\n        // Delete entire table\r\n        tableNode.remove();\r\n        const rootNode = lexical.$getRoot();\r\n        rootNode.selectStart();\r\n        return;\r\n      }\r\n      selectedNodes.forEach(cellNode => {\r\n        if (lexical.$isElementNode(cellNode)) {\r\n          const paragraphNode = lexical.$createParagraphNode();\r\n          const textNode = lexical.$createTextNode();\r\n          paragraphNode.append(textNode);\r\n          cellNode.append(paragraphNode);\r\n          cellNode.getChildren().forEach(child => {\r\n            if (child !== paragraphNode) {\r\n              child.remove();\r\n            }\r\n          });\r\n        }\r\n      });\r\n      $updateDOMForSelection(editor, this.table, null);\r\n      lexical.$setSelection(null);\r\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\r\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\r\n  const rootElement = editor.getRootElement();\r\n  if (rootElement === null) {\r\n    throw new Error('No root element.');\r\n  }\r\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\r\n  const editorWindow = editor._window || window;\r\n  attachTableObserverToTableElement(tableElement, tableObserver);\r\n  tableElement.addEventListener('mousedown', event => {\r\n    setTimeout(() => {\r\n      if (event.button !== 0) {\r\n        return;\r\n      }\r\n      if (!editorWindow) {\r\n        return;\r\n      }\r\n      const anchorCell = getDOMCellFromTarget(event.target);\r\n      if (anchorCell !== null) {\r\n        stopEvent(event);\r\n        tableObserver.setAnchorCellForSelection(anchorCell);\r\n      }\r\n      const onMouseUp = () => {\r\n        editorWindow.removeEventListener('mouseup', onMouseUp);\r\n        editorWindow.removeEventListener('mousemove', onMouseMove);\r\n      };\r\n      const onMouseMove = moveEvent => {\r\n        const focusCell = getDOMCellFromTarget(moveEvent.target);\r\n        if (focusCell !== null && (tableObserver.anchorX !== focusCell.x || tableObserver.anchorY !== focusCell.y)) {\r\n          moveEvent.preventDefault();\r\n          tableObserver.setFocusCellForSelection(focusCell);\r\n        }\r\n      };\r\n      editorWindow.addEventListener('mouseup', onMouseUp);\r\n      editorWindow.addEventListener('mousemove', onMouseMove);\r\n    }, 0);\r\n  });\r\n\r\n  // Clear selection when clicking outside of dom.\r\n  const mouseDownCallback = event => {\r\n    if (event.button !== 0) {\r\n      return;\r\n    }\r\n    editor.update(() => {\r\n      const selection = lexical.$getSelection();\r\n      const target = event.target;\r\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\r\n        tableObserver.clearHighlight();\r\n      }\r\n    });\r\n  };\r\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\r\n  tableObserver.listenersToRemove.add(() => editorWindow.removeEventListener('mousedown', mouseDownCallback));\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableObserver), lexical.COMMAND_PRIORITY_HIGH));\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableObserver), lexical.COMMAND_PRIORITY_HIGH));\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableObserver), lexical.COMMAND_PRIORITY_HIGH));\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableObserver), lexical.COMMAND_PRIORITY_HIGH));\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, event => {\r\n    const selection = lexical.$getSelection();\r\n    if ($isTableSelection(selection)) {\r\n      const focusCellNode = utils.$findMatchingParent(selection.focus.getNode(), $isTableCellNode);\r\n      if ($isTableCellNode(focusCellNode)) {\r\n        stopEvent(event);\r\n        focusCellNode.selectEnd();\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }, lexical.COMMAND_PRIORITY_HIGH));\r\n  const deleteTextHandler = command => () => {\r\n    const selection = lexical.$getSelection();\r\n    if (!$isSelectionInTable(selection, tableNode)) {\r\n      return false;\r\n    }\r\n    if ($isTableSelection(selection)) {\r\n      tableObserver.clearText();\r\n      return true;\r\n    } else if (lexical.$isRangeSelection(selection)) {\r\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\r\n      if (!$isTableCellNode(tableCellNode)) {\r\n        return false;\r\n      }\r\n      const anchorNode = selection.anchor.getNode();\r\n      const focusNode = selection.focus.getNode();\r\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\r\n      const isFocusInside = tableNode.isParentOf(focusNode);\r\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\r\n      if (selectionContainsPartialTable) {\r\n        tableObserver.clearText();\r\n        return true;\r\n      }\r\n      const nearestElementNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\r\n      const topLevelCellElementNode = nearestElementNode && utils.$findMatchingParent(nearestElementNode, n => lexical.$isElementNode(n) && $isTableCellNode(n.getParent()));\r\n      if (!lexical.$isElementNode(topLevelCellElementNode) || !lexical.$isElementNode(nearestElementNode)) {\r\n        return false;\r\n      }\r\n      if (command === lexical.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\r\n        // TODO: Fix Delete Line in Table Cells.\r\n        return true;\r\n      }\r\n      if (command === lexical.DELETE_CHARACTER_COMMAND || command === lexical.DELETE_WORD_COMMAND) {\r\n        if (selection.isCollapsed() && selection.anchor.offset === 0) {\r\n          if (nearestElementNode !== topLevelCellElementNode) {\r\n            const children = nearestElementNode.getChildren();\r\n            const newParagraphNode = lexical.$createParagraphNode();\r\n            children.forEach(child => newParagraphNode.append(child));\r\n            nearestElementNode.replace(newParagraphNode);\r\n            nearestElementNode.getWritable().__parent = tableCellNode.getKey();\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n  [lexical.DELETE_WORD_COMMAND, lexical.DELETE_LINE_COMMAND, lexical.DELETE_CHARACTER_COMMAND].forEach(command => {\r\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical.COMMAND_PRIORITY_CRITICAL));\r\n  });\r\n  const deleteCellHandler = event => {\r\n    const selection = lexical.$getSelection();\r\n    if (!$isSelectionInTable(selection, tableNode)) {\r\n      return false;\r\n    }\r\n    if ($isTableSelection(selection)) {\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n      tableObserver.clearText();\r\n      return true;\r\n    } else if (lexical.$isRangeSelection(selection)) {\r\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\r\n      if (!$isTableCellNode(tableCellNode)) {\r\n        return false;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.KEY_DELETE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, payload => {\r\n    const selection = lexical.$getSelection();\r\n    if (!$isSelectionInTable(selection, tableNode)) {\r\n      return false;\r\n    }\r\n    if ($isTableSelection(selection)) {\r\n      tableObserver.formatCells(payload);\r\n      return true;\r\n    } else if (lexical.$isRangeSelection(selection)) {\r\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\r\n      if (!$isTableCellNode(tableCellNode)) {\r\n        return false;\r\n      }\r\n    }\r\n    return false;\r\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\r\n    const selection = lexical.$getSelection();\r\n    if (!$isSelectionInTable(selection, tableNode)) {\r\n      return false;\r\n    }\r\n    if ($isTableSelection(selection)) {\r\n      tableObserver.clearHighlight();\r\n      return false;\r\n    } else if (lexical.$isRangeSelection(selection)) {\r\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\r\n      if (!$isTableCellNode(tableCellNode)) {\r\n        return false;\r\n      }\r\n    }\r\n    return false;\r\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\r\n  if (hasTabHandler) {\r\n    tableObserver.listenersToRemove.add(editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\r\n      const selection = lexical.$getSelection();\r\n      if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\r\n        return false;\r\n      }\r\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\r\n      if (tableCellNode === null) {\r\n        return false;\r\n      }\r\n      stopEvent(event);\r\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\r\n      selectTableNodeInDirection(tableObserver, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\r\n      return true;\r\n    }, lexical.COMMAND_PRIORITY_CRITICAL));\r\n  }\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.FOCUS_COMMAND, payload => {\r\n    return tableNode.isSelected();\r\n  }, lexical.COMMAND_PRIORITY_HIGH));\r\n  function getObserverCellFromCellNode(tableCellNode) {\r\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\r\n    return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\r\n  }\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\r\n    const {\r\n      nodes,\r\n      selection\r\n    } = selectionPayload;\r\n    const anchorAndFocus = selection.getStartEndPoints();\r\n    const isTableSelection = $isTableSelection(selection);\r\n    const isRangeSelection = lexical.$isRangeSelection(selection);\r\n    const isSelectionInsideOfGrid = isRangeSelection && utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\r\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\r\n      return false;\r\n    }\r\n    const [anchor] = anchorAndFocus;\r\n    const newGrid = nodes[0];\r\n    const newGridRows = newGrid.getChildren();\r\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\r\n    const newRowCount = newGrid.getChildrenSize();\r\n    const gridCellNode = utils.$findMatchingParent(anchor.getNode(), n => $isTableCellNode(n));\r\n    const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => $isTableRowNode(n));\r\n    const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => $isTableNode(n));\r\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\r\n      return false;\r\n    }\r\n    const startY = gridRowNode.getIndexWithinParent();\r\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\r\n    const startX = gridCellNode.getIndexWithinParent();\r\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\r\n    const fromX = Math.min(startX, stopX);\r\n    const fromY = Math.min(startY, stopY);\r\n    const toX = Math.max(startX, stopX);\r\n    const toY = Math.max(startY, stopY);\r\n    const gridRowNodes = gridNode.getChildren();\r\n    let newRowIdx = 0;\r\n    let newAnchorCellKey;\r\n    let newFocusCellKey;\r\n    for (let r = fromY; r <= toY; r++) {\r\n      const currentGridRowNode = gridRowNodes[r];\r\n      if (!$isTableRowNode(currentGridRowNode)) {\r\n        return false;\r\n      }\r\n      const newGridRowNode = newGridRows[newRowIdx];\r\n      if (!$isTableRowNode(newGridRowNode)) {\r\n        return false;\r\n      }\r\n      const gridCellNodes = currentGridRowNode.getChildren();\r\n      const newGridCellNodes = newGridRowNode.getChildren();\r\n      let newColumnIdx = 0;\r\n      for (let c = fromX; c <= toX; c++) {\r\n        const currentGridCellNode = gridCellNodes[c];\r\n        if (!$isTableCellNode(currentGridCellNode)) {\r\n          return false;\r\n        }\r\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\r\n        if (!$isTableCellNode(newGridCellNode)) {\r\n          return false;\r\n        }\r\n        if (r === fromY && c === fromX) {\r\n          newAnchorCellKey = currentGridCellNode.getKey();\r\n        } else if (r === toY && c === toX) {\r\n          newFocusCellKey = currentGridCellNode.getKey();\r\n        }\r\n        const originalChildren = currentGridCellNode.getChildren();\r\n        newGridCellNode.getChildren().forEach(child => {\r\n          if (lexical.$isTextNode(child)) {\r\n            const paragraphNode = lexical.$createParagraphNode();\r\n            paragraphNode.append(child);\r\n            currentGridCellNode.append(child);\r\n          } else {\r\n            currentGridCellNode.append(child);\r\n          }\r\n        });\r\n        originalChildren.forEach(n => n.remove());\r\n        newColumnIdx++;\r\n      }\r\n      newRowIdx++;\r\n    }\r\n    if (newAnchorCellKey && newFocusCellKey) {\r\n      const newTableSelection = $createTableSelection();\r\n      newTableSelection.set(nodes[0].getKey(), newAnchorCellKey, newFocusCellKey);\r\n      lexical.$setSelection(newTableSelection);\r\n    }\r\n    return true;\r\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\r\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical.SELECTION_CHANGE_COMMAND, () => {\r\n    const selection = lexical.$getSelection();\r\n    const prevSelection = lexical.$getPreviousSelection();\r\n    if (lexical.$isRangeSelection(selection)) {\r\n      const {\r\n        anchor,\r\n        focus\r\n      } = selection;\r\n      const anchorNode = anchor.getNode();\r\n      const focusNode = focus.getNode();\r\n      // Using explicit comparison with table node to ensure it's not a nested table\r\n      // as in that case we'll leave selection resolving to that table\r\n      const anchorCellNode = $findCellNode(anchorNode);\r\n      const focusCellNode = $findCellNode(focusNode);\r\n      const isAnchorInside = anchorCellNode && tableNode.is($findTableNode(anchorCellNode));\r\n      const isFocusInside = focusCellNode && tableNode.is($findTableNode(focusCellNode));\r\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\r\n      const isWithinTable = isAnchorInside && isFocusInside;\r\n      const isBackward = selection.isBackward();\r\n      if (isPartialyWithinTable) {\r\n        const newSelection = selection.clone();\r\n        newSelection.focus.set(tableNode.getKey(), isBackward ? 0 : tableNode.getChildrenSize(), 'element');\r\n        lexical.$setSelection(newSelection);\r\n        $addHighlightStyleToTable(editor, tableObserver);\r\n      } else if (isWithinTable) {\r\n        // Handle case when selection spans across multiple cells but still\r\n        // has range selection, then we convert it into grid selection\r\n        if (!anchorCellNode.is(focusCellNode)) {\r\n          tableObserver.setAnchorCellForSelection(getObserverCellFromCellNode(anchorCellNode));\r\n          tableObserver.setFocusCellForSelection(getObserverCellFromCellNode(focusCellNode), true);\r\n        }\r\n      }\r\n    }\r\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\r\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\r\n        tableObserver.updateTableTableSelection(selection);\r\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\r\n        tableObserver.updateTableTableSelection(null);\r\n      }\r\n      return false;\r\n    }\r\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\r\n      $removeHighlightStyleToTable(editor, tableObserver);\r\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\r\n      $addHighlightStyleToTable(editor, tableObserver);\r\n    }\r\n    return false;\r\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\r\n  return tableObserver;\r\n}\r\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\r\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\r\n}\r\nfunction getTableObserverFromTableElement(tableElement) {\r\n  return tableElement[LEXICAL_ELEMENT_KEY];\r\n}\r\nfunction getDOMCellFromTarget(node) {\r\n  let currentNode = node;\r\n  while (currentNode != null) {\r\n    const nodeName = currentNode.nodeName;\r\n    if (nodeName === 'TD' || nodeName === 'TH') {\r\n      // @ts-expect-error: internal field\r\n      const cell = currentNode._cell;\r\n      if (cell === undefined) {\r\n        return null;\r\n      }\r\n      return cell;\r\n    }\r\n    currentNode = currentNode.parentNode;\r\n  }\r\n  return null;\r\n}\r\nfunction getTable(tableElement) {\r\n  const domRows = [];\r\n  const grid = {\r\n    columns: 0,\r\n    domRows,\r\n    rows: 0\r\n  };\r\n  let currentNode = tableElement.firstChild;\r\n  let x = 0;\r\n  let y = 0;\r\n  domRows.length = 0;\r\n  while (currentNode != null) {\r\n    const nodeMame = currentNode.nodeName;\r\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\r\n      const elem = currentNode;\r\n      const cell = {\r\n        elem,\r\n        hasBackgroundColor: elem.style.backgroundColor !== '',\r\n        highlighted: false,\r\n        x,\r\n        y\r\n      };\r\n\r\n      // @ts-expect-error: internal field\r\n      currentNode._cell = cell;\r\n      let row = domRows[y];\r\n      if (row === undefined) {\r\n        row = domRows[y] = [];\r\n      }\r\n      row[x] = cell;\r\n    } else {\r\n      const child = currentNode.firstChild;\r\n      if (child != null) {\r\n        currentNode = child;\r\n        continue;\r\n      }\r\n    }\r\n    const sibling = currentNode.nextSibling;\r\n    if (sibling != null) {\r\n      x++;\r\n      currentNode = sibling;\r\n      continue;\r\n    }\r\n    const parent = currentNode.parentNode;\r\n    if (parent != null) {\r\n      const parentSibling = parent.nextSibling;\r\n      if (parentSibling == null) {\r\n        break;\r\n      }\r\n      y++;\r\n      x = 0;\r\n      currentNode = parentSibling;\r\n    }\r\n  }\r\n  grid.columns = x + 1;\r\n  grid.rows = y + 1;\r\n  return grid;\r\n}\r\nfunction $updateDOMForSelection(editor, table, selection) {\r\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\r\n  $forEachTableCell(table, (cell, lexicalNode) => {\r\n    const elem = cell.elem;\r\n    if (selectedCellNodes.has(lexicalNode)) {\r\n      cell.highlighted = true;\r\n      $addHighlightToDOM(editor, cell);\r\n    } else {\r\n      cell.highlighted = false;\r\n      $removeHighlightFromDOM(editor, cell);\r\n      if (!elem.getAttribute('style')) {\r\n        elem.removeAttribute('style');\r\n      }\r\n    }\r\n  });\r\n}\r\nfunction $forEachTableCell(grid, cb) {\r\n  const {\r\n    domRows\r\n  } = grid;\r\n  for (let y = 0; y < domRows.length; y++) {\r\n    const row = domRows[y];\r\n    if (!row) {\r\n      continue;\r\n    }\r\n    for (let x = 0; x < row.length; x++) {\r\n      const cell = row[x];\r\n      if (!cell) {\r\n        continue;\r\n      }\r\n      const lexicalNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\r\n      if (lexicalNode !== null) {\r\n        cb(cell, lexicalNode, {\r\n          x,\r\n          y\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction $addHighlightStyleToTable(editor, tableSelection) {\r\n  tableSelection.disableHighlightStyle();\r\n  $forEachTableCell(tableSelection.table, cell => {\r\n    cell.highlighted = true;\r\n    $addHighlightToDOM(editor, cell);\r\n  });\r\n}\r\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\r\n  tableObserver.enableHighlightStyle();\r\n  $forEachTableCell(tableObserver.table, cell => {\r\n    const elem = cell.elem;\r\n    cell.highlighted = false;\r\n    $removeHighlightFromDOM(editor, cell);\r\n    if (!elem.getAttribute('style')) {\r\n      elem.removeAttribute('style');\r\n    }\r\n  });\r\n}\r\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\r\n  const isForward = direction === 'forward';\r\n  switch (direction) {\r\n    case 'backward':\r\n    case 'forward':\r\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\r\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\r\n      } else {\r\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\r\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\r\n        } else if (!isForward) {\r\n          tableNode.selectPrevious();\r\n        } else {\r\n          tableNode.selectNext();\r\n        }\r\n      }\r\n      return true;\r\n    case 'up':\r\n      if (y !== 0) {\r\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\r\n      } else {\r\n        tableNode.selectPrevious();\r\n      }\r\n      return true;\r\n    case 'down':\r\n      if (y !== tableObserver.table.rows - 1) {\r\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\r\n      } else {\r\n        tableNode.selectNext();\r\n      }\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n};\r\nconst adjustFocusNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\r\n  const isForward = direction === 'forward';\r\n  switch (direction) {\r\n    case 'backward':\r\n    case 'forward':\r\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\r\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table));\r\n      }\r\n      return true;\r\n    case 'up':\r\n      if (y !== 0) {\r\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y - 1, tableObserver.table));\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    case 'down':\r\n      if (y !== tableObserver.table.rows - 1) {\r\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y + 1, tableObserver.table));\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    default:\r\n      return false;\r\n  }\r\n};\r\nfunction $isSelectionInTable(selection, tableNode) {\r\n  if (lexical.$isRangeSelection(selection) || $isTableSelection(selection)) {\r\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\r\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\r\n    return isAnchorInside && isFocusInside;\r\n  }\r\n  return false;\r\n}\r\nfunction selectTableCellNode(tableCell, fromStart) {\r\n  if (fromStart) {\r\n    tableCell.selectStart();\r\n  } else {\r\n    tableCell.selectEnd();\r\n  }\r\n}\r\nconst BROWSER_BLUE_RGB = '172,206,247';\r\nfunction $addHighlightToDOM(editor, cell) {\r\n  const element = cell.elem;\r\n  const node = lexical.$getNearestNodeFromDOMNode(element);\r\n  if (!$isTableCellNode(node)) {\r\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\r\n  }\r\n  const backgroundColor = node.getBackgroundColor();\r\n  if (backgroundColor === null) {\r\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\r\n  } else {\r\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\r\n  }\r\n  element.style.setProperty('caret-color', 'transparent');\r\n}\r\nfunction $removeHighlightFromDOM(editor, cell) {\r\n  const element = cell.elem;\r\n  const node = lexical.$getNearestNodeFromDOMNode(element);\r\n  if (!$isTableCellNode(node)) {\r\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\r\n  }\r\n  const backgroundColor = node.getBackgroundColor();\r\n  if (backgroundColor === null) {\r\n    element.style.removeProperty('background-color');\r\n  }\r\n  element.style.removeProperty('background-image');\r\n  element.style.removeProperty('caret-color');\r\n}\r\nfunction $findCellNode(node) {\r\n  const cellNode = utils.$findMatchingParent(node, $isTableCellNode);\r\n  return $isTableCellNode(cellNode) ? cellNode : null;\r\n}\r\nfunction $findTableNode(node) {\r\n  const tableNode = utils.$findMatchingParent(node, $isTableNode);\r\n  return $isTableNode(tableNode) ? tableNode : null;\r\n}\r\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\r\n  const selection = lexical.$getSelection();\r\n  if (!$isSelectionInTable(selection, tableNode)) {\r\n    return false;\r\n  }\r\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed()) {\r\n    // Horizontal move between cels seem to work well without interruption\r\n    // so just exit early, and handle vertical moves\r\n    if (direction === 'backward' || direction === 'forward') {\r\n      return false;\r\n    }\r\n    const {\r\n      anchor,\r\n      focus\r\n    } = selection;\r\n    const anchorCellNode = utils.$findMatchingParent(anchor.getNode(), $isTableCellNode);\r\n    const focusCellNode = utils.$findMatchingParent(focus.getNode(), $isTableCellNode);\r\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\r\n      return false;\r\n    }\r\n    const anchorCellTable = $findTableNode(anchorCellNode);\r\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\r\n      const anchorCellTableElement = editor.getElementByKey(anchorCellTable.getKey());\r\n      if (anchorCellTableElement != null) {\r\n        tableObserver.table = getTable(anchorCellTableElement);\r\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\r\n      }\r\n    }\r\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\r\n    const anchorDOM = editor.getElementByKey(anchor.key);\r\n    if (anchorDOM == null || anchorCellDom == null) {\r\n      return false;\r\n    }\r\n    let edgeSelectionRect;\r\n    if (anchor.type === 'element') {\r\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\r\n    } else {\r\n      const domSelection = window.getSelection();\r\n      if (domSelection === null || domSelection.rangeCount === 0) {\r\n        return false;\r\n      }\r\n      const range = domSelection.getRangeAt(0);\r\n      edgeSelectionRect = range.getBoundingClientRect();\r\n    }\r\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\r\n    if (edgeChild == null) {\r\n      return false;\r\n    }\r\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\r\n    if (edgeChildDOM == null) {\r\n      return false;\r\n    }\r\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\r\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\r\n    if (isExiting) {\r\n      stopEvent(event);\r\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\r\n      if (event.shiftKey) {\r\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\r\n        tableObserver.setAnchorCellForSelection(cell);\r\n        tableObserver.setFocusCellForSelection(cell, true);\r\n      } else {\r\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\r\n      }\r\n      return true;\r\n    }\r\n  } else if ($isTableSelection(selection)) {\r\n    const {\r\n      anchor,\r\n      focus\r\n    } = selection;\r\n    const anchorCellNode = utils.$findMatchingParent(anchor.getNode(), $isTableCellNode);\r\n    const focusCellNode = utils.$findMatchingParent(focus.getNode(), $isTableCellNode);\r\n    const [tableNodeFromSelection] = selection.getNodes();\r\n    const tableElement = editor.getElementByKey(tableNodeFromSelection.getKey());\r\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\r\n      return false;\r\n    }\r\n    tableObserver.updateTableTableSelection(selection);\r\n    const grid = getTable(tableElement);\r\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\r\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\r\n    tableObserver.setAnchorCellForSelection(anchorCell);\r\n    stopEvent(event);\r\n    if (event.shiftKey) {\r\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, grid);\r\n      return adjustFocusNodeInDirection(tableObserver, tableNodeFromSelection, cords.x, cords.y, direction);\r\n    } else {\r\n      focusCellNode.selectEnd();\r\n    }\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nfunction stopEvent(event) {\r\n  event.preventDefault();\r\n  event.stopImmediatePropagation();\r\n  event.stopPropagation();\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass TableNode extends lexical.ElementNode {\r\n  static getType() {\r\n    return 'table';\r\n  }\r\n  static clone(node) {\r\n    return new TableNode(node.__key);\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      table: _node => ({\r\n        conversion: convertTableElement,\r\n        priority: 1\r\n      })\r\n    };\r\n  }\r\n  static importJSON(_serializedNode) {\r\n    return $createTableNode();\r\n  }\r\n  constructor(key) {\r\n    super(key);\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      type: 'table',\r\n      version: 1\r\n    };\r\n  }\r\n  createDOM(config, editor) {\r\n    const tableElement = document.createElement('table');\r\n    utils.addClassNamesToElement(tableElement, config.theme.table);\r\n    return tableElement;\r\n  }\r\n  updateDOM() {\r\n    return false;\r\n  }\r\n  exportDOM(editor) {\r\n    return {\r\n      ...super.exportDOM(editor),\r\n      after: tableElement => {\r\n        if (tableElement) {\r\n          const newElement = tableElement.cloneNode();\r\n          const colGroup = document.createElement('colgroup');\r\n          const tBody = document.createElement('tbody');\r\n          if (utils.isHTMLElement(tableElement)) {\r\n            tBody.append(...tableElement.children);\r\n          }\r\n          const firstRow = this.getFirstChildOrThrow();\r\n          if (!$isTableRowNode(firstRow)) {\r\n            throw new Error('Expected to find row node.');\r\n          }\r\n          const colCount = firstRow.getChildrenSize();\r\n          for (let i = 0; i < colCount; i++) {\r\n            const col = document.createElement('col');\r\n            colGroup.append(col);\r\n          }\r\n          newElement.replaceChildren(colGroup, tBody);\r\n          return newElement;\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  // TODO 0.10 deprecate\r\n  canExtractContents() {\r\n    return false;\r\n  }\r\n  canBeEmpty() {\r\n    return false;\r\n  }\r\n  isShadowRoot() {\r\n    return true;\r\n  }\r\n  getCordsFromCellNode(tableCellNode, table) {\r\n    const {\r\n      rows,\r\n      domRows\r\n    } = table;\r\n    for (let y = 0; y < rows; y++) {\r\n      const row = domRows[y];\r\n      if (row == null) {\r\n        continue;\r\n      }\r\n      const x = row.findIndex(cell => {\r\n        if (!cell) return;\r\n        const {\r\n          elem\r\n        } = cell;\r\n        const cellNode = lexical.$getNearestNodeFromDOMNode(elem);\r\n        return cellNode === tableCellNode;\r\n      });\r\n      if (x !== -1) {\r\n        return {\r\n          x,\r\n          y\r\n        };\r\n      }\r\n    }\r\n    throw new Error('Cell not found in table.');\r\n  }\r\n  getDOMCellFromCords(x, y, table) {\r\n    const {\r\n      domRows\r\n    } = table;\r\n    const row = domRows[y];\r\n    if (row == null) {\r\n      return null;\r\n    }\r\n    const cell = row[x];\r\n    if (cell == null) {\r\n      return null;\r\n    }\r\n    return cell;\r\n  }\r\n  getDOMCellFromCordsOrThrow(x, y, table) {\r\n    const cell = this.getDOMCellFromCords(x, y, table);\r\n    if (!cell) {\r\n      throw new Error('Cell not found at cords.');\r\n    }\r\n    return cell;\r\n  }\r\n  getCellNodeFromCords(x, y, table) {\r\n    const cell = this.getDOMCellFromCords(x, y, table);\r\n    if (cell == null) {\r\n      return null;\r\n    }\r\n    const node = lexical.$getNearestNodeFromDOMNode(cell.elem);\r\n    if ($isTableCellNode(node)) {\r\n      return node;\r\n    }\r\n    return null;\r\n  }\r\n  getCellNodeFromCordsOrThrow(x, y, table) {\r\n    const node = this.getCellNodeFromCords(x, y, table);\r\n    if (!node) {\r\n      throw new Error('Node at cords not TableCellNode.');\r\n    }\r\n    return node;\r\n  }\r\n  canSelectBefore() {\r\n    return true;\r\n  }\r\n  canIndent() {\r\n    return false;\r\n  }\r\n}\r\nfunction $getElementForTableNode(editor, tableNode) {\r\n  const tableElement = editor.getElementByKey(tableNode.getKey());\r\n  if (tableElement == null) {\r\n    throw new Error('Table Element Not Found');\r\n  }\r\n  return getTable(tableElement);\r\n}\r\nfunction convertTableElement(_domNode) {\r\n  return {\r\n    node: $createTableNode()\r\n  };\r\n}\r\nfunction $createTableNode() {\r\n  return lexical.$applyNodeReplacement(new TableNode());\r\n}\r\nfunction $isTableNode(node) {\r\n  return node instanceof TableNode;\r\n}\r\n\r\nexports.$computeTableMap = $computeTableMap;\r\nexports.$createTableCellNode = $createTableCellNode;\r\nexports.$createTableNode = $createTableNode;\r\nexports.$createTableNodeWithDimensions = $createTableNodeWithDimensions;\r\nexports.$createTableRowNode = $createTableRowNode;\r\nexports.$createTableSelection = $createTableSelection;\r\nexports.$deleteTableColumn = $deleteTableColumn;\r\nexports.$deleteTableColumn__EXPERIMENTAL = $deleteTableColumn__EXPERIMENTAL;\r\nexports.$deleteTableRow__EXPERIMENTAL = $deleteTableRow__EXPERIMENTAL;\r\nexports.$getElementForTableNode = $getElementForTableNode;\r\nexports.$getNodeTriplet = $getNodeTriplet;\r\nexports.$getTableCellNodeFromLexicalNode = $getTableCellNodeFromLexicalNode;\r\nexports.$getTableCellNodeRect = $getTableCellNodeRect;\r\nexports.$getTableColumnIndexFromTableCellNode = $getTableColumnIndexFromTableCellNode;\r\nexports.$getTableNodeFromLexicalNodeOrThrow = $getTableNodeFromLexicalNodeOrThrow;\r\nexports.$getTableRowIndexFromTableCellNode = $getTableRowIndexFromTableCellNode;\r\nexports.$getTableRowNodeFromTableCellNodeOrThrow = $getTableRowNodeFromTableCellNodeOrThrow;\r\nexports.$insertTableColumn = $insertTableColumn;\r\nexports.$insertTableColumn__EXPERIMENTAL = $insertTableColumn__EXPERIMENTAL;\r\nexports.$insertTableRow = $insertTableRow;\r\nexports.$insertTableRow__EXPERIMENTAL = $insertTableRow__EXPERIMENTAL;\r\nexports.$isTableCellNode = $isTableCellNode;\r\nexports.$isTableNode = $isTableNode;\r\nexports.$isTableRowNode = $isTableRowNode;\r\nexports.$isTableSelection = $isTableSelection;\r\nexports.$removeTableRowAtIndex = $removeTableRowAtIndex;\r\nexports.$unmergeCell = $unmergeCell;\r\nexports.INSERT_TABLE_COMMAND = INSERT_TABLE_COMMAND;\r\nexports.TableCellHeaderStates = TableCellHeaderStates;\r\nexports.TableCellNode = TableCellNode;\r\nexports.TableNode = TableNode;\r\nexports.TableObserver = TableObserver;\r\nexports.TableRowNode = TableRowNode;\r\nexports.applyTableHandlers = applyTableHandlers;\r\nexports.getDOMCellFromTarget = getDOMCellFromTarget;\r\nexports.getTableObserverFromTableElement = getTableObserverFromTableElement;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst LexicalTable = process.env.NODE_ENV === 'development' ? require('./LexicalTable.dev.js') : require('./LexicalTable.prod.js')\r\nmodule.exports = LexicalTable;"],
  "mappings": "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",
  "names": []
}
