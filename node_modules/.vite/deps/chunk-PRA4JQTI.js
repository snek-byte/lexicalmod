import {
  require_LexicalSelection,
  require_LexicalUtils
} from "./chunk-654INGXA.js";
import {
  require_Lexical
} from "./chunk-O75NZ7RX.js";
import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@lexical/html/LexicalHtml.dev.js
var require_LexicalHtml_dev = __commonJS({
  "node_modules/@lexical/html/LexicalHtml.dev.js"(exports) {
    "use strict";
    var selection = require_LexicalSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    function $generateNodesFromDOM(editor, dom) {
      const elements = dom.body ? dom.body.childNodes : [];
      let lexicalNodes = [];
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (!IGNORE_TAGS.has(element.nodeName)) {
          const lexicalNode = $createNodesFromDOM(element, editor);
          if (lexicalNode !== null) {
            lexicalNodes = lexicalNodes.concat(lexicalNode);
          }
        }
      }
      return lexicalNodes;
    }
    function $generateHtmlFromNodes(editor, selection2) {
      if (typeof document === "undefined" || typeof window === "undefined" && typeof global.window === "undefined") {
        throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
      }
      const container = document.createElement("div");
      const root = lexical.$getRoot();
      const topLevelChildren = root.getChildren();
      for (let i = 0; i < topLevelChildren.length; i++) {
        const topLevelNode = topLevelChildren[i];
        $appendNodesToHTML(editor, topLevelNode, container, selection2);
      }
      return container.innerHTML;
    }
    function $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {
      let shouldInclude = selection$1 !== null ? currentNode.isSelected(selection$1) : true;
      const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy("html");
      let target = currentNode;
      if (selection$1 !== null) {
        let clone = selection.$cloneWithProperties(currentNode);
        clone = lexical.$isTextNode(clone) && selection$1 !== null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
        target = clone;
      }
      const children = lexical.$isElementNode(target) ? target.getChildren() : [];
      const registeredNode = editor._nodes.get(target.getType());
      let exportOutput;
      if (registeredNode && registeredNode.exportDOM !== void 0) {
        exportOutput = registeredNode.exportDOM(editor, target);
      } else {
        exportOutput = target.exportDOM(editor);
      }
      const {
        element,
        after
      } = exportOutput;
      if (!element) {
        return false;
      }
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < children.length; i++) {
        const childNode = children[i];
        const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);
        if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, "html")) {
          shouldInclude = true;
        }
      }
      if (shouldInclude && !shouldExclude) {
        if (utils.isHTMLElement(element)) {
          element.append(fragment);
        }
        parentElement.append(element);
        if (after) {
          const newElement = after.call(target, element);
          if (newElement) element.replaceWith(newElement);
        }
      } else {
        parentElement.append(fragment);
      }
      return shouldInclude;
    }
    function getConversionFunction(domNode, editor) {
      const {
        nodeName
      } = domNode;
      const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
      let currentConversion = null;
      if (cachedConversions !== void 0) {
        for (const cachedConversion of cachedConversions) {
          const domConversion = cachedConversion(domNode);
          if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {
            currentConversion = domConversion;
          }
        }
      }
      return currentConversion !== null ? currentConversion.conversion : null;
    }
    var IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
    function $createNodesFromDOM(node, editor, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode) {
      let lexicalNodes = [];
      if (IGNORE_TAGS.has(node.nodeName)) {
        return lexicalNodes;
      }
      let currentLexicalNode = null;
      const transformFunction = getConversionFunction(node, editor);
      const transformOutput = transformFunction ? transformFunction(node) : null;
      let postTransform = null;
      if (transformOutput !== null) {
        postTransform = transformOutput.after;
        const transformNodes = transformOutput.node;
        currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;
        if (currentLexicalNode !== null) {
          for (const [, forChildFunction] of forChildMap) {
            currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
            if (!currentLexicalNode) {
              break;
            }
          }
          if (currentLexicalNode) {
            lexicalNodes.push(...Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]);
          }
        }
        if (transformOutput.forChild != null) {
          forChildMap.set(node.nodeName, transformOutput.forChild);
        }
      }
      const children = node.childNodes;
      let childLexicalNodes = [];
      for (let i = 0; i < children.length; i++) {
        childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));
      }
      if (postTransform != null) {
        childLexicalNodes = postTransform(childLexicalNodes);
      }
      if (currentLexicalNode == null) {
        lexicalNodes = lexicalNodes.concat(childLexicalNodes);
      } else {
        if (lexical.$isElementNode(currentLexicalNode)) {
          currentLexicalNode.append(...childLexicalNodes);
        }
      }
      return lexicalNodes;
    }
    exports.$generateHtmlFromNodes = $generateHtmlFromNodes;
    exports.$generateNodesFromDOM = $generateNodesFromDOM;
  }
});

// node_modules/@lexical/html/LexicalHtml.js
var require_LexicalHtml = __commonJS({
  "node_modules/@lexical/html/LexicalHtml.js"(exports, module) {
    "use strict";
    var LexicalHtml = true ? require_LexicalHtml_dev() : null;
    module.exports = LexicalHtml;
  }
});

// node_modules/@lexical/clipboard/LexicalClipboard.dev.js
var require_LexicalClipboard_dev = __commonJS({
  "node_modules/@lexical/clipboard/LexicalClipboard.dev.js"(exports) {
    "use strict";
    var html = require_LexicalHtml();
    var selection = require_LexicalSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var getDOMSelection = (targetWindow) => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;
    function $getHtmlContent(editor) {
      const selection2 = lexical.$getSelection();
      if (selection2 == null) {
        {
          throw Error(`Expected valid LexicalSelection`);
        }
      }
      if (lexical.$isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {
        return "";
      }
      return html.$generateHtmlFromNodes(editor, selection2);
    }
    function $getLexicalContent(editor) {
      const selection2 = lexical.$getSelection();
      if (selection2 == null) {
        {
          throw Error(`Expected valid LexicalSelection`);
        }
      }
      if (lexical.$isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {
        return null;
      }
      return JSON.stringify($generateJSONFromSelectedNodes(editor, selection2));
    }
    function $insertDataTransferForPlainText(dataTransfer, selection2) {
      const text = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
      if (text != null) {
        selection2.insertRawText(text);
      }
    }
    function $insertDataTransferForRichText(dataTransfer, selection2, editor) {
      const lexicalString = dataTransfer.getData("application/x-lexical-editor");
      if (lexicalString) {
        try {
          const payload = JSON.parse(lexicalString);
          if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
            const nodes = $generateNodesFromSerializedNodes(payload.nodes);
            return $insertGeneratedNodes(editor, nodes, selection2);
          }
        } catch (_unused) {
        }
      }
      const htmlString = dataTransfer.getData("text/html");
      if (htmlString) {
        try {
          const parser = new DOMParser();
          const dom = parser.parseFromString(htmlString, "text/html");
          const nodes = html.$generateNodesFromDOM(editor, dom);
          return $insertGeneratedNodes(editor, nodes, selection2);
        } catch (_unused2) {
        }
      }
      const text = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
      if (text != null) {
        if (lexical.$isRangeSelection(selection2)) {
          const parts = text.split(/(\r?\n|\t)/);
          if (parts[parts.length - 1] === "") {
            parts.pop();
          }
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (part === "\n" || part === "\r\n") {
              selection2.insertParagraph();
            } else if (part === "	") {
              selection2.insertNodes([lexical.$createTabNode()]);
            } else {
              selection2.insertText(part);
            }
          }
        } else {
          selection2.insertRawText(text);
        }
      }
    }
    function $insertGeneratedNodes(editor, nodes, selection2) {
      if (!editor.dispatchCommand(lexical.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {
        nodes,
        selection: selection2
      })) {
        selection2.insertNodes(nodes);
      }
      return;
    }
    function exportNodeToJSON(node) {
      const serializedNode = node.exportJSON();
      const nodeClass = node.constructor;
      if (serializedNode.type !== nodeClass.getType()) {
        {
          throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
        }
      }
      if (lexical.$isElementNode(node)) {
        const serializedChildren = serializedNode.children;
        if (!Array.isArray(serializedChildren)) {
          {
            throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
          }
        }
      }
      return serializedNode;
    }
    function $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {
      let shouldInclude = selection$1 !== null ? currentNode.isSelected(selection$1) : true;
      const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy("html");
      let target = currentNode;
      if (selection$1 !== null) {
        let clone = selection.$cloneWithProperties(currentNode);
        clone = lexical.$isTextNode(clone) && selection$1 !== null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
        target = clone;
      }
      const children = lexical.$isElementNode(target) ? target.getChildren() : [];
      const serializedNode = exportNodeToJSON(target);
      if (lexical.$isTextNode(target)) {
        const text = target.__text;
        if (text.length > 0) {
          serializedNode.text = text;
        } else {
          shouldInclude = false;
        }
      }
      for (let i = 0; i < children.length; i++) {
        const childNode = children[i];
        const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);
        if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, "clone")) {
          shouldInclude = true;
        }
      }
      if (shouldInclude && !shouldExclude) {
        targetArray.push(serializedNode);
      } else if (Array.isArray(serializedNode.children)) {
        for (let i = 0; i < serializedNode.children.length; i++) {
          const serializedChildNode = serializedNode.children[i];
          targetArray.push(serializedChildNode);
        }
      }
      return shouldInclude;
    }
    function $generateJSONFromSelectedNodes(editor, selection2) {
      const nodes = [];
      const root = lexical.$getRoot();
      const topLevelChildren = root.getChildren();
      for (let i = 0; i < topLevelChildren.length; i++) {
        const topLevelNode = topLevelChildren[i];
        $appendNodesToJSON(editor, selection2, topLevelNode, nodes);
      }
      return {
        namespace: editor._config.namespace,
        nodes
      };
    }
    function $generateNodesFromSerializedNodes(serializedNodes) {
      const nodes = [];
      for (let i = 0; i < serializedNodes.length; i++) {
        const serializedNode = serializedNodes[i];
        const node = lexical.$parseSerializedNode(serializedNode);
        if (lexical.$isTextNode(node)) {
          selection.$addNodeStyle(node);
        }
        nodes.push(node);
      }
      return nodes;
    }
    var EVENT_LATENCY = 50;
    var clipboardEventTimeout = null;
    async function copyToClipboard(editor, event) {
      if (clipboardEventTimeout !== null) {
        return false;
      }
      if (event !== null) {
        return new Promise((resolve, reject) => {
          editor.update(() => {
            resolve($copyToClipboardEvent(editor, event));
          });
        });
      }
      const rootElement = editor.getRootElement();
      const windowDocument = editor._window == null ? window.document : editor._window.document;
      const domSelection = getDOMSelection(editor._window);
      if (rootElement === null || domSelection === null) {
        return false;
      }
      const element = windowDocument.createElement("span");
      element.style.cssText = "position: fixed; top: -1000px;";
      element.append(windowDocument.createTextNode("#"));
      rootElement.append(element);
      const range = new Range();
      range.setStart(element, 0);
      range.setEnd(element, 1);
      domSelection.removeAllRanges();
      domSelection.addRange(range);
      return new Promise((resolve, reject) => {
        const removeListener = editor.registerCommand(lexical.COPY_COMMAND, (secondEvent) => {
          if (utils.objectKlassEquals(secondEvent, ClipboardEvent)) {
            removeListener();
            if (clipboardEventTimeout !== null) {
              window.clearTimeout(clipboardEventTimeout);
              clipboardEventTimeout = null;
            }
            resolve($copyToClipboardEvent(editor, secondEvent));
          }
          return true;
        }, lexical.COMMAND_PRIORITY_CRITICAL);
        clipboardEventTimeout = window.setTimeout(() => {
          removeListener();
          clipboardEventTimeout = null;
          resolve(false);
        }, EVENT_LATENCY);
        windowDocument.execCommand("copy");
        element.remove();
      });
    }
    function $copyToClipboardEvent(editor, event) {
      const domSelection = getDOMSelection(editor._window);
      if (!domSelection) {
        return false;
      }
      const anchorDOM = domSelection.anchorNode;
      const focusDOM = domSelection.focusNode;
      if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
        return false;
      }
      event.preventDefault();
      const clipboardData = event.clipboardData;
      const selection2 = lexical.$getSelection();
      if (clipboardData === null || selection2 === null) {
        return false;
      }
      const htmlString = $getHtmlContent(editor);
      const lexicalString = $getLexicalContent(editor);
      let plainString = "";
      if (selection2 !== null) {
        plainString = selection2.getTextContent();
      }
      if (htmlString !== null) {
        clipboardData.setData("text/html", htmlString);
      }
      if (lexicalString !== null) {
        clipboardData.setData("application/x-lexical-editor", lexicalString);
      }
      clipboardData.setData("text/plain", plainString);
      return true;
    }
    exports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;
    exports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;
    exports.$getHtmlContent = $getHtmlContent;
    exports.$getLexicalContent = $getLexicalContent;
    exports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;
    exports.$insertDataTransferForRichText = $insertDataTransferForRichText;
    exports.$insertGeneratedNodes = $insertGeneratedNodes;
    exports.copyToClipboard = copyToClipboard;
  }
});

// node_modules/@lexical/clipboard/LexicalClipboard.js
var require_LexicalClipboard = __commonJS({
  "node_modules/@lexical/clipboard/LexicalClipboard.js"(exports, module) {
    "use strict";
    var LexicalClipboard = true ? require_LexicalClipboard_dev() : null;
    module.exports = LexicalClipboard;
  }
});

// node_modules/@lexical/rich-text/LexicalRichText.dev.js
var require_LexicalRichText_dev = __commonJS({
  "node_modules/@lexical/rich-text/LexicalRichText.dev.js"(exports) {
    "use strict";
    var clipboard = require_LexicalClipboard();
    var selection = require_LexicalSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    function caretFromPoint(x, y) {
      if (typeof document.caretRangeFromPoint !== "undefined") {
        const range = document.caretRangeFromPoint(x, y);
        if (range === null) {
          return null;
        }
        return {
          node: range.startContainer,
          offset: range.startOffset
        };
      } else if (document.caretPositionFromPoint !== "undefined") {
        const range = document.caretPositionFromPoint(x, y);
        if (range === null) {
          return null;
        }
        return {
          node: range.offsetNode,
          offset: range.offset
        };
      } else {
        return null;
      }
    }
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
    CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    var CAN_USE_BEFORE_INPUT = CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
    var IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    var IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    CAN_USE_DOM && /Android/.test(navigator.userAgent);
    var IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    var IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
    var DRAG_DROP_PASTE = lexical.createCommand("DRAG_DROP_PASTE_FILE");
    var QuoteNode = class _QuoteNode extends lexical.ElementNode {
      static getType() {
        return "quote";
      }
      static clone(node) {
        return new _QuoteNode(node.__key);
      }
      constructor(key) {
        super(key);
      }
      // View
      createDOM(config) {
        const element = document.createElement("blockquote");
        utils.addClassNamesToElement(element, config.theme.quote);
        return element;
      }
      updateDOM(prevNode, dom) {
        return false;
      }
      static importDOM() {
        return {
          blockquote: (node) => ({
            conversion: convertBlockquoteElement,
            priority: 0
          })
        };
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (element && utils.isHTMLElement(element)) {
          if (this.isEmpty()) element.append(document.createElement("br"));
          const formatType = this.getFormatType();
          element.style.textAlign = formatType;
          const direction = this.getDirection();
          if (direction) {
            element.dir = direction;
          }
        }
        return {
          element
        };
      }
      static importJSON(serializedNode) {
        const node = $createQuoteNode();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          type: "quote"
        };
      }
      // Mutation
      insertNewAfter(_, restoreSelection) {
        const newBlock = lexical.$createParagraphNode();
        const direction = this.getDirection();
        newBlock.setDirection(direction);
        this.insertAfter(newBlock, restoreSelection);
        return newBlock;
      }
      collapseAtStart() {
        const paragraph = lexical.$createParagraphNode();
        const children = this.getChildren();
        children.forEach((child) => paragraph.append(child));
        this.replace(paragraph);
        return true;
      }
    };
    function $createQuoteNode() {
      return lexical.$applyNodeReplacement(new QuoteNode());
    }
    function $isQuoteNode(node) {
      return node instanceof QuoteNode;
    }
    var HeadingNode = class _HeadingNode extends lexical.ElementNode {
      /** @internal */
      static getType() {
        return "heading";
      }
      static clone(node) {
        return new _HeadingNode(node.__tag, node.__key);
      }
      constructor(tag, key) {
        super(key);
        this.__tag = tag;
      }
      getTag() {
        return this.__tag;
      }
      // View
      createDOM(config) {
        const tag = this.__tag;
        const element = document.createElement(tag);
        const theme = config.theme;
        const classNames = theme.heading;
        if (classNames !== void 0) {
          const className = classNames[tag];
          utils.addClassNamesToElement(element, className);
        }
        return element;
      }
      updateDOM(prevNode, dom) {
        return false;
      }
      static importDOM() {
        return {
          h1: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h2: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h3: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h4: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h5: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h6: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          p: (node) => {
            const paragraph = node;
            const firstChild = paragraph.firstChild;
            if (firstChild !== null && isGoogleDocsTitle(firstChild)) {
              return {
                conversion: () => ({
                  node: null
                }),
                priority: 3
              };
            }
            return null;
          },
          span: (node) => {
            if (isGoogleDocsTitle(node)) {
              return {
                conversion: (domNode) => {
                  return {
                    node: $createHeadingNode("h1")
                  };
                },
                priority: 3
              };
            }
            return null;
          }
        };
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (element && utils.isHTMLElement(element)) {
          if (this.isEmpty()) element.append(document.createElement("br"));
          const formatType = this.getFormatType();
          element.style.textAlign = formatType;
          const direction = this.getDirection();
          if (direction) {
            element.dir = direction;
          }
        }
        return {
          element
        };
      }
      static importJSON(serializedNode) {
        const node = $createHeadingNode(serializedNode.tag);
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          tag: this.getTag(),
          type: "heading",
          version: 1
        };
      }
      // Mutation
      insertNewAfter(selection2, restoreSelection = true) {
        const anchorOffet = selection2 ? selection2.anchor.offset : 0;
        const newElement = anchorOffet === this.getTextContentSize() || !selection2 ? lexical.$createParagraphNode() : $createHeadingNode(this.getTag());
        const direction = this.getDirection();
        newElement.setDirection(direction);
        this.insertAfter(newElement, restoreSelection);
        if (anchorOffet === 0 && !this.isEmpty() && selection2) {
          const paragraph = lexical.$createParagraphNode();
          paragraph.select();
          this.replace(paragraph, true);
        }
        return newElement;
      }
      collapseAtStart() {
        const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();
        const children = this.getChildren();
        children.forEach((child) => newElement.append(child));
        this.replace(newElement);
        return true;
      }
      extractWithChild() {
        return true;
      }
    };
    function isGoogleDocsTitle(domNode) {
      if (domNode.nodeName.toLowerCase() === "span") {
        return domNode.style.fontSize === "26pt";
      }
      return false;
    }
    function convertHeadingElement(element) {
      const nodeName = element.nodeName.toLowerCase();
      let node = null;
      if (nodeName === "h1" || nodeName === "h2" || nodeName === "h3" || nodeName === "h4" || nodeName === "h5" || nodeName === "h6") {
        node = $createHeadingNode(nodeName);
        if (element.style !== null) {
          node.setFormat(element.style.textAlign);
        }
      }
      return {
        node
      };
    }
    function convertBlockquoteElement(element) {
      const node = $createQuoteNode();
      if (element.style !== null) {
        node.setFormat(element.style.textAlign);
      }
      return {
        node
      };
    }
    function $createHeadingNode(headingTag) {
      return lexical.$applyNodeReplacement(new HeadingNode(headingTag));
    }
    function $isHeadingNode(node) {
      return node instanceof HeadingNode;
    }
    function onPasteForRichText(event, editor) {
      event.preventDefault();
      editor.update(() => {
        const selection2 = lexical.$getSelection();
        const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;
        if (clipboardData != null && selection2 !== null) {
          clipboard.$insertDataTransferForRichText(clipboardData, selection2, editor);
        }
      }, {
        tag: "paste"
      });
    }
    async function onCutForRichText(event, editor) {
      await clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);
      editor.update(() => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection2)) {
          selection2.removeText();
        } else if (lexical.$isNodeSelection(selection2)) {
          selection2.getNodes().forEach((node) => node.remove());
        }
      });
    }
    function eventFiles(event) {
      let dataTransfer = null;
      if (event instanceof DragEvent) {
        dataTransfer = event.dataTransfer;
      } else if (event instanceof ClipboardEvent) {
        dataTransfer = event.clipboardData;
      }
      if (dataTransfer === null) {
        return [false, [], false];
      }
      const types = dataTransfer.types;
      const hasFiles = types.includes("Files");
      const hasContent = types.includes("text/html") || types.includes("text/plain");
      return [hasFiles, Array.from(dataTransfer.files), hasContent];
    }
    function handleIndentAndOutdent(indentOrOutdent) {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      const alreadyHandled = /* @__PURE__ */ new Set();
      const nodes = selection2.getNodes();
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const key = node.getKey();
        if (alreadyHandled.has(key)) {
          continue;
        }
        const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);
        const parentKey = parentBlock.getKey();
        if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {
          alreadyHandled.add(parentKey);
          indentOrOutdent(parentBlock);
        }
      }
      return alreadyHandled.size > 0;
    }
    function $isTargetWithinDecorator(target) {
      const node = lexical.$getNearestNodeFromDOMNode(target);
      return lexical.$isDecoratorNode(node);
    }
    function $isSelectionAtEndOfRoot(selection2) {
      const focus = selection2.focus;
      return focus.key === "root" && focus.offset === lexical.$getRoot().getChildrenSize();
    }
    function registerRichText(editor) {
      const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, (payload) => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection2)) {
          selection2.clear();
          return true;
        }
        return false;
      }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, (isBackward) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.deleteCharacter(isBackward);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, (isBackward) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.deleteWord(isBackward);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, (isBackward) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.deleteLine(isBackward);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, (eventOrText) => {
        const selection2 = lexical.$getSelection();
        if (typeof eventOrText === "string") {
          if (selection2 !== null) {
            selection2.insertText(eventOrText);
          }
        } else {
          if (selection2 === null) {
            return false;
          }
          const dataTransfer = eventOrText.dataTransfer;
          if (dataTransfer != null) {
            clipboard.$insertDataTransferForRichText(dataTransfer, selection2, editor);
          } else if (lexical.$isRangeSelection(selection2)) {
            const data = eventOrText.data;
            if (data) {
              selection2.insertText(data);
            }
            return true;
          }
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.removeText();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, (format) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.formatText(format);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, (format) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2) && !lexical.$isNodeSelection(selection2)) {
          return false;
        }
        const nodes = selection2.getNodes();
        for (const node of nodes) {
          const element = utils.$findMatchingParent(node, (parentNode) => lexical.$isElementNode(parentNode) && !parentNode.isInline());
          if (element !== null) {
            element.setFormat(format);
          }
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, (selectStart) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.insertLineBreak(selectStart);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.insertParagraph();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {
        lexical.$insertNodes([lexical.$createTabNode()]);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {
        return handleIndentAndOutdent((block) => {
          const indent = block.getIndent();
          block.setIndent(indent + 1);
        });
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {
        return handleIndentAndOutdent((block) => {
          const indent = block.getIndent();
          if (indent > 0) {
            block.setIndent(indent - 1);
          }
        });
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, (event) => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection2) && !$isTargetWithinDecorator(event.target)) {
          const nodes = selection2.getNodes();
          if (nodes.length > 0) {
            nodes[0].selectPrevious();
            return true;
          }
        } else if (lexical.$isRangeSelection(selection2)) {
          const possibleNode = lexical.$getAdjacentNode(selection2.focus, true);
          if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
            possibleNode.selectPrevious();
            event.preventDefault();
            return true;
          }
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, (event) => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection2)) {
          const nodes = selection2.getNodes();
          if (nodes.length > 0) {
            nodes[0].selectNext(0, 0);
            return true;
          }
        } else if (lexical.$isRangeSelection(selection2)) {
          if ($isSelectionAtEndOfRoot(selection2)) {
            event.preventDefault();
            return true;
          }
          const possibleNode = lexical.$getAdjacentNode(selection2.focus, false);
          if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
            possibleNode.selectNext();
            event.preventDefault();
            return true;
          }
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, (event) => {
        const selection$1 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection$1)) {
          const nodes = selection$1.getNodes();
          if (nodes.length > 0) {
            event.preventDefault();
            nodes[0].selectPrevious();
            return true;
          }
        }
        if (!lexical.$isRangeSelection(selection$1)) {
          return false;
        }
        if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {
          const isHoldingShift = event.shiftKey;
          event.preventDefault();
          selection.$moveCharacter(selection$1, isHoldingShift, true);
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, (event) => {
        const selection$1 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {
          const nodes = selection$1.getNodes();
          if (nodes.length > 0) {
            event.preventDefault();
            nodes[0].selectNext(0, 0);
            return true;
          }
        }
        if (!lexical.$isRangeSelection(selection$1)) {
          return false;
        }
        const isHoldingShift = event.shiftKey;
        if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {
          event.preventDefault();
          selection.$moveCharacter(selection$1, isHoldingShift, false);
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, (event) => {
        if ($isTargetWithinDecorator(event.target)) {
          return false;
        }
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        event.preventDefault();
        const {
          anchor
        } = selection2;
        const anchorNode = anchor.getNode();
        if (selection2.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {
          const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);
          if (element.getIndent() > 0) {
            return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, void 0);
          }
        }
        return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, (event) => {
        if ($isTargetWithinDecorator(event.target)) {
          return false;
        }
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        event.preventDefault();
        return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, (event) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        if (event !== null) {
          if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {
            return false;
          }
          event.preventDefault();
          if (event.shiftKey) {
            return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);
          }
        }
        return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, void 0);
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        editor.blur();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, (event) => {
        const [, files] = eventFiles(event);
        if (files.length > 0) {
          const x = event.clientX;
          const y = event.clientY;
          const eventRange = caretFromPoint(x, y);
          if (eventRange !== null) {
            const {
              offset: domOffset,
              node: domNode
            } = eventRange;
            const node = lexical.$getNearestNodeFromDOMNode(domNode);
            if (node !== null) {
              const selection3 = lexical.$createRangeSelection();
              if (lexical.$isTextNode(node)) {
                selection3.anchor.set(node.getKey(), domOffset, "text");
                selection3.focus.set(node.getKey(), domOffset, "text");
              } else {
                const parentKey = node.getParentOrThrow().getKey();
                const offset = node.getIndexWithinParent() + 1;
                selection3.anchor.set(parentKey, offset, "element");
                selection3.focus.set(parentKey, offset, "element");
              }
              const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection3);
              lexical.$setSelection(normalizedSelection);
            }
            editor.dispatchCommand(DRAG_DROP_PASTE, files);
          }
          event.preventDefault();
          return true;
        }
        const selection2 = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection2)) {
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, (event) => {
        const [isFileTransfer] = eventFiles(event);
        const selection2 = lexical.$getSelection();
        if (isFileTransfer && !lexical.$isRangeSelection(selection2)) {
          return false;
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, (event) => {
        const [isFileTransfer] = eventFiles(event);
        const selection2 = lexical.$getSelection();
        if (isFileTransfer && !lexical.$isRangeSelection(selection2)) {
          return false;
        }
        const x = event.clientX;
        const y = event.clientY;
        const eventRange = caretFromPoint(x, y);
        if (eventRange !== null) {
          const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);
          if (lexical.$isDecoratorNode(node)) {
            event.preventDefault();
          }
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.SELECT_ALL_COMMAND, () => {
        lexical.$selectAll();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, (event) => {
        clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, (event) => {
        onCutForRichText(event, editor);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, (event) => {
        const [, files, hasTextContent] = eventFiles(event);
        if (files.length > 0 && !hasTextContent) {
          editor.dispatchCommand(DRAG_DROP_PASTE, files);
          return true;
        }
        if (lexical.isSelectionCapturedInDecoratorInput(event.target)) {
          return false;
        }
        const selection2 = lexical.$getSelection();
        if (selection2 !== null) {
          onPasteForRichText(event, editor);
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR));
      return removeListener;
    }
    exports.$createHeadingNode = $createHeadingNode;
    exports.$createQuoteNode = $createQuoteNode;
    exports.$isHeadingNode = $isHeadingNode;
    exports.$isQuoteNode = $isQuoteNode;
    exports.DRAG_DROP_PASTE = DRAG_DROP_PASTE;
    exports.HeadingNode = HeadingNode;
    exports.QuoteNode = QuoteNode;
    exports.eventFiles = eventFiles;
    exports.registerRichText = registerRichText;
  }
});

// node_modules/@lexical/rich-text/LexicalRichText.js
var require_LexicalRichText = __commonJS({
  "node_modules/@lexical/rich-text/LexicalRichText.js"(exports, module) {
    var LexicalRichText = true ? require_LexicalRichText_dev() : null;
    module.exports = LexicalRichText;
  }
});

export {
  require_LexicalRichText
};
//# sourceMappingURL=chunk-PRA4JQTI.js.map
