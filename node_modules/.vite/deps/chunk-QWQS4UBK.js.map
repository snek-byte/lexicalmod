{
  "version": 3,
  "sources": ["../../@lexical/list/LexicalList.dev.js", "../../@lexical/list/LexicalList.js"],
  "sourcesContent": ["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\nvar lexical = require('lexical');\r\nvar utils = require('@lexical/utils');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n/**\r\n * Checks the depth of listNode from the root node.\r\n * @param listNode - The ListNode to be checked.\r\n * @returns The depth of the ListNode.\r\n */\r\nfunction $getListDepth(listNode) {\r\n  let depth = 1;\r\n  let parent = listNode.getParent();\r\n  while (parent != null) {\r\n    if ($isListItemNode(parent)) {\r\n      const parentList = parent.getParent();\r\n      if ($isListNode(parentList)) {\r\n        depth++;\r\n        parent = parentList.getParent();\r\n        continue;\r\n      }\r\n      {\r\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\r\n      }\r\n    }\r\n    return depth;\r\n  }\r\n  return depth;\r\n}\r\n\r\n/**\r\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\r\n * @param listItem - The node to be checked.\r\n * @returns The ListNode found.\r\n */\r\nfunction $getTopListNode(listItem) {\r\n  let list = listItem.getParent();\r\n  if (!$isListNode(list)) {\r\n    {\r\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\r\n    }\r\n  }\r\n  let parent = list;\r\n  while (parent !== null) {\r\n    parent = parent.getParent();\r\n    if ($isListNode(parent)) {\r\n      list = parent;\r\n    }\r\n  }\r\n  return list;\r\n}\r\n\r\n/**\r\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\r\n * that are of type ListItemNode and returns them in an array.\r\n * @param node - The ListNode to start the search.\r\n * @returns An array containing all nodes of type ListItemNode found.\r\n */\r\n// This should probably be $getAllChildrenOfType\r\nfunction $getAllListItems(node) {\r\n  let listItemNodes = [];\r\n  const listChildren = node.getChildren().filter($isListItemNode);\r\n  for (let i = 0; i < listChildren.length; i++) {\r\n    const listItemNode = listChildren[i];\r\n    const firstChild = listItemNode.getFirstChild();\r\n    if ($isListNode(firstChild)) {\r\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\r\n    } else {\r\n      listItemNodes.push(listItemNode);\r\n    }\r\n  }\r\n  return listItemNodes;\r\n}\r\n\r\n/**\r\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\r\n * @param node - The node to be checked.\r\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\r\n */\r\nfunction isNestedListNode(node) {\r\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\r\n}\r\n\r\n/**\r\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\r\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\r\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\r\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\r\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\r\n */\r\nfunction $removeHighestEmptyListParent(sublist) {\r\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\r\n  // contain just one bullet.\r\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\r\n  // way to do that is crawl back up the tree until we find a node that has siblings\r\n  // (e.g. is actually part of the list contents) and delete that, or delete\r\n  // the root of the list (if no list nodes have siblings.)\r\n  let emptyListPtr = sublist;\r\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\r\n    const parent = emptyListPtr.getParent();\r\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\r\n      break;\r\n    }\r\n    emptyListPtr = parent;\r\n  }\r\n  emptyListPtr.remove();\r\n}\r\n\r\n/**\r\n * Wraps a node into a ListItemNode.\r\n * @param node - The node to be wrapped into a ListItemNode\r\n * @returns The ListItemNode which the passed node is wrapped in.\r\n */\r\nfunction wrapInListItem(node) {\r\n  const listItemWrapper = $createListItemNode();\r\n  return listItemWrapper.append(node);\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\r\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\r\n}\r\nfunction $getListItemValue(listItem) {\r\n  const list = listItem.getParent();\r\n  let value = 1;\r\n  if (list != null) {\r\n    if (!$isListNode(list)) {\r\n      {\r\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\r\n      }\r\n    } else {\r\n      value = list.getStart();\r\n    }\r\n  }\r\n  const siblings = listItem.getPreviousSiblings();\r\n  for (let i = 0; i < siblings.length; i++) {\r\n    const sibling = siblings[i];\r\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\r\n      value++;\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\r\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\r\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\r\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\r\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\r\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\r\n * @param editor - The lexical editor.\r\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\r\n */\r\nfunction insertList(editor, listType) {\r\n  editor.update(() => {\r\n    const selection = lexical.$getSelection();\r\n    if (selection !== null) {\r\n      const nodes = selection.getNodes();\r\n      const anchorAndFocus = selection.getStartEndPoints();\r\n      if (!(anchorAndFocus !== null)) {\r\n        throw Error(`insertList: anchor should be defined`);\r\n      }\r\n      const [anchor] = anchorAndFocus;\r\n      const anchorNode = anchor.getNode();\r\n      const anchorNodeParent = anchorNode.getParent();\r\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\r\n        const list = $createListNode(listType);\r\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\r\n          anchorNode.replace(list);\r\n          const listItem = $createListItemNode();\r\n          if (lexical.$isElementNode(anchorNode)) {\r\n            listItem.setFormat(anchorNode.getFormatType());\r\n            listItem.setIndent(anchorNode.getIndent());\r\n          }\r\n          list.append(listItem);\r\n        } else if ($isListItemNode(anchorNode)) {\r\n          const parent = anchorNode.getParentOrThrow();\r\n          append(list, parent.getChildren());\r\n          parent.replace(list);\r\n        }\r\n        return;\r\n      } else {\r\n        const handled = new Set();\r\n        for (let i = 0; i < nodes.length; i++) {\r\n          const node = nodes[i];\r\n          if (lexical.$isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\r\n            createListOrMerge(node, listType);\r\n            continue;\r\n          }\r\n          if (lexical.$isLeafNode(node)) {\r\n            let parent = node.getParent();\r\n            while (parent != null) {\r\n              const parentKey = parent.getKey();\r\n              if ($isListNode(parent)) {\r\n                if (!handled.has(parentKey)) {\r\n                  const newListNode = $createListNode(listType);\r\n                  append(newListNode, parent.getChildren());\r\n                  parent.replace(newListNode);\r\n                  updateChildrenListItemValue(newListNode);\r\n                  handled.add(parentKey);\r\n                }\r\n                break;\r\n              } else {\r\n                const nextParent = parent.getParent();\r\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\r\n                  handled.add(parentKey);\r\n                  createListOrMerge(parent, listType);\r\n                  break;\r\n                }\r\n                parent = nextParent;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\nfunction append(node, nodesToAppend) {\r\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\r\n}\r\nfunction createListOrMerge(node, listType) {\r\n  if ($isListNode(node)) {\r\n    return node;\r\n  }\r\n  const previousSibling = node.getPreviousSibling();\r\n  const nextSibling = node.getNextSibling();\r\n  const listItem = $createListItemNode();\r\n  listItem.setFormat(node.getFormatType());\r\n  listItem.setIndent(node.getIndent());\r\n  append(listItem, node.getChildren());\r\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\r\n    previousSibling.append(listItem);\r\n    node.remove();\r\n    // if the same type of list is on both sides, merge them.\r\n\r\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\r\n      append(previousSibling, nextSibling.getChildren());\r\n      nextSibling.remove();\r\n    }\r\n    return previousSibling;\r\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\r\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\r\n    node.remove();\r\n    return nextSibling;\r\n  } else {\r\n    const list = $createListNode(listType);\r\n    list.append(listItem);\r\n    node.replace(list);\r\n    updateChildrenListItemValue(list);\r\n    return list;\r\n  }\r\n}\r\n\r\n/**\r\n * A recursive function that goes through each list and their children, including nested lists,\r\n * appending list2 children after list1 children and updating ListItemNode values.\r\n * @param list1 - The first list to be merged.\r\n * @param list2 - The second list to be merged.\r\n */\r\nfunction mergeLists(list1, list2) {\r\n  const listItem1 = list1.getLastChild();\r\n  const listItem2 = list2.getFirstChild();\r\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\r\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\r\n    listItem2.remove();\r\n  }\r\n  const toMerge = list2.getChildren();\r\n  if (toMerge.length > 0) {\r\n    list1.append(...toMerge);\r\n    updateChildrenListItemValue(list1);\r\n  }\r\n  list2.remove();\r\n}\r\n\r\n/**\r\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\r\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\r\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\r\n * inside a ListItemNode will be appended to the new ParagraphNodes.\r\n * @param editor - The lexical editor.\r\n */\r\nfunction removeList(editor) {\r\n  editor.update(() => {\r\n    const selection = lexical.$getSelection();\r\n    if (lexical.$isRangeSelection(selection)) {\r\n      const listNodes = new Set();\r\n      const nodes = selection.getNodes();\r\n      const anchorNode = selection.anchor.getNode();\r\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\r\n        listNodes.add($getTopListNode(anchorNode));\r\n      } else {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n          const node = nodes[i];\r\n          if (lexical.$isLeafNode(node)) {\r\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\r\n            if (listItemNode != null) {\r\n              listNodes.add($getTopListNode(listItemNode));\r\n            }\r\n          }\r\n        }\r\n      }\r\n      for (const listNode of listNodes) {\r\n        let insertionPoint = listNode;\r\n        const listItems = $getAllListItems(listNode);\r\n        for (const listItemNode of listItems) {\r\n          const paragraph = lexical.$createParagraphNode();\r\n          append(paragraph, listItemNode.getChildren());\r\n          insertionPoint.insertAfter(paragraph);\r\n          insertionPoint = paragraph;\r\n\r\n          // When the anchor and focus fall on the textNode\r\n          // we don't have to change the selection because the textNode will be appended to\r\n          // the newly generated paragraph.\r\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\r\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\r\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\r\n          if (listItemNode.__key === selection.anchor.key) {\r\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\r\n          }\r\n          if (listItemNode.__key === selection.focus.key) {\r\n            selection.focus.set(paragraph.getKey(), 0, 'element');\r\n          }\r\n          listItemNode.remove();\r\n        }\r\n        listNode.remove();\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\r\n * should be if it isn't already. If only certain children should be updated, they\r\n * can be passed optionally in an array.\r\n * @param list - The list whose children are updated.\r\n * @param children - An array of the children to be updated.\r\n */\r\nfunction updateChildrenListItemValue(list, children) {\r\n  const childrenOrExisting = children || list.getChildren();\r\n  if (childrenOrExisting !== undefined) {\r\n    for (let i = 0; i < childrenOrExisting.length; i++) {\r\n      const child = childrenOrExisting[i];\r\n      if ($isListItemNode(child)) {\r\n        const prevValue = child.getValue();\r\n        const nextValue = $getListItemValue(child);\r\n        if (prevValue !== nextValue) {\r\n          child.setValue(nextValue);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\r\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\r\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\r\n * @param listItemNode - The ListItemNode to be indented.\r\n */\r\nfunction $handleIndent(listItemNode) {\r\n  // go through each node and decide where to move it.\r\n  const removed = new Set();\r\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\r\n    return;\r\n  }\r\n  const parent = listItemNode.getParent();\r\n\r\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\r\n  const nextSibling = listItemNode.getNextSibling();\r\n  const previousSibling = listItemNode.getPreviousSibling();\r\n  // if there are nested lists on either side, merge them all together.\r\n\r\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\r\n    const innerList = previousSibling.getFirstChild();\r\n    if ($isListNode(innerList)) {\r\n      innerList.append(listItemNode);\r\n      const nextInnerList = nextSibling.getFirstChild();\r\n      if ($isListNode(nextInnerList)) {\r\n        const children = nextInnerList.getChildren();\r\n        append(innerList, children);\r\n        nextSibling.remove();\r\n        removed.add(nextSibling.getKey());\r\n      }\r\n      updateChildrenListItemValue(innerList);\r\n    }\r\n  } else if (isNestedListNode(nextSibling)) {\r\n    // if the ListItemNode is next to a nested ListNode, merge them\r\n    const innerList = nextSibling.getFirstChild();\r\n    if ($isListNode(innerList)) {\r\n      const firstChild = innerList.getFirstChild();\r\n      if (firstChild !== null) {\r\n        firstChild.insertBefore(listItemNode);\r\n      }\r\n      updateChildrenListItemValue(innerList);\r\n    }\r\n  } else if (isNestedListNode(previousSibling)) {\r\n    const innerList = previousSibling.getFirstChild();\r\n    if ($isListNode(innerList)) {\r\n      innerList.append(listItemNode);\r\n      updateChildrenListItemValue(innerList);\r\n    }\r\n  } else {\r\n    // otherwise, we need to create a new nested ListNode\r\n\r\n    if ($isListNode(parent)) {\r\n      const newListItem = $createListItemNode();\r\n      const newList = $createListNode(parent.getListType());\r\n      newListItem.append(newList);\r\n      newList.append(listItemNode);\r\n      if (previousSibling) {\r\n        previousSibling.insertAfter(newListItem);\r\n      } else if (nextSibling) {\r\n        nextSibling.insertBefore(newListItem);\r\n      } else {\r\n        parent.append(newListItem);\r\n      }\r\n      updateChildrenListItemValue(newList);\r\n    }\r\n  }\r\n  if ($isListNode(parent)) {\r\n    updateChildrenListItemValue(parent);\r\n  }\r\n}\r\n\r\n/**\r\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\r\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\r\n * within as a child.\r\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\r\n */\r\nfunction $handleOutdent(listItemNode) {\r\n  // go through each node and decide where to move it.\r\n\r\n  if (isNestedListNode(listItemNode)) {\r\n    return;\r\n  }\r\n  const parentList = listItemNode.getParent();\r\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\r\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\r\n  // If it doesn't have these ancestors, it's not indented.\r\n\r\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\r\n    // if it's the first child in it's parent list, insert it into the\r\n    // great grandparent list before the grandparent\r\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\r\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\r\n    if (listItemNode.is(firstChild)) {\r\n      grandparentListItem.insertBefore(listItemNode);\r\n      if (parentList.isEmpty()) {\r\n        grandparentListItem.remove();\r\n      }\r\n      // if it's the last child in it's parent list, insert it into the\r\n      // great grandparent list after the grandparent.\r\n    } else if (listItemNode.is(lastChild)) {\r\n      grandparentListItem.insertAfter(listItemNode);\r\n      if (parentList.isEmpty()) {\r\n        grandparentListItem.remove();\r\n      }\r\n    } else {\r\n      // otherwise, we need to split the siblings into two new nested lists\r\n      const listType = parentList.getListType();\r\n      const previousSiblingsListItem = $createListItemNode();\r\n      const previousSiblingsList = $createListNode(listType);\r\n      previousSiblingsListItem.append(previousSiblingsList);\r\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\r\n      const nextSiblingsListItem = $createListItemNode();\r\n      const nextSiblingsList = $createListNode(listType);\r\n      nextSiblingsListItem.append(nextSiblingsList);\r\n      append(nextSiblingsList, listItemNode.getNextSiblings());\r\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\r\n      grandparentListItem.insertBefore(previousSiblingsListItem);\r\n      grandparentListItem.insertAfter(nextSiblingsListItem);\r\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\r\n      grandparentListItem.replace(listItemNode);\r\n    }\r\n    updateChildrenListItemValue(parentList);\r\n    updateChildrenListItemValue(greatGrandparentList);\r\n  }\r\n}\r\n\r\n/**\r\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\r\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\r\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\r\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\r\n * Throws an invariant if the selection is not a child of a ListNode.\r\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\r\n * or the selection does not contain a ListItemNode or the node already holds text.\r\n */\r\nfunction $handleListInsertParagraph() {\r\n  const selection = lexical.$getSelection();\r\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\r\n    return false;\r\n  }\r\n  // Only run this code on empty list items\r\n  const anchor = selection.anchor.getNode();\r\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\r\n    return false;\r\n  }\r\n  const topListNode = $getTopListNode(anchor);\r\n  const parent = anchor.getParent();\r\n  if (!$isListNode(parent)) {\r\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\r\n  }\r\n  const grandparent = parent.getParent();\r\n  let replacementNode;\r\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\r\n    replacementNode = lexical.$createParagraphNode();\r\n    topListNode.insertAfter(replacementNode);\r\n  } else if ($isListItemNode(grandparent)) {\r\n    replacementNode = $createListItemNode();\r\n    grandparent.insertAfter(replacementNode);\r\n  } else {\r\n    return false;\r\n  }\r\n  replacementNode.select();\r\n  const nextSiblings = anchor.getNextSiblings();\r\n  if (nextSiblings.length > 0) {\r\n    const newList = $createListNode(parent.getListType());\r\n    if (lexical.$isParagraphNode(replacementNode)) {\r\n      replacementNode.insertAfter(newList);\r\n    } else {\r\n      const newListItem = $createListItemNode();\r\n      newListItem.append(newList);\r\n      replacementNode.insertAfter(newListItem);\r\n    }\r\n    nextSiblings.forEach(sibling => {\r\n      sibling.remove();\r\n      newList.append(sibling);\r\n    });\r\n  }\r\n\r\n  // Don't leave hanging nested empty lists\r\n  $removeHighestEmptyListParent(anchor);\r\n  return true;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass ListItemNode extends lexical.ElementNode {\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  static getType() {\r\n    return 'listitem';\r\n  }\r\n  static clone(node) {\r\n    return new ListItemNode(node.__value, node.__checked, node.__key);\r\n  }\r\n  constructor(value, checked, key) {\r\n    super(key);\r\n    this.__value = value === undefined ? 1 : value;\r\n    this.__checked = checked;\r\n  }\r\n  createDOM(config) {\r\n    const element = document.createElement('li');\r\n    const parent = this.getParent();\r\n    if ($isListNode(parent) && parent.getListType() === 'check') {\r\n      updateListItemChecked(element, this, null);\r\n    }\r\n    element.value = this.__value;\r\n    $setListItemThemeClassNames(element, config.theme, this);\r\n    return element;\r\n  }\r\n  updateDOM(prevNode, dom, config) {\r\n    const parent = this.getParent();\r\n    if ($isListNode(parent) && parent.getListType() === 'check') {\r\n      updateListItemChecked(dom, this, prevNode);\r\n    }\r\n    // @ts-expect-error - this is always HTMLListItemElement\r\n    dom.value = this.__value;\r\n    $setListItemThemeClassNames(dom, config.theme, this);\r\n    return false;\r\n  }\r\n  static transform() {\r\n    return node => {\r\n      const parent = node.getParent();\r\n      if ($isListNode(parent)) {\r\n        updateChildrenListItemValue(parent);\r\n        if (!$isListItemNode(node)) {\r\n          throw Error(`node is not a ListItemNode`);\r\n        }\r\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\r\n          node.setChecked(undefined);\r\n        }\r\n      }\r\n    };\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      li: node => ({\r\n        conversion: convertListItemElement,\r\n        priority: 0\r\n      })\r\n    };\r\n  }\r\n  static importJSON(serializedNode) {\r\n    const node = $createListItemNode();\r\n    node.setChecked(serializedNode.checked);\r\n    node.setValue(serializedNode.value);\r\n    node.setFormat(serializedNode.format);\r\n    node.setDirection(serializedNode.direction);\r\n    return node;\r\n  }\r\n  exportDOM(editor) {\r\n    const element = this.createDOM(editor._config);\r\n    element.style.textAlign = this.getFormatType();\r\n    return {\r\n      element\r\n    };\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      checked: this.getChecked(),\r\n      type: 'listitem',\r\n      value: this.getValue(),\r\n      version: 1\r\n    };\r\n  }\r\n  append(...nodes) {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      const node = nodes[i];\r\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\r\n        const children = node.getChildren();\r\n        this.append(...children);\r\n        node.remove();\r\n      } else {\r\n        super.append(node);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n  replace(replaceWithNode, includeChildren) {\r\n    if ($isListItemNode(replaceWithNode)) {\r\n      return super.replace(replaceWithNode);\r\n    }\r\n    this.setIndent(0);\r\n    const list = this.getParentOrThrow();\r\n    if (!$isListNode(list)) return replaceWithNode;\r\n    if (list.__first === this.getKey()) {\r\n      list.insertBefore(replaceWithNode);\r\n    } else if (list.__last === this.getKey()) {\r\n      list.insertAfter(replaceWithNode);\r\n    } else {\r\n      // Split the list\r\n      const newList = $createListNode(list.getListType());\r\n      let nextSibling = this.getNextSibling();\r\n      while (nextSibling) {\r\n        const nodeToAppend = nextSibling;\r\n        nextSibling = nextSibling.getNextSibling();\r\n        newList.append(nodeToAppend);\r\n      }\r\n      list.insertAfter(replaceWithNode);\r\n      replaceWithNode.insertAfter(newList);\r\n    }\r\n    if (includeChildren) {\r\n      if (!lexical.$isElementNode(replaceWithNode)) {\r\n        throw Error(`includeChildren should only be true for ElementNodes`);\r\n      }\r\n      this.getChildren().forEach(child => {\r\n        replaceWithNode.append(child);\r\n      });\r\n    }\r\n    this.remove();\r\n    if (list.getChildrenSize() === 0) {\r\n      list.remove();\r\n    }\r\n    return replaceWithNode;\r\n  }\r\n  insertAfter(node, restoreSelection = true) {\r\n    const listNode = this.getParentOrThrow();\r\n    if (!$isListNode(listNode)) {\r\n      {\r\n        throw Error(`insertAfter: list node is not parent of list item node`);\r\n      }\r\n    }\r\n    const siblings = this.getNextSiblings();\r\n    if ($isListItemNode(node)) {\r\n      const after = super.insertAfter(node, restoreSelection);\r\n      const afterListNode = node.getParentOrThrow();\r\n      if ($isListNode(afterListNode)) {\r\n        updateChildrenListItemValue(afterListNode);\r\n      }\r\n      return after;\r\n    }\r\n\r\n    // Attempt to merge if the list is of the same type.\r\n\r\n    if ($isListNode(node)) {\r\n      let child = node;\r\n      const children = node.getChildren();\r\n      for (let i = children.length - 1; i >= 0; i--) {\r\n        child = children[i];\r\n        this.insertAfter(child, restoreSelection);\r\n      }\r\n      return child;\r\n    }\r\n\r\n    // Otherwise, split the list\r\n    // Split the lists and insert the node in between them\r\n    listNode.insertAfter(node, restoreSelection);\r\n    if (siblings.length !== 0) {\r\n      const newListNode = $createListNode(listNode.getListType());\r\n      siblings.forEach(sibling => newListNode.append(sibling));\r\n      node.insertAfter(newListNode, restoreSelection);\r\n    }\r\n    return node;\r\n  }\r\n  remove(preserveEmptyParent) {\r\n    const prevSibling = this.getPreviousSibling();\r\n    const nextSibling = this.getNextSibling();\r\n    super.remove(preserveEmptyParent);\r\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\r\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\r\n      nextSibling.remove();\r\n    } else if (nextSibling) {\r\n      const parent = nextSibling.getParent();\r\n      if ($isListNode(parent)) {\r\n        updateChildrenListItemValue(parent);\r\n      }\r\n    }\r\n  }\r\n  insertNewAfter(_, restoreSelection = true) {\r\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\r\n    this.insertAfter(newElement, restoreSelection);\r\n    return newElement;\r\n  }\r\n  collapseAtStart(selection) {\r\n    const paragraph = lexical.$createParagraphNode();\r\n    const children = this.getChildren();\r\n    children.forEach(child => paragraph.append(child));\r\n    const listNode = this.getParentOrThrow();\r\n    const listNodeParent = listNode.getParentOrThrow();\r\n    const isIndented = $isListItemNode(listNodeParent);\r\n    if (listNode.getChildrenSize() === 1) {\r\n      if (isIndented) {\r\n        // if the list node is nested, we just want to remove it,\r\n        // effectively unindenting it.\r\n        listNode.remove();\r\n        listNodeParent.select();\r\n      } else {\r\n        listNode.insertBefore(paragraph);\r\n        listNode.remove();\r\n        // If we have selection on the list item, we'll need to move it\r\n        // to the paragraph\r\n        const anchor = selection.anchor;\r\n        const focus = selection.focus;\r\n        const key = paragraph.getKey();\r\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\r\n          anchor.set(key, anchor.offset, 'element');\r\n        }\r\n        if (focus.type === 'element' && focus.getNode().is(this)) {\r\n          focus.set(key, focus.offset, 'element');\r\n        }\r\n      }\r\n    } else {\r\n      listNode.insertBefore(paragraph);\r\n      this.remove();\r\n    }\r\n    return true;\r\n  }\r\n  getValue() {\r\n    const self = this.getLatest();\r\n    return self.__value;\r\n  }\r\n  setValue(value) {\r\n    const self = this.getWritable();\r\n    self.__value = value;\r\n  }\r\n  getChecked() {\r\n    const self = this.getLatest();\r\n    return self.__checked;\r\n  }\r\n  setChecked(checked) {\r\n    const self = this.getWritable();\r\n    self.__checked = checked;\r\n  }\r\n  toggleChecked() {\r\n    this.setChecked(!this.__checked);\r\n  }\r\n  getIndent() {\r\n    // If we don't have a parent, we are likely serializing\r\n    const parent = this.getParent();\r\n    if (parent === null) {\r\n      return this.getLatest().__indent;\r\n    }\r\n    // ListItemNode should always have a ListNode for a parent.\r\n    let listNodeParent = parent.getParentOrThrow();\r\n    let indentLevel = 0;\r\n    while ($isListItemNode(listNodeParent)) {\r\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\r\n      indentLevel++;\r\n    }\r\n    return indentLevel;\r\n  }\r\n  setIndent(indent) {\r\n    if (!(typeof indent === 'number' && indent > -1)) {\r\n      throw Error(`Invalid indent value.`);\r\n    }\r\n    let currentIndent = this.getIndent();\r\n    while (currentIndent !== indent) {\r\n      if (currentIndent < indent) {\r\n        $handleIndent(this);\r\n        currentIndent++;\r\n      } else {\r\n        $handleOutdent(this);\r\n        currentIndent--;\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n  insertBefore(nodeToInsert) {\r\n    if ($isListItemNode(nodeToInsert)) {\r\n      const parent = this.getParentOrThrow();\r\n      if ($isListNode(parent)) {\r\n        const siblings = this.getNextSiblings();\r\n        updateChildrenListItemValue(parent, siblings);\r\n      }\r\n    }\r\n    return super.insertBefore(nodeToInsert);\r\n  }\r\n  canInsertAfter(node) {\r\n    return $isListItemNode(node);\r\n  }\r\n  canReplaceWith(replacement) {\r\n    return $isListItemNode(replacement);\r\n  }\r\n  canMergeWith(node) {\r\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\r\n  }\r\n  extractWithChild(child, selection) {\r\n    if (!lexical.$isRangeSelection(selection)) {\r\n      return false;\r\n    }\r\n    const anchorNode = selection.anchor.getNode();\r\n    const focusNode = selection.focus.getNode();\r\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\r\n  }\r\n  isParentRequired() {\r\n    return true;\r\n  }\r\n  createParentElementNode() {\r\n    return $createListNode('bullet');\r\n  }\r\n}\r\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\r\n  const classesToAdd = [];\r\n  const classesToRemove = [];\r\n  const listTheme = editorThemeClasses.list;\r\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\r\n  let nestedListItemClassName;\r\n  if (listTheme && listTheme.nested) {\r\n    nestedListItemClassName = listTheme.nested.listitem;\r\n  }\r\n  if (listItemClassName !== undefined) {\r\n    const listItemClasses = listItemClassName.split(' ');\r\n    classesToAdd.push(...listItemClasses);\r\n  }\r\n  if (listTheme) {\r\n    const parentNode = node.getParent();\r\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\r\n    const checked = node.getChecked();\r\n    if (!isCheckList || checked) {\r\n      classesToRemove.push(listTheme.listitemUnchecked);\r\n    }\r\n    if (!isCheckList || !checked) {\r\n      classesToRemove.push(listTheme.listitemChecked);\r\n    }\r\n    if (isCheckList) {\r\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\r\n    }\r\n  }\r\n  if (nestedListItemClassName !== undefined) {\r\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\r\n    if (node.getChildren().some(child => $isListNode(child))) {\r\n      classesToAdd.push(...nestedListItemClasses);\r\n    } else {\r\n      classesToRemove.push(...nestedListItemClasses);\r\n    }\r\n  }\r\n  if (classesToRemove.length > 0) {\r\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\r\n  }\r\n  if (classesToAdd.length > 0) {\r\n    utils.addClassNamesToElement(dom, ...classesToAdd);\r\n  }\r\n}\r\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\r\n  // Only add attributes for leaf list items\r\n  if ($isListNode(listItemNode.getFirstChild())) {\r\n    dom.removeAttribute('role');\r\n    dom.removeAttribute('tabIndex');\r\n    dom.removeAttribute('aria-checked');\r\n  } else {\r\n    dom.setAttribute('role', 'checkbox');\r\n    dom.setAttribute('tabIndex', '-1');\r\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\r\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\r\n    }\r\n  }\r\n}\r\nfunction convertListItemElement(domNode) {\r\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\r\n  return {\r\n    node: $createListItemNode(checked)\r\n  };\r\n}\r\n\r\n/**\r\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\r\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\r\n * @returns The new List Item.\r\n */\r\nfunction $createListItemNode(checked) {\r\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\r\n}\r\n\r\n/**\r\n * Checks to see if the node is a ListItemNode.\r\n * @param node - The node to be checked.\r\n * @returns true if the node is a ListItemNode, false otherwise.\r\n */\r\nfunction $isListItemNode(node) {\r\n  return node instanceof ListItemNode;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass ListNode extends lexical.ElementNode {\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  static getType() {\r\n    return 'list';\r\n  }\r\n  static clone(node) {\r\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\r\n    return new ListNode(listType, node.__start, node.__key);\r\n  }\r\n  constructor(listType, start, key) {\r\n    super(key);\r\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\r\n    this.__listType = _listType;\r\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\r\n    this.__start = start;\r\n  }\r\n  getTag() {\r\n    return this.__tag;\r\n  }\r\n  setListType(type) {\r\n    const writable = this.getWritable();\r\n    writable.__listType = type;\r\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\r\n  }\r\n  getListType() {\r\n    return this.__listType;\r\n  }\r\n  getStart() {\r\n    return this.__start;\r\n  }\r\n\r\n  // View\r\n\r\n  createDOM(config, _editor) {\r\n    const tag = this.__tag;\r\n    const dom = document.createElement(tag);\r\n    if (this.__start !== 1) {\r\n      dom.setAttribute('start', String(this.__start));\r\n    }\r\n    // @ts-expect-error Internal field.\r\n    dom.__lexicalListType = this.__listType;\r\n    setListThemeClassNames(dom, config.theme, this);\r\n    return dom;\r\n  }\r\n  updateDOM(prevNode, dom, config) {\r\n    if (prevNode.__tag !== this.__tag) {\r\n      return true;\r\n    }\r\n    setListThemeClassNames(dom, config.theme, this);\r\n    return false;\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      ol: node => ({\r\n        conversion: convertListNode,\r\n        priority: 0\r\n      }),\r\n      ul: node => ({\r\n        conversion: convertListNode,\r\n        priority: 0\r\n      })\r\n    };\r\n  }\r\n  static importJSON(serializedNode) {\r\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\r\n    node.setFormat(serializedNode.format);\r\n    node.setIndent(serializedNode.indent);\r\n    node.setDirection(serializedNode.direction);\r\n    return node;\r\n  }\r\n  exportDOM(editor) {\r\n    const {\r\n      element\r\n    } = super.exportDOM(editor);\r\n    if (element && utils.isHTMLElement(element)) {\r\n      if (this.__start !== 1) {\r\n        element.setAttribute('start', String(this.__start));\r\n      }\r\n      if (this.__listType === 'check') {\r\n        element.setAttribute('__lexicalListType', 'check');\r\n      }\r\n    }\r\n    return {\r\n      element\r\n    };\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      listType: this.getListType(),\r\n      start: this.getStart(),\r\n      tag: this.getTag(),\r\n      type: 'list',\r\n      version: 1\r\n    };\r\n  }\r\n  canBeEmpty() {\r\n    return false;\r\n  }\r\n  canIndent() {\r\n    return false;\r\n  }\r\n  append(...nodesToAppend) {\r\n    for (let i = 0; i < nodesToAppend.length; i++) {\r\n      const currentNode = nodesToAppend[i];\r\n      if ($isListItemNode(currentNode)) {\r\n        super.append(currentNode);\r\n      } else {\r\n        const listItemNode = $createListItemNode();\r\n        if ($isListNode(currentNode)) {\r\n          listItemNode.append(currentNode);\r\n        } else if (lexical.$isElementNode(currentNode)) {\r\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\r\n          listItemNode.append(textNode);\r\n        } else {\r\n          listItemNode.append(currentNode);\r\n        }\r\n        super.append(listItemNode);\r\n      }\r\n    }\r\n    updateChildrenListItemValue(this);\r\n    return this;\r\n  }\r\n  extractWithChild(child) {\r\n    return $isListItemNode(child);\r\n  }\r\n}\r\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\r\n  const classesToAdd = [];\r\n  const classesToRemove = [];\r\n  const listTheme = editorThemeClasses.list;\r\n  if (listTheme !== undefined) {\r\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\r\n    const listDepth = $getListDepth(node) - 1;\r\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\r\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\r\n    const listClassName = listTheme[node.__tag];\r\n    let nestedListClassName;\r\n    const nestedListTheme = listTheme.nested;\r\n    const checklistClassName = listTheme.checklist;\r\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\r\n      nestedListClassName = nestedListTheme.list;\r\n    }\r\n    if (listClassName !== undefined) {\r\n      classesToAdd.push(listClassName);\r\n    }\r\n    if (checklistClassName !== undefined && node.__listType === 'check') {\r\n      classesToAdd.push(checklistClassName);\r\n    }\r\n    if (listLevelClassName !== undefined) {\r\n      const listItemClasses = listLevelClassName.split(' ');\r\n      classesToAdd.push(...listItemClasses);\r\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\r\n        if (i !== normalizedListDepth) {\r\n          classesToRemove.push(node.__tag + i);\r\n        }\r\n      }\r\n    }\r\n    if (nestedListClassName !== undefined) {\r\n      const nestedListItemClasses = nestedListClassName.split(' ');\r\n      if (listDepth > 1) {\r\n        classesToAdd.push(...nestedListItemClasses);\r\n      } else {\r\n        classesToRemove.push(...nestedListItemClasses);\r\n      }\r\n    }\r\n  }\r\n  if (classesToRemove.length > 0) {\r\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\r\n  }\r\n  if (classesToAdd.length > 0) {\r\n    utils.addClassNamesToElement(dom, ...classesToAdd);\r\n  }\r\n}\r\n\r\n/*\r\n * This function normalizes the children of a ListNode after the conversion from HTML,\r\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\r\n * or some other inline content.\r\n */\r\nfunction normalizeChildren(nodes) {\r\n  const normalizedListItems = [];\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n    if ($isListItemNode(node)) {\r\n      normalizedListItems.push(node);\r\n      const children = node.getChildren();\r\n      if (children.length > 1) {\r\n        children.forEach(child => {\r\n          if ($isListNode(child)) {\r\n            normalizedListItems.push(wrapInListItem(child));\r\n          }\r\n        });\r\n      }\r\n    } else {\r\n      normalizedListItems.push(wrapInListItem(node));\r\n    }\r\n  }\r\n  return normalizedListItems;\r\n}\r\nfunction convertListNode(domNode) {\r\n  const nodeName = domNode.nodeName.toLowerCase();\r\n  let node = null;\r\n  if (nodeName === 'ol') {\r\n    // @ts-ignore\r\n    const start = domNode.start;\r\n    node = $createListNode('number', start);\r\n  } else if (nodeName === 'ul') {\r\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\r\n      node = $createListNode('check');\r\n    } else {\r\n      node = $createListNode('bullet');\r\n    }\r\n  }\r\n  return {\r\n    after: normalizeChildren,\r\n    node\r\n  };\r\n}\r\nconst TAG_TO_LIST_TYPE = {\r\n  ol: 'number',\r\n  ul: 'bullet'\r\n};\r\n\r\n/**\r\n * Creates a ListNode of listType.\r\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\r\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\r\n * @returns The new ListNode\r\n */\r\nfunction $createListNode(listType, start = 1) {\r\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\r\n}\r\n\r\n/**\r\n * Checks to see if the node is a ListNode.\r\n * @param node - The node to be checked.\r\n * @returns true if the node is a ListNode, false otherwise.\r\n */\r\nfunction $isListNode(node) {\r\n  return node instanceof ListNode;\r\n}\r\n\r\n/** @module @lexical/list */\r\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\r\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\r\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\r\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\r\n\r\nexports.$createListItemNode = $createListItemNode;\r\nexports.$createListNode = $createListNode;\r\nexports.$getListDepth = $getListDepth;\r\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\r\nexports.$isListItemNode = $isListItemNode;\r\nexports.$isListNode = $isListNode;\r\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\r\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\r\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\r\nexports.ListItemNode = ListItemNode;\r\nexports.ListNode = ListNode;\r\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\r\nexports.insertList = insertList;\r\nexports.removeList = removeList;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst LexicalList = process.env.NODE_ENV === 'development' ? require('./LexicalList.dev.js') : require('./LexicalList.prod.js')\r\nmodule.exports = LexicalList;"],
  "mappings": "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",
  "names": []
}
