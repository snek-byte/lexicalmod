{
  "version": 3,
  "sources": ["../../lexical/Lexical.dev.js", "../../lexical/Lexical.js"],
  "sourcesContent": ["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict';\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nfunction createCommand(type) {\r\n  return {\r\n    type\r\n  } ;\r\n}\r\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\r\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\r\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\r\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\r\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\r\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\r\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\r\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\r\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\r\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\r\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\r\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\r\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\r\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\r\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\r\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\r\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\r\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\r\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\r\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\r\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\r\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\r\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\r\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\r\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\r\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\r\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\r\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\r\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\r\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\r\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\r\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\r\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\r\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\r\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\r\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\r\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\r\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\r\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\r\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\r\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\r\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\r\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\r\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\r\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\r\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\r\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\r\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\r\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\r\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\r\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\r\n\r\n// Keep these in case we need to use them in the future.\r\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\r\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\r\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\r\n\r\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n// DOM\r\nconst DOM_ELEMENT_TYPE = 1;\r\nconst DOM_TEXT_TYPE = 3;\r\n\r\n// Reconciling\r\nconst NO_DIRTY_NODES = 0;\r\nconst HAS_DIRTY_NODES = 1;\r\nconst FULL_RECONCILE = 2;\r\n\r\n// Text node modes\r\nconst IS_NORMAL = 0;\r\nconst IS_TOKEN = 1;\r\nconst IS_SEGMENTED = 2;\r\n// IS_INERT = 3\r\n\r\n// Text node formatting\r\nconst IS_BOLD = 1;\r\nconst IS_ITALIC = 1 << 1;\r\nconst IS_STRIKETHROUGH = 1 << 2;\r\nconst IS_UNDERLINE = 1 << 3;\r\nconst IS_CODE = 1 << 4;\r\nconst IS_SUBSCRIPT = 1 << 5;\r\nconst IS_SUPERSCRIPT = 1 << 6;\r\nconst IS_HIGHLIGHT = 1 << 7;\r\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;\r\n\r\n// Text node details\r\nconst IS_DIRECTIONLESS = 1;\r\nconst IS_UNMERGEABLE = 1 << 1;\r\n\r\n// Element node formatting\r\nconst IS_ALIGN_LEFT = 1;\r\nconst IS_ALIGN_CENTER = 2;\r\nconst IS_ALIGN_RIGHT = 3;\r\nconst IS_ALIGN_JUSTIFY = 4;\r\nconst IS_ALIGN_START = 5;\r\nconst IS_ALIGN_END = 6;\r\n\r\n// Reconciliation\r\nconst NON_BREAKING_SPACE = '\\u00A0';\r\nconst ZERO_WIDTH_SPACE = '\\u200b';\r\n\r\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\r\n// overlapping the composed text.\r\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\r\nconst DOUBLE_LINE_BREAK = '\\n\\n';\r\n\r\n// For FF, we need to use a non-breaking space, or it gets composition\r\n// in a stuck state.\r\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\r\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\r\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\r\n\r\n// eslint-disable-next-line no-misleading-character-class\r\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\r\n// eslint-disable-next-line no-misleading-character-class\r\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\r\nconst TEXT_TYPE_TO_FORMAT = {\r\n  bold: IS_BOLD,\r\n  code: IS_CODE,\r\n  highlight: IS_HIGHLIGHT,\r\n  italic: IS_ITALIC,\r\n  strikethrough: IS_STRIKETHROUGH,\r\n  subscript: IS_SUBSCRIPT,\r\n  superscript: IS_SUPERSCRIPT,\r\n  underline: IS_UNDERLINE\r\n};\r\nconst DETAIL_TYPE_TO_DETAIL = {\r\n  directionless: IS_DIRECTIONLESS,\r\n  unmergeable: IS_UNMERGEABLE\r\n};\r\nconst ELEMENT_TYPE_TO_FORMAT = {\r\n  center: IS_ALIGN_CENTER,\r\n  end: IS_ALIGN_END,\r\n  justify: IS_ALIGN_JUSTIFY,\r\n  left: IS_ALIGN_LEFT,\r\n  right: IS_ALIGN_RIGHT,\r\n  start: IS_ALIGN_START\r\n};\r\nconst ELEMENT_FORMAT_TO_TYPE = {\r\n  [IS_ALIGN_CENTER]: 'center',\r\n  [IS_ALIGN_END]: 'end',\r\n  [IS_ALIGN_JUSTIFY]: 'justify',\r\n  [IS_ALIGN_LEFT]: 'left',\r\n  [IS_ALIGN_RIGHT]: 'right',\r\n  [IS_ALIGN_START]: 'start'\r\n};\r\nconst TEXT_MODE_TO_TYPE = {\r\n  normal: IS_NORMAL,\r\n  segmented: IS_SEGMENTED,\r\n  token: IS_TOKEN\r\n};\r\nconst TEXT_TYPE_TO_MODE = {\r\n  [IS_NORMAL]: 'normal',\r\n  [IS_SEGMENTED]: 'segmented',\r\n  [IS_TOKEN]: 'token'\r\n};\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n// The time between a text entry event and the mutation observer firing.\r\nconst TEXT_MUTATION_VARIANCE = 100;\r\nlet isProcessingMutations = false;\r\nlet lastTextEntryTimeStamp = 0;\r\nfunction getIsProcessingMutations() {\r\n  return isProcessingMutations;\r\n}\r\nfunction updateTimeStamp(event) {\r\n  lastTextEntryTimeStamp = event.timeStamp;\r\n}\r\nfunction initTextEntryListener(editor) {\r\n  if (lastTextEntryTimeStamp === 0) {\r\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\r\n  }\r\n}\r\nfunction isManagedLineBreak(dom, target, editor) {\r\n  return (\r\n    // @ts-expect-error: internal field\r\n    target.__lexicalLineBreak === dom ||\r\n    // @ts-ignore We intentionally add this to the Node.\r\n    dom[`__lexicalKey_${editor._key}`] !== undefined\r\n  );\r\n}\r\nfunction getLastSelection(editor) {\r\n  return editor.getEditorState().read(() => {\r\n    const selection = $getSelection();\r\n    return selection !== null ? selection.clone() : null;\r\n  });\r\n}\r\nfunction handleTextMutation(target, node, editor) {\r\n  const domSelection = getDOMSelection(editor._window);\r\n  let anchorOffset = null;\r\n  let focusOffset = null;\r\n  if (domSelection !== null && domSelection.anchorNode === target) {\r\n    anchorOffset = domSelection.anchorOffset;\r\n    focusOffset = domSelection.focusOffset;\r\n  }\r\n  const text = target.nodeValue;\r\n  if (text !== null) {\r\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\r\n  }\r\n}\r\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\r\n  if ($isRangeSelection(selection)) {\r\n    const anchorNode = selection.anchor.getNode();\r\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\r\n      return false;\r\n    }\r\n  }\r\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\r\n}\r\nfunction $flushMutations$1(editor, mutations, observer) {\r\n  isProcessingMutations = true;\r\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\r\n  try {\r\n    updateEditor(editor, () => {\r\n      const selection = $getSelection() || getLastSelection(editor);\r\n      const badDOMTargets = new Map();\r\n      const rootElement = editor.getRootElement();\r\n      // We use the current editor state, as that reflects what is\r\n      // actually \"on screen\".\r\n      const currentEditorState = editor._editorState;\r\n      const blockCursorElement = editor._blockCursorElement;\r\n      let shouldRevertSelection = false;\r\n      let possibleTextForFirefoxPaste = '';\r\n      for (let i = 0; i < mutations.length; i++) {\r\n        const mutation = mutations[i];\r\n        const type = mutation.type;\r\n        const targetDOM = mutation.target;\r\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\r\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\r\n          continue;\r\n        }\r\n        if (type === 'characterData') {\r\n          // Text mutations are deferred and passed to mutation listeners to be\r\n          // processed outside of the Lexical engine.\r\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\r\n            handleTextMutation(\r\n            // nodeType === DOM_TEXT_TYPE is a Text DOM node\r\n            targetDOM, targetNode, editor);\r\n          }\r\n        } else if (type === 'childList') {\r\n          shouldRevertSelection = true;\r\n          // We attempt to \"undo\" any changes that have occurred outside\r\n          // of Lexical. We want Lexical's editor state to be source of truth.\r\n          // To the user, these will look like no-ops.\r\n          const addedDOMs = mutation.addedNodes;\r\n          for (let s = 0; s < addedDOMs.length; s++) {\r\n            const addedDOM = addedDOMs[s];\r\n            const node = getNodeFromDOMNode(addedDOM);\r\n            const parentDOM = addedDOM.parentNode;\r\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\r\n              if (IS_FIREFOX) {\r\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\r\n                if (possibleText) {\r\n                  possibleTextForFirefoxPaste += possibleText;\r\n                }\r\n              }\r\n              parentDOM.removeChild(addedDOM);\r\n            }\r\n          }\r\n          const removedDOMs = mutation.removedNodes;\r\n          const removedDOMsLength = removedDOMs.length;\r\n          if (removedDOMsLength > 0) {\r\n            let unremovedBRs = 0;\r\n            for (let s = 0; s < removedDOMsLength; s++) {\r\n              const removedDOM = removedDOMs[s];\r\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\r\n                targetDOM.appendChild(removedDOM);\r\n                unremovedBRs++;\r\n              }\r\n            }\r\n            if (removedDOMsLength !== unremovedBRs) {\r\n              if (targetDOM === rootElement) {\r\n                targetNode = internalGetRoot(currentEditorState);\r\n              }\r\n              badDOMTargets.set(targetDOM, targetNode);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Now we process each of the unique target nodes, attempting\r\n      // to restore their contents back to the source of truth, which\r\n      // is Lexical's \"current\" editor state. This is basically like\r\n      // an internal revert on the DOM.\r\n      if (badDOMTargets.size > 0) {\r\n        for (const [targetDOM, targetNode] of badDOMTargets) {\r\n          if ($isElementNode(targetNode)) {\r\n            const childKeys = targetNode.getChildrenKeys();\r\n            let currentDOM = targetDOM.firstChild;\r\n            for (let s = 0; s < childKeys.length; s++) {\r\n              const key = childKeys[s];\r\n              const correctDOM = editor.getElementByKey(key);\r\n              if (correctDOM === null) {\r\n                continue;\r\n              }\r\n              if (currentDOM == null) {\r\n                targetDOM.appendChild(correctDOM);\r\n                currentDOM = correctDOM;\r\n              } else if (currentDOM !== correctDOM) {\r\n                targetDOM.replaceChild(correctDOM, currentDOM);\r\n              }\r\n              currentDOM = currentDOM.nextSibling;\r\n            }\r\n          } else if ($isTextNode(targetNode)) {\r\n            targetNode.markDirty();\r\n          }\r\n        }\r\n      }\r\n\r\n      // Capture all the mutations made during this function. This\r\n      // also prevents us having to process them on the next cycle\r\n      // of onMutation, as these mutations were made by us.\r\n      const records = observer.takeRecords();\r\n\r\n      // Check for any random auto-added <br> elements, and remove them.\r\n      // These get added by the browser when we undo the above mutations\r\n      // and this can lead to a broken UI.\r\n      if (records.length > 0) {\r\n        for (let i = 0; i < records.length; i++) {\r\n          const record = records[i];\r\n          const addedNodes = record.addedNodes;\r\n          const target = record.target;\r\n          for (let s = 0; s < addedNodes.length; s++) {\r\n            const addedDOM = addedNodes[s];\r\n            const parentDOM = addedDOM.parentNode;\r\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\r\n              parentDOM.removeChild(addedDOM);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Clear any of those removal mutations\r\n        observer.takeRecords();\r\n      }\r\n      if (selection !== null) {\r\n        if (shouldRevertSelection) {\r\n          selection.dirty = true;\r\n          $setSelection(selection);\r\n        }\r\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\r\n          selection.insertRawText(possibleTextForFirefoxPaste);\r\n        }\r\n      }\r\n    });\r\n  } finally {\r\n    isProcessingMutations = false;\r\n  }\r\n}\r\nfunction flushRootMutations(editor) {\r\n  const observer = editor._observer;\r\n  if (observer !== null) {\r\n    const mutations = observer.takeRecords();\r\n    $flushMutations$1(editor, mutations, observer);\r\n  }\r\n}\r\nfunction initMutationObserver(editor) {\r\n  initTextEntryListener(editor);\r\n  editor._observer = new MutationObserver((mutations, observer) => {\r\n    $flushMutations$1(editor, mutations, observer);\r\n  });\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\r\n  const node1Mode = node1.__mode;\r\n  const node1Format = node1.__format;\r\n  const node1Style = node1.__style;\r\n  const node2Mode = node2.__mode;\r\n  const node2Format = node2.__format;\r\n  const node2Style = node2.__style;\r\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\r\n}\r\nfunction $mergeTextNodes(node1, node2) {\r\n  const writableNode1 = node1.mergeWithSibling(node2);\r\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\r\n  normalizedNodes.add(node1.__key);\r\n  normalizedNodes.add(node2.__key);\r\n  return writableNode1;\r\n}\r\nfunction $normalizeTextNode(textNode) {\r\n  let node = textNode;\r\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\r\n    node.remove();\r\n    return;\r\n  }\r\n\r\n  // Backward\r\n  let previousNode;\r\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\r\n    if (previousNode.__text === '') {\r\n      previousNode.remove();\r\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\r\n      node = $mergeTextNodes(previousNode, node);\r\n      break;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Forward\r\n  let nextNode;\r\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\r\n    if (nextNode.__text === '') {\r\n      nextNode.remove();\r\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\r\n      node = $mergeTextNodes(node, nextNode);\r\n      break;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n}\r\nfunction $normalizeSelection(selection) {\r\n  $normalizePoint(selection.anchor);\r\n  $normalizePoint(selection.focus);\r\n  return selection;\r\n}\r\nfunction $normalizePoint(point) {\r\n  while (point.type === 'element') {\r\n    const node = point.getNode();\r\n    const offset = point.offset;\r\n    let nextNode;\r\n    let nextOffsetAtEnd;\r\n    if (offset === node.getChildrenSize()) {\r\n      nextNode = node.getChildAtIndex(offset - 1);\r\n      nextOffsetAtEnd = true;\r\n    } else {\r\n      nextNode = node.getChildAtIndex(offset);\r\n      nextOffsetAtEnd = false;\r\n    }\r\n    if ($isTextNode(nextNode)) {\r\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\r\n      break;\r\n    } else if (!$isElementNode(nextNode)) {\r\n      break;\r\n    }\r\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\r\n  }\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nlet keyCounter = 1;\r\nfunction generateRandomKey() {\r\n  return '' + keyCounter++;\r\n}\r\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\r\n  const registeredNode = editor._nodes.get(nodeType);\r\n  if (registeredNode === undefined) {\r\n    {\r\n      throw Error(`registeredNode: Type ${nodeType} not found`);\r\n    }\r\n  }\r\n  return registeredNode;\r\n}\r\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\r\n  // No window prefix intended (#1400)\r\n  Promise.resolve().then(fn);\r\n};\r\nfunction $isSelectionCapturedInDecorator(node) {\r\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\r\n}\r\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\r\n  const activeElement = document.activeElement;\r\n  if (activeElement === null) {\r\n    return false;\r\n  }\r\n  const nodeName = activeElement.nodeName;\r\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' &&\r\n  // @ts-ignore iternal field\r\n  activeElement.__lexicalEditor == null);\r\n}\r\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\r\n  const rootElement = editor.getRootElement();\r\n  try {\r\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\r\n    // Ignore if selection is within nested editor\r\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n}\r\nfunction getNearestEditorFromDOMNode(node) {\r\n  let currentNode = node;\r\n  while (currentNode != null) {\r\n    // @ts-expect-error: internal field\r\n    const editor = currentNode.__lexicalEditor;\r\n    if (editor != null) {\r\n      return editor;\r\n    }\r\n    currentNode = getParentElement(currentNode);\r\n  }\r\n  return null;\r\n}\r\nfunction getTextDirection(text) {\r\n  if (RTL_REGEX.test(text)) {\r\n    return 'rtl';\r\n  }\r\n  if (LTR_REGEX.test(text)) {\r\n    return 'ltr';\r\n  }\r\n  return null;\r\n}\r\nfunction $isTokenOrSegmented(node) {\r\n  return node.isToken() || node.isSegmented();\r\n}\r\nfunction isDOMNodeLexicalTextNode(node) {\r\n  return node.nodeType === DOM_TEXT_TYPE;\r\n}\r\nfunction getDOMTextNode(element) {\r\n  let node = element;\r\n  while (node != null) {\r\n    if (isDOMNodeLexicalTextNode(node)) {\r\n      return node;\r\n    }\r\n    node = node.firstChild;\r\n  }\r\n  return null;\r\n}\r\nfunction toggleTextFormatType(format, type, alignWithFormat) {\r\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\r\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\r\n    return format;\r\n  }\r\n  let newFormat = format ^ activeFormat;\r\n  if (type === 'subscript') {\r\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\r\n  } else if (type === 'superscript') {\r\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\r\n  }\r\n  return newFormat;\r\n}\r\nfunction $isLeafNode(node) {\r\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\r\n}\r\nfunction $setNodeKey(node, existingKey) {\r\n  if (existingKey != null) {\r\n    node.__key = existingKey;\r\n    return;\r\n  }\r\n  errorOnReadOnly();\r\n  errorOnInfiniteTransforms();\r\n  const editor = getActiveEditor();\r\n  const editorState = getActiveEditorState();\r\n  const key = generateRandomKey();\r\n  editorState._nodeMap.set(key, node);\r\n  // TODO Split this function into leaf/element\r\n  if ($isElementNode(node)) {\r\n    editor._dirtyElements.set(key, true);\r\n  } else {\r\n    editor._dirtyLeaves.add(key);\r\n  }\r\n  editor._cloneNotNeeded.add(key);\r\n  editor._dirtyType = HAS_DIRTY_NODES;\r\n  node.__key = key;\r\n}\r\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\r\n  let nextParentKey = parentKey;\r\n  while (nextParentKey !== null) {\r\n    if (dirtyElements.has(nextParentKey)) {\r\n      return;\r\n    }\r\n    const node = nodeMap.get(nextParentKey);\r\n    if (node === undefined) {\r\n      break;\r\n    }\r\n    dirtyElements.set(nextParentKey, false);\r\n    nextParentKey = node.__parent;\r\n  }\r\n}\r\nfunction removeFromParent(node) {\r\n  const oldParent = node.getParent();\r\n  if (oldParent !== null) {\r\n    const writableNode = node.getWritable();\r\n    const writableParent = oldParent.getWritable();\r\n    const prevSibling = node.getPreviousSibling();\r\n    const nextSibling = node.getNextSibling();\r\n    // TODO: this function duplicates a bunch of operations, can be simplified.\r\n    if (prevSibling === null) {\r\n      if (nextSibling !== null) {\r\n        const writableNextSibling = nextSibling.getWritable();\r\n        writableParent.__first = nextSibling.__key;\r\n        writableNextSibling.__prev = null;\r\n      } else {\r\n        writableParent.__first = null;\r\n      }\r\n    } else {\r\n      const writablePrevSibling = prevSibling.getWritable();\r\n      if (nextSibling !== null) {\r\n        const writableNextSibling = nextSibling.getWritable();\r\n        writableNextSibling.__prev = writablePrevSibling.__key;\r\n        writablePrevSibling.__next = writableNextSibling.__key;\r\n      } else {\r\n        writablePrevSibling.__next = null;\r\n      }\r\n      writableNode.__prev = null;\r\n    }\r\n    if (nextSibling === null) {\r\n      if (prevSibling !== null) {\r\n        const writablePrevSibling = prevSibling.getWritable();\r\n        writableParent.__last = prevSibling.__key;\r\n        writablePrevSibling.__next = null;\r\n      } else {\r\n        writableParent.__last = null;\r\n      }\r\n    } else {\r\n      const writableNextSibling = nextSibling.getWritable();\r\n      if (prevSibling !== null) {\r\n        const writablePrevSibling = prevSibling.getWritable();\r\n        writablePrevSibling.__next = writableNextSibling.__key;\r\n        writableNextSibling.__prev = writablePrevSibling.__key;\r\n      } else {\r\n        writableNextSibling.__prev = null;\r\n      }\r\n      writableNode.__next = null;\r\n    }\r\n    writableParent.__size--;\r\n    writableNode.__parent = null;\r\n  }\r\n}\r\n\r\n// Never use this function directly! It will break\r\n// the cloning heuristic. Instead use node.getWritable().\r\nfunction internalMarkNodeAsDirty(node) {\r\n  errorOnInfiniteTransforms();\r\n  const latest = node.getLatest();\r\n  const parent = latest.__parent;\r\n  const editorState = getActiveEditorState();\r\n  const editor = getActiveEditor();\r\n  const nodeMap = editorState._nodeMap;\r\n  const dirtyElements = editor._dirtyElements;\r\n  if (parent !== null) {\r\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\r\n  }\r\n  const key = latest.__key;\r\n  editor._dirtyType = HAS_DIRTY_NODES;\r\n  if ($isElementNode(node)) {\r\n    dirtyElements.set(key, true);\r\n  } else {\r\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\r\n    editor._dirtyLeaves.add(key);\r\n  }\r\n}\r\nfunction internalMarkSiblingsAsDirty(node) {\r\n  const previousNode = node.getPreviousSibling();\r\n  const nextNode = node.getNextSibling();\r\n  if (previousNode !== null) {\r\n    internalMarkNodeAsDirty(previousNode);\r\n  }\r\n  if (nextNode !== null) {\r\n    internalMarkNodeAsDirty(nextNode);\r\n  }\r\n}\r\nfunction $setCompositionKey(compositionKey) {\r\n  errorOnReadOnly();\r\n  const editor = getActiveEditor();\r\n  const previousCompositionKey = editor._compositionKey;\r\n  if (compositionKey !== previousCompositionKey) {\r\n    editor._compositionKey = compositionKey;\r\n    if (previousCompositionKey !== null) {\r\n      const node = $getNodeByKey(previousCompositionKey);\r\n      if (node !== null) {\r\n        node.getWritable();\r\n      }\r\n    }\r\n    if (compositionKey !== null) {\r\n      const node = $getNodeByKey(compositionKey);\r\n      if (node !== null) {\r\n        node.getWritable();\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction $getCompositionKey() {\r\n  if (isCurrentlyReadOnlyMode()) {\r\n    return null;\r\n  }\r\n  const editor = getActiveEditor();\r\n  return editor._compositionKey;\r\n}\r\nfunction $getNodeByKey(key, _editorState) {\r\n  const editorState = _editorState || getActiveEditorState();\r\n  const node = editorState._nodeMap.get(key);\r\n  if (node === undefined) {\r\n    return null;\r\n  }\r\n  return node;\r\n}\r\nfunction getNodeFromDOMNode(dom, editorState) {\r\n  const editor = getActiveEditor();\r\n  // @ts-ignore We intentionally add this to the Node.\r\n  const key = dom[`__lexicalKey_${editor._key}`];\r\n  if (key !== undefined) {\r\n    return $getNodeByKey(key, editorState);\r\n  }\r\n  return null;\r\n}\r\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\r\n  let dom = startingDOM;\r\n  while (dom != null) {\r\n    const node = getNodeFromDOMNode(dom, editorState);\r\n    if (node !== null) {\r\n      return node;\r\n    }\r\n    dom = getParentElement(dom);\r\n  }\r\n  return null;\r\n}\r\nfunction cloneDecorators(editor) {\r\n  const currentDecorators = editor._decorators;\r\n  const pendingDecorators = Object.assign({}, currentDecorators);\r\n  editor._pendingDecorators = pendingDecorators;\r\n  return pendingDecorators;\r\n}\r\nfunction getEditorStateTextContent(editorState) {\r\n  return editorState.read(() => $getRoot().getTextContent());\r\n}\r\nfunction markAllNodesAsDirty(editor, type) {\r\n  // Mark all existing text nodes as dirty\r\n  updateEditor(editor, () => {\r\n    const editorState = getActiveEditorState();\r\n    if (editorState.isEmpty()) {\r\n      return;\r\n    }\r\n    if (type === 'root') {\r\n      $getRoot().markDirty();\r\n      return;\r\n    }\r\n    const nodeMap = editorState._nodeMap;\r\n    for (const [, node] of nodeMap) {\r\n      node.markDirty();\r\n    }\r\n  }, editor._pendingEditorState === null ? {\r\n    tag: 'history-merge'\r\n  } : undefined);\r\n}\r\nfunction $getRoot() {\r\n  return internalGetRoot(getActiveEditorState());\r\n}\r\nfunction internalGetRoot(editorState) {\r\n  return editorState._nodeMap.get('root');\r\n}\r\nfunction $setSelection(selection) {\r\n  errorOnReadOnly();\r\n  const editorState = getActiveEditorState();\r\n  if (selection !== null) {\r\n    {\r\n      if (Object.isFrozen(selection)) {\r\n        {\r\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\r\n        }\r\n      }\r\n    }\r\n    selection.dirty = true;\r\n    selection.setCachedNodes(null);\r\n  }\r\n  editorState._selection = selection;\r\n}\r\nfunction $flushMutations() {\r\n  errorOnReadOnly();\r\n  const editor = getActiveEditor();\r\n  flushRootMutations(editor);\r\n}\r\nfunction getNodeFromDOM(dom) {\r\n  const editor = getActiveEditor();\r\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\r\n  if (nodeKey === null) {\r\n    const rootElement = editor.getRootElement();\r\n    if (dom === rootElement) {\r\n      return $getNodeByKey('root');\r\n    }\r\n    return null;\r\n  }\r\n  return $getNodeByKey(nodeKey);\r\n}\r\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\r\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\r\n}\r\nfunction getNodeKeyFromDOM(\r\n// Note that node here refers to a DOM Node, not an Lexical Node\r\ndom, editor) {\r\n  let node = dom;\r\n  while (node != null) {\r\n    // @ts-ignore We intentionally add this to the Node.\r\n    const key = node[`__lexicalKey_${editor._key}`];\r\n    if (key !== undefined) {\r\n      return key;\r\n    }\r\n    node = getParentElement(node);\r\n  }\r\n  return null;\r\n}\r\nfunction doesContainGrapheme(str) {\r\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\r\n}\r\nfunction getEditorsToPropagate(editor) {\r\n  const editorsToPropagate = [];\r\n  let currentEditor = editor;\r\n  while (currentEditor !== null) {\r\n    editorsToPropagate.push(currentEditor);\r\n    currentEditor = currentEditor._parentEditor;\r\n  }\r\n  return editorsToPropagate;\r\n}\r\nfunction createUID() {\r\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\r\n}\r\nfunction getAnchorTextFromDOM(anchorNode) {\r\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\r\n    return anchorNode.nodeValue;\r\n  }\r\n  return null;\r\n}\r\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\r\n  // Update the text content with the latest composition text\r\n  const domSelection = getDOMSelection(editor._window);\r\n  if (domSelection === null) {\r\n    return;\r\n  }\r\n  const anchorNode = domSelection.anchorNode;\r\n  let {\r\n    anchorOffset,\r\n    focusOffset\r\n  } = domSelection;\r\n  if (anchorNode !== null) {\r\n    let textContent = getAnchorTextFromDOM(anchorNode);\r\n    const node = $getNearestNodeFromDOMNode(anchorNode);\r\n    if (textContent !== null && $isTextNode(node)) {\r\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\r\n      if (textContent === COMPOSITION_SUFFIX && data) {\r\n        const offset = data.length;\r\n        textContent = data;\r\n        anchorOffset = offset;\r\n        focusOffset = offset;\r\n      }\r\n      if (textContent !== null) {\r\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\r\n  let node = textNode;\r\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\r\n    const isComposing = node.isComposing();\r\n    let normalizedTextContent = textContent;\r\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\r\n      normalizedTextContent = textContent.slice(0, -1);\r\n    }\r\n    const prevTextContent = node.getTextContent();\r\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\r\n      if (normalizedTextContent === '') {\r\n        $setCompositionKey(null);\r\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\r\n          // For composition (mainly Android), we have to remove the node on a later update\r\n          const editor = getActiveEditor();\r\n          setTimeout(() => {\r\n            editor.update(() => {\r\n              if (node.isAttached()) {\r\n                node.remove();\r\n              }\r\n            });\r\n          }, 20);\r\n        } else {\r\n          node.remove();\r\n        }\r\n        return;\r\n      }\r\n      const parent = node.getParent();\r\n      const prevSelection = $getPreviousSelection();\r\n      const prevTextContentSize = node.getTextContentSize();\r\n      const compositionKey = $getCompositionKey();\r\n      const nodeKey = node.getKey();\r\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\r\n      // Check if character was added at the start or boundaries when not insertable, and we need\r\n      // to clear this input from occurring as that action wasn't permitted.\r\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\r\n        node.markDirty();\r\n        return;\r\n      }\r\n      const selection = $getSelection();\r\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\r\n        node.setTextContent(normalizedTextContent);\r\n        return;\r\n      }\r\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\r\n      if (node.isSegmented()) {\r\n        const originalTextContent = node.getTextContent();\r\n        const replacement = $createTextNode(originalTextContent);\r\n        node.replace(replacement);\r\n        node = replacement;\r\n      }\r\n      node.setTextContent(normalizedTextContent);\r\n    }\r\n  }\r\n}\r\nfunction $previousSiblingDoesNotAcceptText(node) {\r\n  const previousSibling = node.getPreviousSibling();\r\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\r\n}\r\n\r\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\r\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\r\n// in the case of a LinkNode, boundaries are not writable.\r\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\r\n  if (node.isSegmented()) {\r\n    return true;\r\n  }\r\n  if (!selection.isCollapsed()) {\r\n    return false;\r\n  }\r\n  const offset = selection.anchor.offset;\r\n  const parent = node.getParentOrThrow();\r\n  const isToken = node.isToken();\r\n  if (offset === 0) {\r\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);\r\n  } else if (offset === node.getTextContentSize()) {\r\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\r\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\r\n}\r\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\r\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\r\n}\r\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\r\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\r\n}\r\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\r\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\r\n}\r\nfunction isParagraph(keyCode, shiftKey) {\r\n  return isReturn(keyCode) && !shiftKey;\r\n}\r\nfunction isLineBreak(keyCode, shiftKey) {\r\n  return isReturn(keyCode) && shiftKey;\r\n}\r\n\r\n// Inserts a new line after the selection\r\n\r\nfunction isOpenLineBreak(keyCode, ctrlKey) {\r\n  // 79 = KeyO\r\n  return IS_APPLE && ctrlKey && keyCode === 79;\r\n}\r\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\r\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\r\n}\r\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\r\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\r\n}\r\nfunction isDeleteLineBackward(keyCode, metaKey) {\r\n  return IS_APPLE && metaKey && isBackspace(keyCode);\r\n}\r\nfunction isDeleteLineForward(keyCode, metaKey) {\r\n  return IS_APPLE && metaKey && isDelete(keyCode);\r\n}\r\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\r\n  if (IS_APPLE) {\r\n    if (altKey || metaKey) {\r\n      return false;\r\n    }\r\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\r\n  }\r\n  if (ctrlKey || altKey || metaKey) {\r\n    return false;\r\n  }\r\n  return isBackspace(keyCode);\r\n}\r\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\r\n  if (IS_APPLE) {\r\n    if (shiftKey || altKey || metaKey) {\r\n      return false;\r\n    }\r\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\r\n  }\r\n  if (ctrlKey || altKey || metaKey) {\r\n    return false;\r\n  }\r\n  return isDelete(keyCode);\r\n}\r\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\r\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\r\n}\r\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\r\n  if (IS_APPLE) {\r\n    return keyCode === 90 && metaKey && shiftKey;\r\n  }\r\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\r\n}\r\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\r\n  if (shiftKey) {\r\n    return false;\r\n  }\r\n  if (keyCode === 67) {\r\n    return IS_APPLE ? metaKey : ctrlKey;\r\n  }\r\n  return false;\r\n}\r\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\r\n  if (shiftKey) {\r\n    return false;\r\n  }\r\n  if (keyCode === 88) {\r\n    return IS_APPLE ? metaKey : ctrlKey;\r\n  }\r\n  return false;\r\n}\r\nfunction isArrowLeft(keyCode) {\r\n  return keyCode === 37;\r\n}\r\nfunction isArrowRight(keyCode) {\r\n  return keyCode === 39;\r\n}\r\nfunction isArrowUp(keyCode) {\r\n  return keyCode === 38;\r\n}\r\nfunction isArrowDown(keyCode) {\r\n  return keyCode === 40;\r\n}\r\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\r\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\r\n}\r\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\r\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\r\n}\r\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\r\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\r\n}\r\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\r\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\r\n}\r\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\r\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\r\n}\r\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\r\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\r\n}\r\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\r\n  return ctrlKey || shiftKey || altKey || metaKey;\r\n}\r\nfunction isSpace(keyCode) {\r\n  return keyCode === 32;\r\n}\r\nfunction controlOrMeta(metaKey, ctrlKey) {\r\n  if (IS_APPLE) {\r\n    return metaKey;\r\n  }\r\n  return ctrlKey;\r\n}\r\nfunction isReturn(keyCode) {\r\n  return keyCode === 13;\r\n}\r\nfunction isBackspace(keyCode) {\r\n  return keyCode === 8;\r\n}\r\nfunction isEscape(keyCode) {\r\n  return keyCode === 27;\r\n}\r\nfunction isDelete(keyCode) {\r\n  return keyCode === 46;\r\n}\r\nfunction isSelectAll(keyCode, metaKey, ctrlKey) {\r\n  return keyCode === 65 && controlOrMeta(metaKey, ctrlKey);\r\n}\r\nfunction $selectAll() {\r\n  const root = $getRoot();\r\n  const selection = root.select(0, root.getChildrenSize());\r\n  $setSelection($normalizeSelection(selection));\r\n}\r\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\r\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\r\n    classNamesTheme.__lexicalClassNameCache = {};\r\n  }\r\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\r\n  const cachedClassNames = classNamesCache[classNameThemeType];\r\n  if (cachedClassNames !== undefined) {\r\n    return cachedClassNames;\r\n  }\r\n  const classNames = classNamesTheme[classNameThemeType];\r\n  // As we're using classList, we need\r\n  // to handle className tokens that have spaces.\r\n  // The easiest way to do this to convert the\r\n  // className tokens to an array that can be\r\n  // applied to classList.add()/remove().\r\n  if (typeof classNames === 'string') {\r\n    const classNamesArr = classNames.split(' ');\r\n    classNamesCache[classNameThemeType] = classNamesArr;\r\n    return classNamesArr;\r\n  }\r\n  return classNames;\r\n}\r\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\r\n  if (mutationListeners.size === 0) {\r\n    return;\r\n  }\r\n  const nodeType = node.__type;\r\n  const nodeKey = node.__key;\r\n  const registeredNode = registeredNodes.get(nodeType);\r\n  if (registeredNode === undefined) {\r\n    {\r\n      throw Error(`Type ${nodeType} not in registeredNodes`);\r\n    }\r\n  }\r\n  const klass = registeredNode.klass;\r\n  let mutatedNodesByType = mutatedNodes.get(klass);\r\n  if (mutatedNodesByType === undefined) {\r\n    mutatedNodesByType = new Map();\r\n    mutatedNodes.set(klass, mutatedNodesByType);\r\n  }\r\n  const prevMutation = mutatedNodesByType.get(nodeKey);\r\n  // If the node has already been \"destroyed\", yet we are\r\n  // re-making it, then this means a move likely happened.\r\n  // We should change the mutation to be that of \"updated\"\r\n  // instead.\r\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\r\n  if (prevMutation === undefined || isMove) {\r\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\r\n  }\r\n}\r\nfunction $nodesOfType(klass) {\r\n  const editorState = getActiveEditorState();\r\n  const readOnly = editorState._readOnly;\r\n  const klassType = klass.getType();\r\n  const nodes = editorState._nodeMap;\r\n  const nodesOfType = [];\r\n  for (const [, node] of nodes) {\r\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\r\n      nodesOfType.push(node);\r\n    }\r\n  }\r\n  return nodesOfType;\r\n}\r\nfunction resolveElement(element, isBackward, focusOffset) {\r\n  const parent = element.getParent();\r\n  let offset = focusOffset;\r\n  let block = element;\r\n  if (parent !== null) {\r\n    if (isBackward && focusOffset === 0) {\r\n      offset = block.getIndexWithinParent();\r\n      block = parent;\r\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\r\n      offset = block.getIndexWithinParent() + 1;\r\n      block = parent;\r\n    }\r\n  }\r\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\r\n}\r\nfunction $getAdjacentNode(focus, isBackward) {\r\n  const focusOffset = focus.offset;\r\n  if (focus.type === 'element') {\r\n    const block = focus.getNode();\r\n    return resolveElement(block, isBackward, focusOffset);\r\n  } else {\r\n    const focusNode = focus.getNode();\r\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\r\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\r\n      if (possibleNode === null) {\r\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\r\n      }\r\n      return possibleNode;\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction isFirefoxClipboardEvents(editor) {\r\n  const event = getWindow(editor).event;\r\n  const inputType = event && event.inputType;\r\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\r\n}\r\nfunction dispatchCommand(editor, command, payload) {\r\n  return triggerCommandListeners(editor, command, payload);\r\n}\r\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\r\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\r\n}\r\nfunction getElementByKeyOrThrow(editor, key) {\r\n  const element = editor._keyToDOMMap.get(key);\r\n  if (element === undefined) {\r\n    {\r\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\r\n    }\r\n  }\r\n  return element;\r\n}\r\nfunction getParentElement(node) {\r\n  const parentElement = node.assignedSlot || node.parentElement;\r\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\r\n}\r\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\r\n  const doc = rootElement.ownerDocument;\r\n  const defaultView = doc.defaultView;\r\n  if (defaultView === null) {\r\n    return;\r\n  }\r\n  let {\r\n    top: currentTop,\r\n    bottom: currentBottom\r\n  } = selectionRect;\r\n  let targetTop = 0;\r\n  let targetBottom = 0;\r\n  let element = rootElement;\r\n  while (element !== null) {\r\n    const isBodyElement = element === doc.body;\r\n    if (isBodyElement) {\r\n      targetTop = 0;\r\n      targetBottom = getWindow(editor).innerHeight;\r\n    } else {\r\n      const targetRect = element.getBoundingClientRect();\r\n      targetTop = targetRect.top;\r\n      targetBottom = targetRect.bottom;\r\n    }\r\n    let diff = 0;\r\n    if (currentTop < targetTop) {\r\n      diff = -(targetTop - currentTop);\r\n    } else if (currentBottom > targetBottom) {\r\n      diff = currentBottom - targetBottom;\r\n    }\r\n    if (diff !== 0) {\r\n      if (isBodyElement) {\r\n        // Only handles scrolling of Y axis\r\n        defaultView.scrollBy(0, diff);\r\n      } else {\r\n        const scrollTop = element.scrollTop;\r\n        element.scrollTop += diff;\r\n        const yOffset = element.scrollTop - scrollTop;\r\n        currentTop -= yOffset;\r\n        currentBottom -= yOffset;\r\n      }\r\n    }\r\n    if (isBodyElement) {\r\n      break;\r\n    }\r\n    element = getParentElement(element);\r\n  }\r\n}\r\nfunction $hasUpdateTag(tag) {\r\n  const editor = getActiveEditor();\r\n  return editor._updateTags.has(tag);\r\n}\r\nfunction $addUpdateTag(tag) {\r\n  errorOnReadOnly();\r\n  const editor = getActiveEditor();\r\n  editor._updateTags.add(tag);\r\n}\r\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\r\n  const selection = $getSelection();\r\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\r\n    return selection;\r\n  }\r\n  const {\r\n    anchor,\r\n    focus\r\n  } = selection;\r\n  const anchorNode = anchor.getNode();\r\n  const focusNode = focus.getNode();\r\n  if ($hasAncestor(anchorNode, parentNode)) {\r\n    anchor.set(parentNode.__key, 0, 'element');\r\n  }\r\n  if ($hasAncestor(focusNode, parentNode)) {\r\n    focus.set(parentNode.__key, 0, 'element');\r\n  }\r\n  return selection;\r\n}\r\nfunction $hasAncestor(child, targetNode) {\r\n  let parent = child.getParent();\r\n  while (parent !== null) {\r\n    if (parent.is(targetNode)) {\r\n      return true;\r\n    }\r\n    parent = parent.getParent();\r\n  }\r\n  return false;\r\n}\r\nfunction getDefaultView(domElem) {\r\n  const ownerDoc = domElem.ownerDocument;\r\n  return ownerDoc && ownerDoc.defaultView || null;\r\n}\r\nfunction getWindow(editor) {\r\n  const windowObj = editor._window;\r\n  if (windowObj === null) {\r\n    {\r\n      throw Error(`window object not found`);\r\n    }\r\n  }\r\n  return windowObj;\r\n}\r\nfunction $isInlineElementOrDecoratorNode(node) {\r\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\r\n}\r\nfunction $getNearestRootOrShadowRoot(node) {\r\n  let parent = node.getParentOrThrow();\r\n  while (parent !== null) {\r\n    if ($isRootOrShadowRoot(parent)) {\r\n      return parent;\r\n    }\r\n    parent = parent.getParentOrThrow();\r\n  }\r\n  return parent;\r\n}\r\nfunction $isRootOrShadowRoot(node) {\r\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\r\n}\r\nfunction $copyNode(node) {\r\n  const copy = node.constructor.clone(node);\r\n  $setNodeKey(copy, null);\r\n  // @ts-expect-error\r\n  return copy;\r\n}\r\nfunction $applyNodeReplacement(node) {\r\n  const editor = getActiveEditor();\r\n  const nodeType = node.constructor.getType();\r\n  const registeredNode = editor._nodes.get(nodeType);\r\n  if (registeredNode === undefined) {\r\n    {\r\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\r\n    }\r\n  }\r\n  const replaceFunc = registeredNode.replace;\r\n  if (replaceFunc !== null) {\r\n    const replacementNode = replaceFunc(node);\r\n    if (!(replacementNode instanceof node.constructor)) {\r\n      {\r\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\r\n      }\r\n    }\r\n    return replacementNode;\r\n  }\r\n  return node;\r\n}\r\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\r\n  const parentNode = node.getParent();\r\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\r\n    {\r\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\r\n    }\r\n  }\r\n}\r\nfunction createBlockCursorElement(editorConfig) {\r\n  const theme = editorConfig.theme;\r\n  const element = document.createElement('div');\r\n  element.contentEditable = 'false';\r\n  element.setAttribute('data-lexical-cursor', 'true');\r\n  let blockCursorTheme = theme.blockCursor;\r\n  if (blockCursorTheme !== undefined) {\r\n    if (typeof blockCursorTheme === 'string') {\r\n      const classNamesArr = blockCursorTheme.split(' ');\r\n      // @ts-expect-error: intentional\r\n      blockCursorTheme = theme.blockCursor = classNamesArr;\r\n    }\r\n    if (blockCursorTheme !== undefined) {\r\n      element.classList.add(...blockCursorTheme);\r\n    }\r\n  }\r\n  return element;\r\n}\r\nfunction needsBlockCursor(node) {\r\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\r\n}\r\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\r\n  rootElement.style.removeProperty('caret-color');\r\n  editor._blockCursorElement = null;\r\n  const parentElement = blockCursorElement.parentElement;\r\n  if (parentElement !== null) {\r\n    parentElement.removeChild(blockCursorElement);\r\n  }\r\n}\r\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\r\n  let blockCursorElement = editor._blockCursorElement;\r\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\r\n    const anchor = nextSelection.anchor;\r\n    const elementNode = anchor.getNode();\r\n    const offset = anchor.offset;\r\n    const elementNodeSize = elementNode.getChildrenSize();\r\n    let isBlockCursor = false;\r\n    let insertBeforeElement = null;\r\n    if (offset === elementNodeSize) {\r\n      const child = elementNode.getChildAtIndex(offset - 1);\r\n      if (needsBlockCursor(child)) {\r\n        isBlockCursor = true;\r\n      }\r\n    } else {\r\n      const child = elementNode.getChildAtIndex(offset);\r\n      if (needsBlockCursor(child)) {\r\n        const sibling = child.getPreviousSibling();\r\n        if (sibling === null || needsBlockCursor(sibling)) {\r\n          isBlockCursor = true;\r\n          insertBeforeElement = editor.getElementByKey(child.__key);\r\n        }\r\n      }\r\n    }\r\n    if (isBlockCursor) {\r\n      const elementDOM = editor.getElementByKey(elementNode.__key);\r\n      if (blockCursorElement === null) {\r\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\r\n      }\r\n      rootElement.style.caretColor = 'transparent';\r\n      if (insertBeforeElement === null) {\r\n        elementDOM.appendChild(blockCursorElement);\r\n      } else {\r\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\r\n      }\r\n      return;\r\n    }\r\n  }\r\n  // Remove cursor\r\n  if (blockCursorElement !== null) {\r\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\r\n  }\r\n}\r\nfunction getDOMSelection(targetWindow) {\r\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\r\n}\r\nfunction $splitNode(node, offset) {\r\n  let startNode = node.getChildAtIndex(offset);\r\n  if (startNode == null) {\r\n    startNode = node;\r\n  }\r\n  if (!!$isRootOrShadowRoot(node)) {\r\n    throw Error(`Can not call $splitNode() on root element`);\r\n  }\r\n  const recurse = currentNode => {\r\n    const parent = currentNode.getParentOrThrow();\r\n    const isParentRoot = $isRootOrShadowRoot(parent);\r\n    // The node we start split from (leaf) is moved, but its recursive\r\n    // parents are copied to create separate tree\r\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\r\n    if (isParentRoot) {\r\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\r\n        throw Error(`Children of a root must be ElementNode`);\r\n      }\r\n      currentNode.insertAfter(nodeToMove);\r\n      return [currentNode, nodeToMove, nodeToMove];\r\n    } else {\r\n      const [leftTree, rightTree, newParent] = recurse(parent);\r\n      const nextSiblings = currentNode.getNextSiblings();\r\n      newParent.append(nodeToMove, ...nextSiblings);\r\n      return [leftTree, rightTree, nodeToMove];\r\n    }\r\n  };\r\n  const [leftTree, rightTree] = recurse(startNode);\r\n  return [leftTree, rightTree];\r\n}\r\n\r\n/**\r\n * @param x - The element being tested\r\n * @returns Returns true if x is an HTML anchor tag, false otherwise\r\n */\r\nfunction isHTMLAnchorElement(x) {\r\n  return isHTMLElement(x) && x.tagName === 'A';\r\n}\r\n\r\n/**\r\n * @param x - The element being testing\r\n * @returns Returns true if x is an HTML element, false otherwise.\r\n */\r\nfunction isHTMLElement(x) {\r\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\r\n  return x.nodeType === 1;\r\n}\r\n\r\n/**\r\n * This function is for internal use of the library.\r\n * Please do not use it as it may change in the future.\r\n */\r\nfunction INTERNAL_$isBlock(node) {\r\n  if ($isDecoratorNode(node) && !node.isInline()) {\r\n    return true;\r\n  }\r\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\r\n    return false;\r\n  }\r\n  const firstChild = node.getFirstChild();\r\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\r\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\r\n}\r\nfunction $getAncestor(node, predicate) {\r\n  let parent = node;\r\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\r\n    parent = parent.getParentOrThrow();\r\n  }\r\n  return predicate(parent) ? parent : null;\r\n}\r\n\r\n/**\r\n * Utility function for accessing current active editor instance.\r\n * @returns Current active editor\r\n */\r\nfunction $getEditor() {\r\n  return getActiveEditor();\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\r\n  const currentDecorators = editor._decorators;\r\n  const pendingDecorators = editor._pendingDecorators;\r\n  let decorators = pendingDecorators || currentDecorators;\r\n  const nodeMap = pendingEditorState._nodeMap;\r\n  let key;\r\n  for (key in decorators) {\r\n    if (!nodeMap.has(key)) {\r\n      if (decorators === currentDecorators) {\r\n        decorators = cloneDecorators(editor);\r\n      }\r\n      delete decorators[key];\r\n    }\r\n  }\r\n}\r\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\r\n  let child = node.getFirstChild();\r\n  while (child !== null) {\r\n    const childKey = child.__key;\r\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\r\n    if (child.__parent === parentKey) {\r\n      if ($isElementNode(child)) {\r\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\r\n      }\r\n\r\n      // If we have created a node and it was dereferenced, then also\r\n      // remove it from out dirty nodes Set.\r\n      if (!prevNodeMap.has(childKey)) {\r\n        dirtyNodes.delete(childKey);\r\n      }\r\n      nodeMapDelete.push(childKey);\r\n    }\r\n    child = child.getNextSibling();\r\n  }\r\n}\r\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\r\n  const prevNodeMap = prevEditorState._nodeMap;\r\n  const nodeMap = editorState._nodeMap;\r\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\r\n  // hinder accessing .__next on child nodes\r\n  const nodeMapDelete = [];\r\n  for (const [nodeKey] of dirtyElements) {\r\n    const node = nodeMap.get(nodeKey);\r\n    if (node !== undefined) {\r\n      // Garbage collect node and its children if they exist\r\n      if (!node.isAttached()) {\r\n        if ($isElementNode(node)) {\r\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\r\n        }\r\n        // If we have created a node and it was dereferenced, then also\r\n        // remove it from out dirty nodes Set.\r\n        if (!prevNodeMap.has(nodeKey)) {\r\n          dirtyElements.delete(nodeKey);\r\n        }\r\n        nodeMapDelete.push(nodeKey);\r\n      }\r\n    }\r\n  }\r\n  for (const nodeKey of nodeMapDelete) {\r\n    nodeMap.delete(nodeKey);\r\n  }\r\n  for (const nodeKey of dirtyLeaves) {\r\n    const node = nodeMap.get(nodeKey);\r\n    if (node !== undefined && !node.isAttached()) {\r\n      if (!prevNodeMap.has(nodeKey)) {\r\n        dirtyLeaves.delete(nodeKey);\r\n      }\r\n      nodeMap.delete(nodeKey);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nlet subTreeTextContent = '';\r\nlet subTreeDirectionedTextContent = '';\r\nlet editorTextContent = '';\r\nlet activeEditorConfig;\r\nlet activeEditor$1;\r\nlet activeEditorNodes;\r\nlet treatAllNodesAsDirty = false;\r\nlet activeEditorStateReadOnly = false;\r\nlet activeMutationListeners;\r\nlet activeTextDirection = null;\r\nlet activeDirtyElements;\r\nlet activeDirtyLeaves;\r\nlet activePrevNodeMap;\r\nlet activeNextNodeMap;\r\nlet activePrevKeyToDOMMap;\r\nlet mutatedNodes;\r\nfunction destroyNode(key, parentDOM) {\r\n  const node = activePrevNodeMap.get(key);\r\n  if (parentDOM !== null) {\r\n    const dom = getPrevElementByKeyOrThrow(key);\r\n    if (dom.parentNode === parentDOM) {\r\n      parentDOM.removeChild(dom);\r\n    }\r\n  }\r\n\r\n  // This logic is really important, otherwise we will leak DOM nodes\r\n  // when their corresponding LexicalNodes are removed from the editor state.\r\n  if (!activeNextNodeMap.has(key)) {\r\n    activeEditor$1._keyToDOMMap.delete(key);\r\n  }\r\n  if ($isElementNode(node)) {\r\n    const children = createChildrenArray(node, activePrevNodeMap);\r\n    destroyChildren(children, 0, children.length - 1, null);\r\n  }\r\n  if (node !== undefined) {\r\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\r\n  }\r\n}\r\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\r\n  let startIndex = _startIndex;\r\n  for (; startIndex <= endIndex; ++startIndex) {\r\n    const child = children[startIndex];\r\n    if (child !== undefined) {\r\n      destroyNode(child, dom);\r\n    }\r\n  }\r\n}\r\nfunction setTextAlign(domStyle, value) {\r\n  domStyle.setProperty('text-align', value);\r\n}\r\nconst DEFAULT_INDENT_VALUE = '40px';\r\nfunction setElementIndent(dom, indent) {\r\n  const indentClassName = activeEditorConfig.theme.indent;\r\n  if (typeof indentClassName === 'string') {\r\n    const elementHasClassName = dom.classList.contains(indentClassName);\r\n    if (indent > 0 && !elementHasClassName) {\r\n      dom.classList.add(indentClassName);\r\n    } else if (indent < 1 && elementHasClassName) {\r\n      dom.classList.remove(indentClassName);\r\n    }\r\n  }\r\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\r\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\r\n}\r\nfunction setElementFormat(dom, format) {\r\n  const domStyle = dom.style;\r\n  if (format === 0) {\r\n    setTextAlign(domStyle, '');\r\n  } else if (format === IS_ALIGN_LEFT) {\r\n    setTextAlign(domStyle, 'left');\r\n  } else if (format === IS_ALIGN_CENTER) {\r\n    setTextAlign(domStyle, 'center');\r\n  } else if (format === IS_ALIGN_RIGHT) {\r\n    setTextAlign(domStyle, 'right');\r\n  } else if (format === IS_ALIGN_JUSTIFY) {\r\n    setTextAlign(domStyle, 'justify');\r\n  } else if (format === IS_ALIGN_START) {\r\n    setTextAlign(domStyle, 'start');\r\n  } else if (format === IS_ALIGN_END) {\r\n    setTextAlign(domStyle, 'end');\r\n  }\r\n}\r\nfunction createNode(key, parentDOM, insertDOM) {\r\n  const node = activeNextNodeMap.get(key);\r\n  if (node === undefined) {\r\n    {\r\n      throw Error(`createNode: node does not exist in nodeMap`);\r\n    }\r\n  }\r\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\r\n  storeDOMWithKey(key, dom, activeEditor$1);\r\n\r\n  // This helps preserve the text, and stops spell check tools from\r\n  // merging or break the spans (which happens if they are missing\r\n  // this attribute).\r\n  if ($isTextNode(node)) {\r\n    dom.setAttribute('data-lexical-text', 'true');\r\n  } else if ($isDecoratorNode(node)) {\r\n    dom.setAttribute('data-lexical-decorator', 'true');\r\n  }\r\n  if ($isElementNode(node)) {\r\n    const indent = node.__indent;\r\n    const childrenSize = node.__size;\r\n    if (indent !== 0) {\r\n      setElementIndent(dom, indent);\r\n    }\r\n    if (childrenSize !== 0) {\r\n      const endIndex = childrenSize - 1;\r\n      const children = createChildrenArray(node, activeNextNodeMap);\r\n      createChildrenWithDirection(children, endIndex, node, dom);\r\n    }\r\n    const format = node.__format;\r\n    if (format !== 0) {\r\n      setElementFormat(dom, format);\r\n    }\r\n    if (!node.isInline()) {\r\n      reconcileElementTerminatingLineBreak(null, node, dom);\r\n    }\r\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\r\n      subTreeTextContent += DOUBLE_LINE_BREAK;\r\n      editorTextContent += DOUBLE_LINE_BREAK;\r\n    }\r\n  } else {\r\n    const text = node.getTextContent();\r\n    if ($isDecoratorNode(node)) {\r\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\r\n      if (decorator !== null) {\r\n        reconcileDecorator(key, decorator);\r\n      }\r\n      // Decorators are always non editable\r\n      dom.contentEditable = 'false';\r\n    } else if ($isTextNode(node)) {\r\n      if (!node.isDirectionless()) {\r\n        subTreeDirectionedTextContent += text;\r\n      }\r\n    }\r\n    subTreeTextContent += text;\r\n    editorTextContent += text;\r\n  }\r\n  if (parentDOM !== null) {\r\n    if (insertDOM != null) {\r\n      parentDOM.insertBefore(dom, insertDOM);\r\n    } else {\r\n      // @ts-expect-error: internal field\r\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\r\n      if (possibleLineBreak != null) {\r\n        parentDOM.insertBefore(dom, possibleLineBreak);\r\n      } else {\r\n        parentDOM.appendChild(dom);\r\n      }\r\n    }\r\n  }\r\n  {\r\n    // Freeze the node in DEV to prevent accidental mutations\r\n    Object.freeze(node);\r\n  }\r\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\r\n  return dom;\r\n}\r\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\r\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\r\n  subTreeDirectionedTextContent = '';\r\n  createChildren(children, element, 0, endIndex, dom, null);\r\n  reconcileBlockDirection(element, dom);\r\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\r\n}\r\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\r\n  const previousSubTreeTextContent = subTreeTextContent;\r\n  subTreeTextContent = '';\r\n  let startIndex = _startIndex;\r\n  for (; startIndex <= endIndex; ++startIndex) {\r\n    createNode(children[startIndex], dom, insertDOM);\r\n  }\r\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\r\n    subTreeTextContent += DOUBLE_LINE_BREAK;\r\n  }\r\n  // @ts-expect-error: internal field\r\n  dom.__lexicalTextContent = subTreeTextContent;\r\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\r\n}\r\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\r\n  const node = nodeMap.get(childKey);\r\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\r\n}\r\n\r\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\r\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\r\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\r\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\r\n  if (prevLineBreak) {\r\n    if (!nextLineBreak) {\r\n      // @ts-expect-error: internal field\r\n      const element = dom.__lexicalLineBreak;\r\n      if (element != null) {\r\n        dom.removeChild(element);\r\n      }\r\n\r\n      // @ts-expect-error: internal field\r\n      dom.__lexicalLineBreak = null;\r\n    }\r\n  } else if (nextLineBreak) {\r\n    const element = document.createElement('br');\r\n    // @ts-expect-error: internal field\r\n    dom.__lexicalLineBreak = element;\r\n    dom.appendChild(element);\r\n  }\r\n}\r\nfunction reconcileBlockDirection(element, dom) {\r\n  const previousSubTreeDirectionTextContent =\r\n  // @ts-expect-error: internal field\r\n  dom.__lexicalDirTextContent;\r\n  // @ts-expect-error: internal field\r\n  const previousDirection = dom.__lexicalDir;\r\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\r\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\r\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\r\n    if (direction !== previousDirection) {\r\n      const classList = dom.classList;\r\n      const theme = activeEditorConfig.theme;\r\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\r\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\r\n\r\n      // Remove the old theme classes if they exist\r\n      if (previousDirectionTheme !== undefined) {\r\n        if (typeof previousDirectionTheme === 'string') {\r\n          const classNamesArr = previousDirectionTheme.split(' ');\r\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\r\n        }\r\n\r\n        // @ts-ignore: intentional\r\n        classList.remove(...previousDirectionTheme);\r\n      }\r\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\r\n        // Remove direction\r\n        dom.removeAttribute('dir');\r\n      } else {\r\n        // Apply the new theme classes if they exist\r\n        if (nextDirectionTheme !== undefined) {\r\n          if (typeof nextDirectionTheme === 'string') {\r\n            const classNamesArr = nextDirectionTheme.split(' ');\r\n            // @ts-expect-error: intentional\r\n            nextDirectionTheme = theme[direction] = classNamesArr;\r\n          }\r\n          if (nextDirectionTheme !== undefined) {\r\n            classList.add(...nextDirectionTheme);\r\n          }\r\n        }\r\n\r\n        // Update direction\r\n        dom.dir = direction;\r\n      }\r\n      if (!activeEditorStateReadOnly) {\r\n        const writableNode = element.getWritable();\r\n        writableNode.__dir = direction;\r\n      }\r\n    }\r\n    activeTextDirection = direction;\r\n    // @ts-expect-error: internal field\r\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\r\n    // @ts-expect-error: internal field\r\n    dom.__lexicalDir = direction;\r\n  }\r\n}\r\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\r\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\r\n  subTreeDirectionedTextContent = '';\r\n  reconcileChildren(prevElement, nextElement, dom);\r\n  reconcileBlockDirection(nextElement, dom);\r\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\r\n}\r\nfunction createChildrenArray(element, nodeMap) {\r\n  const children = [];\r\n  let nodeKey = element.__first;\r\n  while (nodeKey !== null) {\r\n    const node = nodeMap.get(nodeKey);\r\n    if (node === undefined) {\r\n      {\r\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\r\n      }\r\n    }\r\n    children.push(nodeKey);\r\n    nodeKey = node.__next;\r\n  }\r\n  return children;\r\n}\r\nfunction reconcileChildren(prevElement, nextElement, dom) {\r\n  const previousSubTreeTextContent = subTreeTextContent;\r\n  const prevChildrenSize = prevElement.__size;\r\n  const nextChildrenSize = nextElement.__size;\r\n  subTreeTextContent = '';\r\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\r\n    const prevFirstChildKey = prevElement.__first;\r\n    const nextFrstChildKey = nextElement.__first;\r\n    if (prevFirstChildKey === nextFrstChildKey) {\r\n      reconcileNode(prevFirstChildKey, dom);\r\n    } else {\r\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\r\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\r\n      dom.replaceChild(replacementDOM, lastDOM);\r\n      destroyNode(prevFirstChildKey, null);\r\n    }\r\n  } else {\r\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\r\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\r\n    if (prevChildrenSize === 0) {\r\n      if (nextChildrenSize !== 0) {\r\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\r\n      }\r\n    } else if (nextChildrenSize === 0) {\r\n      if (prevChildrenSize !== 0) {\r\n        // @ts-expect-error: internal field\r\n        const lexicalLineBreak = dom.__lexicalLineBreak;\r\n        const canUseFastPath = lexicalLineBreak == null;\r\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\r\n        if (canUseFastPath) {\r\n          // Fast path for removing DOM nodes\r\n          dom.textContent = '';\r\n        }\r\n      }\r\n    } else {\r\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\r\n    }\r\n  }\r\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\r\n    subTreeTextContent += DOUBLE_LINE_BREAK;\r\n  }\r\n\r\n  // @ts-expect-error: internal field\r\n  dom.__lexicalTextContent = subTreeTextContent;\r\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\r\n}\r\nfunction reconcileNode(key, parentDOM) {\r\n  const prevNode = activePrevNodeMap.get(key);\r\n  let nextNode = activeNextNodeMap.get(key);\r\n  if (prevNode === undefined || nextNode === undefined) {\r\n    {\r\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\r\n    }\r\n  }\r\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\r\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\r\n\r\n  // If the node key points to the same instance in both states\r\n  // and isn't dirty, we just update the text content cache\r\n  // and return the existing DOM Node.\r\n  if (prevNode === nextNode && !isDirty) {\r\n    if ($isElementNode(prevNode)) {\r\n      // @ts-expect-error: internal field\r\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\r\n      if (previousSubTreeTextContent !== undefined) {\r\n        subTreeTextContent += previousSubTreeTextContent;\r\n        editorTextContent += previousSubTreeTextContent;\r\n      }\r\n\r\n      // @ts-expect-error: internal field\r\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\r\n      if (previousSubTreeDirectionTextContent !== undefined) {\r\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\r\n      }\r\n    } else {\r\n      const text = prevNode.getTextContent();\r\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\r\n        subTreeDirectionedTextContent += text;\r\n      }\r\n      editorTextContent += text;\r\n      subTreeTextContent += text;\r\n    }\r\n    return dom;\r\n  }\r\n  // If the node key doesn't point to the same instance in both maps,\r\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\r\n  if (prevNode !== nextNode && isDirty) {\r\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\r\n  }\r\n\r\n  // Update node. If it returns true, we need to unmount and re-create the node\r\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\r\n    const replacementDOM = createNode(key, null, null);\r\n    if (parentDOM === null) {\r\n      {\r\n        throw Error(`reconcileNode: parentDOM is null`);\r\n      }\r\n    }\r\n    parentDOM.replaceChild(replacementDOM, dom);\r\n    destroyNode(key, null);\r\n    return replacementDOM;\r\n  }\r\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\r\n    // Reconcile element children\r\n    const nextIndent = nextNode.__indent;\r\n    if (nextIndent !== prevNode.__indent) {\r\n      setElementIndent(dom, nextIndent);\r\n    }\r\n    const nextFormat = nextNode.__format;\r\n    if (nextFormat !== prevNode.__format) {\r\n      setElementFormat(dom, nextFormat);\r\n    }\r\n    if (isDirty) {\r\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\r\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\r\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\r\n      }\r\n    }\r\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\r\n      subTreeTextContent += DOUBLE_LINE_BREAK;\r\n      editorTextContent += DOUBLE_LINE_BREAK;\r\n    }\r\n  } else {\r\n    const text = nextNode.getTextContent();\r\n    if ($isDecoratorNode(nextNode)) {\r\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\r\n      if (decorator !== null) {\r\n        reconcileDecorator(key, decorator);\r\n      }\r\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\r\n      // Handle text content, for LTR, LTR cases.\r\n      subTreeDirectionedTextContent += text;\r\n    }\r\n    subTreeTextContent += text;\r\n    editorTextContent += text;\r\n  }\r\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\r\n    // Cache the latest text content.\r\n    const nextRootNode = nextNode.getWritable();\r\n    nextRootNode.__cachedText = editorTextContent;\r\n    nextNode = nextRootNode;\r\n  }\r\n  {\r\n    // Freeze the node in DEV to prevent accidental mutations\r\n    Object.freeze(nextNode);\r\n  }\r\n  return dom;\r\n}\r\nfunction reconcileDecorator(key, decorator) {\r\n  let pendingDecorators = activeEditor$1._pendingDecorators;\r\n  const currentDecorators = activeEditor$1._decorators;\r\n  if (pendingDecorators === null) {\r\n    if (currentDecorators[key] === decorator) {\r\n      return;\r\n    }\r\n    pendingDecorators = cloneDecorators(activeEditor$1);\r\n  }\r\n  pendingDecorators[key] = decorator;\r\n}\r\nfunction getFirstChild(element) {\r\n  return element.firstChild;\r\n}\r\nfunction getNextSibling(element) {\r\n  let nextSibling = element.nextSibling;\r\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\r\n    nextSibling = nextSibling.nextSibling;\r\n  }\r\n  return nextSibling;\r\n}\r\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\r\n  const prevEndIndex = prevChildrenLength - 1;\r\n  const nextEndIndex = nextChildrenLength - 1;\r\n  let prevChildrenSet;\r\n  let nextChildrenSet;\r\n  let siblingDOM = getFirstChild(dom);\r\n  let prevIndex = 0;\r\n  let nextIndex = 0;\r\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\r\n    const prevKey = prevChildren[prevIndex];\r\n    const nextKey = nextChildren[nextIndex];\r\n    if (prevKey === nextKey) {\r\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\r\n      prevIndex++;\r\n      nextIndex++;\r\n    } else {\r\n      if (prevChildrenSet === undefined) {\r\n        prevChildrenSet = new Set(prevChildren);\r\n      }\r\n      if (nextChildrenSet === undefined) {\r\n        nextChildrenSet = new Set(nextChildren);\r\n      }\r\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\r\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\r\n      if (!nextHasPrevKey) {\r\n        // Remove prev\r\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\r\n        destroyNode(prevKey, dom);\r\n        prevIndex++;\r\n      } else if (!prevHasNextKey) {\r\n        // Create next\r\n        createNode(nextKey, dom, siblingDOM);\r\n        nextIndex++;\r\n      } else {\r\n        // Move next\r\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\r\n        if (childDOM === siblingDOM) {\r\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\r\n        } else {\r\n          if (siblingDOM != null) {\r\n            dom.insertBefore(childDOM, siblingDOM);\r\n          } else {\r\n            dom.appendChild(childDOM);\r\n          }\r\n          reconcileNode(nextKey, dom);\r\n        }\r\n        prevIndex++;\r\n        nextIndex++;\r\n      }\r\n    }\r\n  }\r\n  const appendNewChildren = prevIndex > prevEndIndex;\r\n  const removeOldChildren = nextIndex > nextEndIndex;\r\n  if (appendNewChildren && !removeOldChildren) {\r\n    const previousNode = nextChildren[nextEndIndex + 1];\r\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\r\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\r\n  } else if (removeOldChildren && !appendNewChildren) {\r\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\r\n  }\r\n}\r\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\r\n  // We cache text content to make retrieval more efficient.\r\n  // The cache must be rebuilt during reconciliation to account for any changes.\r\n  subTreeTextContent = '';\r\n  editorTextContent = '';\r\n  subTreeDirectionedTextContent = '';\r\n  // Rather than pass around a load of arguments through the stack recursively\r\n  // we instead set them as bindings within the scope of the module.\r\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\r\n  activeTextDirection = null;\r\n  activeEditor$1 = editor;\r\n  activeEditorConfig = editor._config;\r\n  activeEditorNodes = editor._nodes;\r\n  activeMutationListeners = activeEditor$1._listeners.mutation;\r\n  activeDirtyElements = dirtyElements;\r\n  activeDirtyLeaves = dirtyLeaves;\r\n  activePrevNodeMap = prevEditorState._nodeMap;\r\n  activeNextNodeMap = nextEditorState._nodeMap;\r\n  activeEditorStateReadOnly = nextEditorState._readOnly;\r\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\r\n  // We keep track of mutated nodes so we can trigger mutation\r\n  // listeners later in the update cycle.\r\n  const currentMutatedNodes = new Map();\r\n  mutatedNodes = currentMutatedNodes;\r\n  reconcileNode('root', null);\r\n  // We don't want a bunch of void checks throughout the scope\r\n  // so instead we make it seem that these values are always set.\r\n  // We also want to make sure we clear them down, otherwise we\r\n  // can leak memory.\r\n  // @ts-ignore\r\n  activeEditor$1 = undefined;\r\n  // @ts-ignore\r\n  activeEditorNodes = undefined;\r\n  // @ts-ignore\r\n  activeDirtyElements = undefined;\r\n  // @ts-ignore\r\n  activeDirtyLeaves = undefined;\r\n  // @ts-ignore\r\n  activePrevNodeMap = undefined;\r\n  // @ts-ignore\r\n  activeNextNodeMap = undefined;\r\n  // @ts-ignore\r\n  activeEditorConfig = undefined;\r\n  // @ts-ignore\r\n  activePrevKeyToDOMMap = undefined;\r\n  // @ts-ignore\r\n  mutatedNodes = undefined;\r\n  return currentMutatedNodes;\r\n}\r\nfunction storeDOMWithKey(key, dom, editor) {\r\n  const keyToDOMMap = editor._keyToDOMMap;\r\n  // @ts-ignore We intentionally add this to the Node.\r\n  dom['__lexicalKey_' + editor._key] = key;\r\n  keyToDOMMap.set(key, dom);\r\n}\r\nfunction getPrevElementByKeyOrThrow(key) {\r\n  const element = activePrevKeyToDOMMap.get(key);\r\n  if (element === undefined) {\r\n    {\r\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\r\n    }\r\n  }\r\n  return element;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nconst PASS_THROUGH_COMMAND = Object.freeze({});\r\nconst ANDROID_COMPOSITION_LATENCY = 30;\r\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\r\nif (CAN_USE_BEFORE_INPUT) {\r\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\r\n}\r\nlet lastKeyDownTimeStamp = 0;\r\nlet lastKeyCode = 0;\r\nlet lastBeforeInputInsertTextTimeStamp = 0;\r\nlet unprocessedBeforeInputData = null;\r\nlet rootElementsRegistered = 0;\r\nlet isSelectionChangeFromDOMUpdate = false;\r\nlet isSelectionChangeFromMouseDown = false;\r\nlet isInsertLineBreak = false;\r\nlet isFirefoxEndingComposition = false;\r\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\r\n\r\n// This function is used to determine if Lexical should attempt to override\r\n// the default browser behavior for insertion of text and use its own internal\r\n// heuristics. This is an extremely important function, and makes much of Lexical\r\n// work as intended between different browsers and across word, line and character\r\n// boundary/formats. It also is important for text replacement, node schemas and\r\n// composition mechanics.\r\n\r\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\r\n  const anchor = selection.anchor;\r\n  const focus = selection.focus;\r\n  const anchorNode = anchor.getNode();\r\n  const editor = getActiveEditor();\r\n  const domSelection = getDOMSelection(editor._window);\r\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\r\n  const anchorKey = anchor.key;\r\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\r\n  const textLength = text.length;\r\n  return anchorKey !== focus.key ||\r\n  // If we're working with a non-text node.\r\n  !$isTextNode(anchorNode) ||\r\n  // If we are replacing a range with a single character or grapheme, and not composing.\r\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\r\n  // We check to see if there has been\r\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\r\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\r\n  // a dangling `input` event caused by execCommand('insertText').\r\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\r\n  // Any non standard text node.\r\n  $isTokenOrSegmented(anchorNode) ||\r\n  // If the text length is more than a single character and we're either\r\n  // dealing with this in \"beforeinput\" or where the node has already recently\r\n  // been changed (thus is dirty).\r\n  anchorNode.isDirty() && textLength > 1 ||\r\n  // If the DOM selection element is not the same as the backing node during beforeinput.\r\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\r\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\r\n  // of the editor.\r\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\r\n  // Check if we're changing from bold to italics, or some other format.\r\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\r\n  // One last set of heuristics to check against.\r\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\r\n}\r\nfunction shouldSkipSelectionChange(domNode, offset) {\r\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\r\n}\r\nfunction onSelectionChange(domSelection, editor, isActive) {\r\n  const {\r\n    anchorNode: anchorDOM,\r\n    anchorOffset,\r\n    focusNode: focusDOM,\r\n    focusOffset\r\n  } = domSelection;\r\n  if (isSelectionChangeFromDOMUpdate) {\r\n    isSelectionChangeFromDOMUpdate = false;\r\n\r\n    // If native DOM selection is on a DOM element, then\r\n    // we should continue as usual, as Lexical's selection\r\n    // may have normalized to a better child. If the DOM\r\n    // element is a text node, we can safely apply this\r\n    // optimization and skip the selection change entirely.\r\n    // We also need to check if the offset is at the boundary,\r\n    // because in this case, we might need to normalize to a\r\n    // sibling instead.\r\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\r\n      return;\r\n    }\r\n  }\r\n  updateEditor(editor, () => {\r\n    // Non-active editor don't need any extra logic for selection, it only needs update\r\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\r\n    if (!isActive) {\r\n      $setSelection(null);\r\n      return;\r\n    }\r\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\r\n      return;\r\n    }\r\n    const selection = $getSelection();\r\n\r\n    // Update the selection format\r\n    if ($isRangeSelection(selection)) {\r\n      const anchor = selection.anchor;\r\n      const anchorNode = anchor.getNode();\r\n      if (selection.isCollapsed()) {\r\n        // Badly interpreted range selection when collapsed - #1482\r\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\r\n          selection.dirty = true;\r\n        }\r\n\r\n        // If we have marked a collapsed selection format, and we're\r\n        // within the given time range – then attempt to use that format\r\n        // instead of getting the format from the anchor node.\r\n        const windowEvent = getWindow(editor).event;\r\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\r\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\r\n        const root = $getRoot();\r\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\r\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\r\n          selection.format = lastFormat;\r\n          selection.style = lastStyle;\r\n        } else {\r\n          if (anchor.type === 'text') {\r\n            if (!$isTextNode(anchorNode)) {\r\n              throw Error(`Point.getNode() must return TextNode when type is text`);\r\n            }\r\n            selection.format = anchorNode.getFormat();\r\n            selection.style = anchorNode.getStyle();\r\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\r\n            selection.format = 0;\r\n            selection.style = '';\r\n          }\r\n        }\r\n      } else {\r\n        const anchorKey = anchor.key;\r\n        const focus = selection.focus;\r\n        const focusKey = focus.key;\r\n        const nodes = selection.getNodes();\r\n        const nodesLength = nodes.length;\r\n        const isBackward = selection.isBackward();\r\n        const startOffset = isBackward ? focusOffset : anchorOffset;\r\n        const endOffset = isBackward ? anchorOffset : focusOffset;\r\n        const startKey = isBackward ? focusKey : anchorKey;\r\n        const endKey = isBackward ? anchorKey : focusKey;\r\n        let combinedFormat = IS_ALL_FORMATTING;\r\n        let hasTextNodes = false;\r\n        for (let i = 0; i < nodesLength; i++) {\r\n          const node = nodes[i];\r\n          const textContentSize = node.getTextContentSize();\r\n          if ($isTextNode(node) && textContentSize !== 0 &&\r\n          // Exclude empty text nodes at boundaries resulting from user's selection\r\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\r\n            // TODO: what about style?\r\n            hasTextNodes = true;\r\n            combinedFormat &= node.getFormat();\r\n            if (combinedFormat === 0) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        selection.format = hasTextNodes ? combinedFormat : 0;\r\n      }\r\n    }\r\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\r\n  });\r\n}\r\n\r\n// This is a work-around is mainly Chrome specific bug where if you select\r\n// the contents of an empty block, you cannot easily unselect anything.\r\n// This results in a tiny selection box that looks buggy/broken. This can\r\n// also help other browsers when selection might \"appear\" lost, when it\r\n// really isn't.\r\nfunction onClick(event, editor) {\r\n  updateEditor(editor, () => {\r\n    const selection = $getSelection();\r\n    const domSelection = getDOMSelection(editor._window);\r\n    const lastSelection = $getPreviousSelection();\r\n    if (domSelection) {\r\n      if ($isRangeSelection(selection)) {\r\n        const anchor = selection.anchor;\r\n        const anchorNode = anchor.getNode();\r\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\r\n          domSelection.removeAllRanges();\r\n          selection.dirty = true;\r\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\r\n          // Tripple click causing selection to overflow into the nearest element. In that\r\n          // case visually it looks like a single element content is selected, focus node\r\n          // is actually at the beginning of the next element (if present) and any manipulations\r\n          // with selection (formatting) are affecting second element as well\r\n          const focus = selection.focus;\r\n          const focusNode = focus.getNode();\r\n          if (anchorNode !== focusNode) {\r\n            if ($isElementNode(anchorNode)) {\r\n              anchorNode.select(0);\r\n            } else {\r\n              anchorNode.getParentOrThrow().select(0);\r\n            }\r\n          }\r\n        }\r\n      } else if (event.pointerType === 'touch') {\r\n        // This is used to update the selection on touch devices when the user clicks on text after a\r\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\r\n        const domAnchorNode = domSelection.anchorNode;\r\n        if (domAnchorNode !== null) {\r\n          const nodeType = domAnchorNode.nodeType;\r\n          // If the user is attempting to click selection back onto text, then\r\n          // we should attempt create a range selection.\r\n          // When we click on an empty paragraph node or the end of a paragraph that ends\r\n          // with an image/poll, the nodeType will be ELEMENT_NODE\r\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\r\n            const newSelection = internalCreateRangeSelection(lastSelection, domSelection, editor, event);\r\n            $setSelection(newSelection);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    dispatchCommand(editor, CLICK_COMMAND, event);\r\n  });\r\n}\r\nfunction onPointerDown(event, editor) {\r\n  // TODO implement text drag & drop\r\n  const target = event.target;\r\n  const pointerType = event.pointerType;\r\n  if (target instanceof Node && pointerType !== 'touch') {\r\n    updateEditor(editor, () => {\r\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\r\n      // selected content is lost.\r\n      if (!$isSelectionCapturedInDecorator(target)) {\r\n        isSelectionChangeFromMouseDown = true;\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction getTargetRange(event) {\r\n  if (!event.getTargetRanges) {\r\n    return null;\r\n  }\r\n  const targetRanges = event.getTargetRanges();\r\n  if (targetRanges.length === 0) {\r\n    return null;\r\n  }\r\n  return targetRanges[0];\r\n}\r\nfunction $canRemoveText(anchorNode, focusNode) {\r\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\r\n}\r\nfunction isPossiblyAndroidKeyPress(timeStamp) {\r\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\r\n}\r\nfunction onBeforeInput(event, editor) {\r\n  const inputType = event.inputType;\r\n  const targetRange = getTargetRange(event);\r\n\r\n  // We let the browser do its own thing for composition.\r\n  if (inputType === 'deleteCompositionText' ||\r\n  // If we're pasting in FF, we shouldn't get this event\r\n  // as the `paste` event should have triggered, unless the\r\n  // user has dom.event.clipboardevents.enabled disabled in\r\n  // about:config. In that case, we need to process the\r\n  // pasted content in the DOM mutation phase.\r\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\r\n    return;\r\n  } else if (inputType === 'insertCompositionText') {\r\n    return;\r\n  }\r\n  updateEditor(editor, () => {\r\n    const selection = $getSelection();\r\n    if (inputType === 'deleteContentBackward') {\r\n      if (selection === null) {\r\n        // Use previous selection\r\n        const prevSelection = $getPreviousSelection();\r\n        if (!$isRangeSelection(prevSelection)) {\r\n          return;\r\n        }\r\n        $setSelection(prevSelection.clone());\r\n      }\r\n      if ($isRangeSelection(selection)) {\r\n        // Used for handling backspace in Android.\r\n        if (IS_ANDROID) {\r\n          $setCompositionKey(selection.anchor.key);\r\n        }\r\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {\r\n          $setCompositionKey(null);\r\n          lastKeyDownTimeStamp = 0;\r\n          // Fixes an Android bug where selection flickers when backspacing\r\n          setTimeout(() => {\r\n            updateEditor(editor, () => {\r\n              $setCompositionKey(null);\r\n            });\r\n          }, ANDROID_COMPOSITION_LATENCY);\r\n          if ($isRangeSelection(selection)) {\r\n            const anchorNode = selection.anchor.getNode();\r\n            anchorNode.markDirty();\r\n            selection.format = anchorNode.getFormat();\r\n            if (!$isTextNode(anchorNode)) {\r\n              throw Error(`Anchor node must be a TextNode`);\r\n            }\r\n            selection.style = anchorNode.getStyle();\r\n          }\r\n          const selectedText = selection.anchor.getNode().getTextContent();\r\n          if (selectedText.length <= 1) {\r\n            event.preventDefault();\r\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\r\n          }\r\n        } else {\r\n          $setCompositionKey(null);\r\n          event.preventDefault();\r\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    if (!$isRangeSelection(selection)) {\r\n      return;\r\n    }\r\n    const data = event.data;\r\n\r\n    // This represents the case when two beforeinput events are triggered at the same time (without a\r\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\r\n    // a combination of autocorrection + autocapitalization.\r\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\r\n    // but this would kill the massive performance win from the most common typing event.\r\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\r\n    // content, a job that would usually be the input event's responsibility.\r\n    if (unprocessedBeforeInputData !== null) {\r\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\r\n    }\r\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\r\n      selection.applyDOMRange(targetRange);\r\n    }\r\n    unprocessedBeforeInputData = null;\r\n    const anchor = selection.anchor;\r\n    const focus = selection.focus;\r\n    const anchorNode = anchor.getNode();\r\n    const focusNode = focus.getNode();\r\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\r\n      if (data === '\\n') {\r\n        event.preventDefault();\r\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\r\n      } else if (data === DOUBLE_LINE_BREAK) {\r\n        event.preventDefault();\r\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\r\n      } else if (data == null && event.dataTransfer) {\r\n        // Gets around a Safari text replacement bug.\r\n        const text = event.dataTransfer.getData('text/plain');\r\n        event.preventDefault();\r\n        selection.insertRawText(text);\r\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\r\n        event.preventDefault();\r\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\r\n      } else {\r\n        unprocessedBeforeInputData = data;\r\n      }\r\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\r\n      return;\r\n    }\r\n\r\n    // Prevent the browser from carrying out\r\n    // the input event, so we can control the\r\n    // output.\r\n    event.preventDefault();\r\n    switch (inputType) {\r\n      case 'insertFromYank':\r\n      case 'insertFromDrop':\r\n      case 'insertReplacementText':\r\n        {\r\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\r\n          break;\r\n        }\r\n      case 'insertFromComposition':\r\n        {\r\n          // This is the end of composition\r\n          $setCompositionKey(null);\r\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\r\n          break;\r\n        }\r\n      case 'insertLineBreak':\r\n        {\r\n          // Used for Android\r\n          $setCompositionKey(null);\r\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\r\n          break;\r\n        }\r\n      case 'insertParagraph':\r\n        {\r\n          // Used for Android\r\n          $setCompositionKey(null);\r\n\r\n          // Safari does not provide the type \"insertLineBreak\".\r\n          // So instead, we need to infer it from the keyboard event.\r\n          // We do not apply this logic to iOS to allow newline auto-capitalization\r\n          // work without creating linebreaks when pressing Enter\r\n          if (isInsertLineBreak && !IS_IOS) {\r\n            isInsertLineBreak = false;\r\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\r\n          } else {\r\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\r\n          }\r\n          break;\r\n        }\r\n      case 'insertFromPaste':\r\n      case 'insertFromPasteAsQuotation':\r\n        {\r\n          dispatchCommand(editor, PASTE_COMMAND, event);\r\n          break;\r\n        }\r\n      case 'deleteByComposition':\r\n        {\r\n          if ($canRemoveText(anchorNode, focusNode)) {\r\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\r\n          }\r\n          break;\r\n        }\r\n      case 'deleteByDrag':\r\n      case 'deleteByCut':\r\n        {\r\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\r\n          break;\r\n        }\r\n      case 'deleteContent':\r\n        {\r\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\r\n          break;\r\n        }\r\n      case 'deleteWordBackward':\r\n        {\r\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\r\n          break;\r\n        }\r\n      case 'deleteWordForward':\r\n        {\r\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\r\n          break;\r\n        }\r\n      case 'deleteHardLineBackward':\r\n      case 'deleteSoftLineBackward':\r\n        {\r\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\r\n          break;\r\n        }\r\n      case 'deleteContentForward':\r\n      case 'deleteHardLineForward':\r\n      case 'deleteSoftLineForward':\r\n        {\r\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\r\n          break;\r\n        }\r\n      case 'formatStrikeThrough':\r\n        {\r\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\r\n          break;\r\n        }\r\n      case 'formatBold':\r\n        {\r\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\r\n          break;\r\n        }\r\n      case 'formatItalic':\r\n        {\r\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\r\n          break;\r\n        }\r\n      case 'formatUnderline':\r\n        {\r\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\r\n          break;\r\n        }\r\n      case 'historyUndo':\r\n        {\r\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\r\n          break;\r\n        }\r\n      case 'historyRedo':\r\n        {\r\n          dispatchCommand(editor, REDO_COMMAND, undefined);\r\n          break;\r\n        }\r\n      // NO-OP\r\n    }\r\n  });\r\n}\r\n\r\nfunction onInput(event, editor) {\r\n  // We don't want the onInput to bubble, in the case of nested editors.\r\n  event.stopPropagation();\r\n  updateEditor(editor, () => {\r\n    const selection = $getSelection();\r\n    const data = event.data;\r\n    const targetRange = getTargetRange(event);\r\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\r\n      // Given we're over-riding the default behavior, we will need\r\n      // to ensure to disable composition before dispatching the\r\n      // insertText command for when changing the sequence for FF.\r\n      if (isFirefoxEndingComposition) {\r\n        onCompositionEndImpl(editor, data);\r\n        isFirefoxEndingComposition = false;\r\n      }\r\n      const anchor = selection.anchor;\r\n      const anchorNode = anchor.getNode();\r\n      const domSelection = getDOMSelection(editor._window);\r\n      if (domSelection === null) {\r\n        return;\r\n      }\r\n      const offset = anchor.offset;\r\n      // If the content is the same as inserted, then don't dispatch an insertion.\r\n      // Given onInput doesn't take the current selection (it uses the previous)\r\n      // we can compare that against what the DOM currently says.\r\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\r\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\r\n      }\r\n      const textLength = data.length;\r\n\r\n      // Another hack for FF, as it's possible that the IME is still\r\n      // open, even though compositionend has already fired (sigh).\r\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\r\n        selection.anchor.offset -= textLength;\r\n      }\r\n\r\n      // This ensures consistency on Android.\r\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\r\n        lastKeyDownTimeStamp = 0;\r\n        $setCompositionKey(null);\r\n      }\r\n    } else {\r\n      const characterData = data !== null ? data : undefined;\r\n      $updateSelectedTextFromDOM(false, editor, characterData);\r\n\r\n      // onInput always fires after onCompositionEnd for FF.\r\n      if (isFirefoxEndingComposition) {\r\n        onCompositionEndImpl(editor, data || undefined);\r\n        isFirefoxEndingComposition = false;\r\n      }\r\n    }\r\n\r\n    // Also flush any other mutations that might have occurred\r\n    // since the change.\r\n    $flushMutations();\r\n  });\r\n  unprocessedBeforeInputData = null;\r\n}\r\nfunction onCompositionStart(event, editor) {\r\n  updateEditor(editor, () => {\r\n    const selection = $getSelection();\r\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\r\n      const anchor = selection.anchor;\r\n      const node = selection.anchor.getNode();\r\n      $setCompositionKey(anchor.key);\r\n      if (\r\n      // If it has been 30ms since the last keydown, then we should\r\n      // apply the empty space heuristic. We can't do this for Safari,\r\n      // as the keydown fires after composition start.\r\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\r\n      // FF has issues around composing multibyte characters, so we also\r\n      // need to invoke the empty space heuristic below.\r\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\r\n        // We insert a zero width character, ready for the composition\r\n        // to get inserted into the new node we create. If\r\n        // we don't do this, Safari will fail on us because\r\n        // there is no text node matching the selection.\r\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\r\n      }\r\n    }\r\n  });\r\n}\r\nfunction onCompositionEndImpl(editor, data) {\r\n  const compositionKey = editor._compositionKey;\r\n  $setCompositionKey(null);\r\n\r\n  // Handle termination of composition.\r\n  if (compositionKey !== null && data != null) {\r\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\r\n    // So check for the empty case.\r\n    if (data === '') {\r\n      const node = $getNodeByKey(compositionKey);\r\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\r\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\r\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Composition can sometimes be that of a new line. In which case, we need to\r\n    // handle that accordingly.\r\n    if (data[data.length - 1] === '\\n') {\r\n      const selection = $getSelection();\r\n      if ($isRangeSelection(selection)) {\r\n        // If the last character is a line break, we also need to insert\r\n        // a line break.\r\n        const focus = selection.focus;\r\n        selection.anchor.set(focus.key, focus.offset, focus.type);\r\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  $updateSelectedTextFromDOM(true, editor, data);\r\n}\r\nfunction onCompositionEnd(event, editor) {\r\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\r\n  // fire onInput before onCompositionEnd. To ensure the sequence works\r\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\r\n  // defer handling of onCompositionEnd in Firefox till we have processed\r\n  // the logic in onInput.\r\n  if (IS_FIREFOX) {\r\n    isFirefoxEndingComposition = true;\r\n  } else {\r\n    updateEditor(editor, () => {\r\n      onCompositionEndImpl(editor, event.data);\r\n    });\r\n  }\r\n}\r\nfunction onKeyDown(event, editor) {\r\n  lastKeyDownTimeStamp = event.timeStamp;\r\n  lastKeyCode = event.keyCode;\r\n  if (editor.isComposing()) {\r\n    return;\r\n  }\r\n  const {\r\n    keyCode,\r\n    shiftKey,\r\n    ctrlKey,\r\n    metaKey,\r\n    altKey\r\n  } = event;\r\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\r\n    return;\r\n  }\r\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\r\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\r\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\r\n    dispatchCommand(editor, MOVE_TO_END, event);\r\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\r\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\r\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\r\n    dispatchCommand(editor, MOVE_TO_START, event);\r\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\r\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\r\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\r\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\r\n  } else if (isLineBreak(keyCode, shiftKey)) {\r\n    isInsertLineBreak = true;\r\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\r\n  } else if (isSpace(keyCode)) {\r\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\r\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\r\n    event.preventDefault();\r\n    isInsertLineBreak = true;\r\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\r\n  } else if (isParagraph(keyCode, shiftKey)) {\r\n    isInsertLineBreak = false;\r\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\r\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\r\n    if (isBackspace(keyCode)) {\r\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\r\n    } else {\r\n      event.preventDefault();\r\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\r\n    }\r\n  } else if (isEscape(keyCode)) {\r\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\r\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\r\n    if (isDelete(keyCode)) {\r\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\r\n    } else {\r\n      event.preventDefault();\r\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\r\n    }\r\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\r\n    event.preventDefault();\r\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\r\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\r\n    event.preventDefault();\r\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\r\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\r\n    event.preventDefault();\r\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\r\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\r\n    event.preventDefault();\r\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\r\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\r\n    event.preventDefault();\r\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\r\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\r\n    event.preventDefault();\r\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\r\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\r\n    event.preventDefault();\r\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\r\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\r\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\r\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\r\n    event.preventDefault();\r\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\r\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\r\n    event.preventDefault();\r\n    dispatchCommand(editor, REDO_COMMAND, undefined);\r\n  } else {\r\n    const prevSelection = editor._editorState._selection;\r\n    if ($isNodeSelection(prevSelection)) {\r\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\r\n        event.preventDefault();\r\n        dispatchCommand(editor, COPY_COMMAND, event);\r\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\r\n        event.preventDefault();\r\n        dispatchCommand(editor, CUT_COMMAND, event);\r\n      } else if (isSelectAll(keyCode, metaKey, ctrlKey)) {\r\n        event.preventDefault();\r\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\r\n      }\r\n      // FF does it well (no need to override behavior)\r\n    } else if (!IS_FIREFOX && isSelectAll(keyCode, metaKey, ctrlKey)) {\r\n      event.preventDefault();\r\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\r\n    }\r\n  }\r\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\r\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\r\n  }\r\n}\r\nfunction getRootElementRemoveHandles(rootElement) {\r\n  // @ts-expect-error: internal field\r\n  let eventHandles = rootElement.__lexicalEventHandles;\r\n  if (eventHandles === undefined) {\r\n    eventHandles = [];\r\n    // @ts-expect-error: internal field\r\n    rootElement.__lexicalEventHandles = eventHandles;\r\n  }\r\n  return eventHandles;\r\n}\r\n\r\n// Mapping root editors to their active nested editors, contains nested editors\r\n// mapping only, so if root editor is selected map will have no reference to free up memory\r\nconst activeNestedEditorsMap = new Map();\r\nfunction onDocumentSelectionChange(event) {\r\n  const target = event.target;\r\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\r\n  const domSelection = getDOMSelection(targetWindow);\r\n  if (domSelection === null) {\r\n    return;\r\n  }\r\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\r\n  if (nextActiveEditor === null) {\r\n    return;\r\n  }\r\n  if (isSelectionChangeFromMouseDown) {\r\n    isSelectionChangeFromMouseDown = false;\r\n    updateEditor(nextActiveEditor, () => {\r\n      const lastSelection = $getPreviousSelection();\r\n      const domAnchorNode = domSelection.anchorNode;\r\n      if (domAnchorNode === null) {\r\n        return;\r\n      }\r\n      const nodeType = domAnchorNode.nodeType;\r\n      // If the user is attempting to click selection back onto text, then\r\n      // we should attempt create a range selection.\r\n      // When we click on an empty paragraph node or the end of a paragraph that ends\r\n      // with an image/poll, the nodeType will be ELEMENT_NODE\r\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\r\n        return;\r\n      }\r\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\r\n      $setSelection(newSelection);\r\n    });\r\n  }\r\n\r\n  // When editor receives selection change event, we're checking if\r\n  // it has any sibling editors (within same parent editor) that were active\r\n  // before, and trigger selection change on it to nullify selection.\r\n  const editors = getEditorsToPropagate(nextActiveEditor);\r\n  const rootEditor = editors[editors.length - 1];\r\n  const rootEditorKey = rootEditor._key;\r\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\r\n  const prevActiveEditor = activeNestedEditor || rootEditor;\r\n  if (prevActiveEditor !== nextActiveEditor) {\r\n    onSelectionChange(domSelection, prevActiveEditor, false);\r\n  }\r\n  onSelectionChange(domSelection, nextActiveEditor, true);\r\n\r\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\r\n  if (nextActiveEditor !== rootEditor) {\r\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\r\n  } else if (activeNestedEditor) {\r\n    activeNestedEditorsMap.delete(rootEditorKey);\r\n  }\r\n}\r\nfunction stopLexicalPropagation(event) {\r\n  // We attach a special property to ensure the same event doesn't re-fire\r\n  // for parent editors.\r\n  // @ts-ignore\r\n  event._lexicalHandled = true;\r\n}\r\nfunction hasStoppedLexicalPropagation(event) {\r\n  // @ts-ignore\r\n  const stopped = event._lexicalHandled === true;\r\n  return stopped;\r\n}\r\nfunction addRootElementEvents(rootElement, editor) {\r\n  // We only want to have a single global selectionchange event handler, shared\r\n  // between all editor instances.\r\n  if (rootElementsRegistered === 0) {\r\n    const doc = rootElement.ownerDocument;\r\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\r\n  }\r\n  rootElementsRegistered++;\r\n  // @ts-expect-error: internal field\r\n  rootElement.__lexicalEditor = editor;\r\n  const removeHandles = getRootElementRemoveHandles(rootElement);\r\n  for (let i = 0; i < rootElementEvents.length; i++) {\r\n    const [eventName, onEvent] = rootElementEvents[i];\r\n    const eventHandler = typeof onEvent === 'function' ? event => {\r\n      if (hasStoppedLexicalPropagation(event)) {\r\n        return;\r\n      }\r\n      stopLexicalPropagation(event);\r\n      if (editor.isEditable()) {\r\n        onEvent(event, editor);\r\n      }\r\n    } : event => {\r\n      if (hasStoppedLexicalPropagation(event)) {\r\n        return;\r\n      }\r\n      stopLexicalPropagation(event);\r\n      if (editor.isEditable()) {\r\n        switch (eventName) {\r\n          case 'cut':\r\n            return dispatchCommand(editor, CUT_COMMAND, event);\r\n          case 'copy':\r\n            return dispatchCommand(editor, COPY_COMMAND, event);\r\n          case 'paste':\r\n            return dispatchCommand(editor, PASTE_COMMAND, event);\r\n          case 'dragstart':\r\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\r\n          case 'dragover':\r\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\r\n          case 'dragend':\r\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\r\n          case 'focus':\r\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\r\n          case 'blur':\r\n            {\r\n              return dispatchCommand(editor, BLUR_COMMAND, event);\r\n            }\r\n          case 'drop':\r\n            return dispatchCommand(editor, DROP_COMMAND, event);\r\n        }\r\n      }\r\n    };\r\n    rootElement.addEventListener(eventName, eventHandler);\r\n    removeHandles.push(() => {\r\n      rootElement.removeEventListener(eventName, eventHandler);\r\n    });\r\n  }\r\n}\r\nfunction removeRootElementEvents(rootElement) {\r\n  if (rootElementsRegistered !== 0) {\r\n    rootElementsRegistered--;\r\n\r\n    // We only want to have a single global selectionchange event handler, shared\r\n    // between all editor instances.\r\n    if (rootElementsRegistered === 0) {\r\n      const doc = rootElement.ownerDocument;\r\n      doc.removeEventListener('selectionchange', onDocumentSelectionChange);\r\n    }\r\n  }\r\n\r\n  // @ts-expect-error: internal field\r\n  const editor = rootElement.__lexicalEditor;\r\n  if (editor !== null && editor !== undefined) {\r\n    cleanActiveNestedEditorsMap(editor);\r\n    // @ts-expect-error: internal field\r\n    rootElement.__lexicalEditor = null;\r\n  }\r\n  const removeHandles = getRootElementRemoveHandles(rootElement);\r\n  for (let i = 0; i < removeHandles.length; i++) {\r\n    removeHandles[i]();\r\n  }\r\n\r\n  // @ts-expect-error: internal field\r\n  rootElement.__lexicalEventHandles = [];\r\n}\r\nfunction cleanActiveNestedEditorsMap(editor) {\r\n  if (editor._parentEditor !== null) {\r\n    // For nested editor cleanup map if this editor was marked as active\r\n    const editors = getEditorsToPropagate(editor);\r\n    const rootEditor = editors[editors.length - 1];\r\n    const rootEditorKey = rootEditor._key;\r\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\r\n      activeNestedEditorsMap.delete(rootEditorKey);\r\n    }\r\n  } else {\r\n    // For top-level editors cleanup map\r\n    activeNestedEditorsMap.delete(editor._key);\r\n  }\r\n}\r\nfunction markSelectionChangeFromDOMUpdate() {\r\n  isSelectionChangeFromDOMUpdate = true;\r\n}\r\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\r\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\r\n  errorOnReadOnly();\r\n  const key = nodeToRemove.__key;\r\n  const parent = nodeToRemove.getParent();\r\n  if (parent === null) {\r\n    return;\r\n  }\r\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\r\n  let selectionMoved = false;\r\n  if ($isRangeSelection(selection) && restoreSelection) {\r\n    const anchor = selection.anchor;\r\n    const focus = selection.focus;\r\n    if (anchor.key === key) {\r\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\r\n      selectionMoved = true;\r\n    }\r\n    if (focus.key === key) {\r\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\r\n      selectionMoved = true;\r\n    }\r\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\r\n    nodeToRemove.selectPrevious();\r\n  }\r\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\r\n    // Doing this is O(n) so lets avoid it unless we need to do it\r\n    const index = nodeToRemove.getIndexWithinParent();\r\n    removeFromParent(nodeToRemove);\r\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\r\n  } else {\r\n    removeFromParent(nodeToRemove);\r\n  }\r\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\r\n    removeNode(parent, restoreSelection);\r\n  }\r\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\r\n    parent.selectEnd();\r\n  }\r\n}\r\nclass LexicalNode {\r\n  // Allow us to look up the type including static props\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */ //@ts-ignore We set the key in the constructor.\r\n  /** @internal */\r\n  /** @internal */\r\n  /** @internal */\r\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\r\n  // subclasses of Node to implement statics. All subclasses of Node should have\r\n  // a static getType and clone method though. We define getType and clone here so we can call it\r\n  // on any  Node, and we throw this error by default since the subclass should provide\r\n  // their own implementation.\r\n  /**\r\n   * Returns the string type of this node. Every node must\r\n   * implement this and it MUST BE UNIQUE amongst nodes registered\r\n   * on the editor.\r\n   *\r\n   */\r\n  static getType() {\r\n    {\r\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clones this node, creating a new node with a different key\r\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\r\n   * implement this method.\r\n   *\r\n   */\r\n  static clone(_data) {\r\n    {\r\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\r\n  constructor(key) {\r\n    this.__type = this.constructor.getType();\r\n    this.__parent = null;\r\n    this.__prev = null;\r\n    this.__next = null;\r\n    $setNodeKey(this, key);\r\n    {\r\n      if (this.__type !== 'root') {\r\n        errorOnReadOnly();\r\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\r\n      }\r\n    }\r\n  }\r\n  // Getters and Traversers\r\n\r\n  /**\r\n   * Returns the string type of this node.\r\n   */\r\n  getType() {\r\n    return this.__type;\r\n  }\r\n  isInline() {\r\n    {\r\n      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\r\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\r\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\r\n   */\r\n  isAttached() {\r\n    let nodeKey = this.__key;\r\n    while (nodeKey !== null) {\r\n      if (nodeKey === 'root') {\r\n        return true;\r\n      }\r\n      const node = $getNodeByKey(nodeKey);\r\n      if (node === null) {\r\n        break;\r\n      }\r\n      nodeKey = node.__parent;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this node is contained within the provided Selection., false otherwise.\r\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\r\n   * what's included.\r\n   *\r\n   * @param selection - The selection that we want to determine if the node is in.\r\n   */\r\n  isSelected(selection) {\r\n    const targetSelection = selection || $getSelection();\r\n    if (targetSelection == null) {\r\n      return false;\r\n    }\r\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\r\n    if ($isTextNode(this)) {\r\n      return isSelected;\r\n    }\r\n    // For inline images inside of element nodes.\r\n    // Without this change the image will be selected if the cursor is before or after it.\r\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\r\n      return false;\r\n    }\r\n    return isSelected;\r\n  }\r\n\r\n  /**\r\n   * Returns this nodes key.\r\n   */\r\n  getKey() {\r\n    // Key is stable between copies\r\n    return this.__key;\r\n  }\r\n\r\n  /**\r\n   * Returns the zero-based index of this node within the parent.\r\n   */\r\n  getIndexWithinParent() {\r\n    const parent = this.getParent();\r\n    if (parent === null) {\r\n      return -1;\r\n    }\r\n    let node = parent.getFirstChild();\r\n    let index = 0;\r\n    while (node !== null) {\r\n      if (this.is(node)) {\r\n        return index;\r\n      }\r\n      index++;\r\n      node = node.getNextSibling();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Returns the parent of this node, or null if none is found.\r\n   */\r\n  getParent() {\r\n    const parent = this.getLatest().__parent;\r\n    if (parent === null) {\r\n      return null;\r\n    }\r\n    return $getNodeByKey(parent);\r\n  }\r\n\r\n  /**\r\n   * Returns the parent of this node, or throws if none is found.\r\n   */\r\n  getParentOrThrow() {\r\n    const parent = this.getParent();\r\n    if (parent === null) {\r\n      {\r\n        throw Error(`Expected node ${this.__key} to have a parent.`);\r\n      }\r\n    }\r\n    return parent;\r\n  }\r\n\r\n  /**\r\n   * Returns the highest (in the EditorState tree)\r\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\r\n   * for more information on which Elements comprise \"roots\".\r\n   */\r\n  getTopLevelElement() {\r\n    let node = this;\r\n    while (node !== null) {\r\n      const parent = node.getParent();\r\n      if ($isRootOrShadowRoot(parent)) {\r\n        if (!$isElementNode(node)) {\r\n          throw Error(`Children of root nodes must be elements`);\r\n        }\r\n        return node;\r\n      }\r\n      node = parent;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns the highest (in the EditorState tree)\r\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\r\n   * for more information on which Elements comprise \"roots\".\r\n   */\r\n  getTopLevelElementOrThrow() {\r\n    const parent = this.getTopLevelElement();\r\n    if (parent === null) {\r\n      {\r\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\r\n      }\r\n    }\r\n    return parent;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of the every ancestor of this node,\r\n   * all the way up to the RootNode.\r\n   *\r\n   */\r\n  getParents() {\r\n    const parents = [];\r\n    let node = this.getParent();\r\n    while (node !== null) {\r\n      parents.push(node);\r\n      node = node.getParent();\r\n    }\r\n    return parents;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of the keys of every ancestor of this node,\r\n   * all the way up to the RootNode.\r\n   *\r\n   */\r\n  getParentKeys() {\r\n    const parents = [];\r\n    let node = this.getParent();\r\n    while (node !== null) {\r\n      parents.push(node.__key);\r\n      node = node.getParent();\r\n    }\r\n    return parents;\r\n  }\r\n\r\n  /**\r\n   * Returns the \"previous\" siblings - that is, the node that comes\r\n   * before this one in the same parent.\r\n   *\r\n   */\r\n  getPreviousSibling() {\r\n    const self = this.getLatest();\r\n    const prevKey = self.__prev;\r\n    return prevKey === null ? null : $getNodeByKey(prevKey);\r\n  }\r\n\r\n  /**\r\n   * Returns the \"previous\" siblings - that is, the nodes that come between\r\n   * this one and the first child of it's parent, inclusive.\r\n   *\r\n   */\r\n  getPreviousSiblings() {\r\n    const siblings = [];\r\n    const parent = this.getParent();\r\n    if (parent === null) {\r\n      return siblings;\r\n    }\r\n    let node = parent.getFirstChild();\r\n    while (node !== null) {\r\n      if (node.is(this)) {\r\n        break;\r\n      }\r\n      siblings.push(node);\r\n      node = node.getNextSibling();\r\n    }\r\n    return siblings;\r\n  }\r\n\r\n  /**\r\n   * Returns the \"next\" siblings - that is, the node that comes\r\n   * after this one in the same parent\r\n   *\r\n   */\r\n  getNextSibling() {\r\n    const self = this.getLatest();\r\n    const nextKey = self.__next;\r\n    return nextKey === null ? null : $getNodeByKey(nextKey);\r\n  }\r\n\r\n  /**\r\n   * Returns all \"next\" siblings - that is, the nodes that come between this\r\n   * one and the last child of it's parent, inclusive.\r\n   *\r\n   */\r\n  getNextSiblings() {\r\n    const siblings = [];\r\n    let node = this.getNextSibling();\r\n    while (node !== null) {\r\n      siblings.push(node);\r\n      node = node.getNextSibling();\r\n    }\r\n    return siblings;\r\n  }\r\n\r\n  /**\r\n   * Returns the closest common ancestor of this node and the provided one or null\r\n   * if one cannot be found.\r\n   *\r\n   * @param node - the other node to find the common ancestor of.\r\n   */\r\n  getCommonAncestor(node) {\r\n    const a = this.getParents();\r\n    const b = node.getParents();\r\n    if ($isElementNode(this)) {\r\n      a.unshift(this);\r\n    }\r\n    if ($isElementNode(node)) {\r\n      b.unshift(node);\r\n    }\r\n    const aLength = a.length;\r\n    const bLength = b.length;\r\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\r\n      return null;\r\n    }\r\n    const bSet = new Set(b);\r\n    for (let i = 0; i < aLength; i++) {\r\n      const ancestor = a[i];\r\n      if (bSet.has(ancestor)) {\r\n        return ancestor;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\r\n   * Always use this instead of referential equality.\r\n   *\r\n   * @param object - the node to perform the equality comparison on.\r\n   */\r\n  is(object) {\r\n    if (object == null) {\r\n      return false;\r\n    }\r\n    return this.__key === object.__key;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this node logical precedes the target node in the editor state.\r\n   *\r\n   * @param targetNode - the node we're testing to see if it's after this one.\r\n   */\r\n  isBefore(targetNode) {\r\n    if (this === targetNode) {\r\n      return false;\r\n    }\r\n    if (targetNode.isParentOf(this)) {\r\n      return true;\r\n    }\r\n    if (this.isParentOf(targetNode)) {\r\n      return false;\r\n    }\r\n    const commonAncestor = this.getCommonAncestor(targetNode);\r\n    let indexA = 0;\r\n    let indexB = 0;\r\n    let node = this;\r\n    while (true) {\r\n      const parent = node.getParentOrThrow();\r\n      if (parent === commonAncestor) {\r\n        indexA = node.getIndexWithinParent();\r\n        break;\r\n      }\r\n      node = parent;\r\n    }\r\n    node = targetNode;\r\n    while (true) {\r\n      const parent = node.getParentOrThrow();\r\n      if (parent === commonAncestor) {\r\n        indexB = node.getIndexWithinParent();\r\n        break;\r\n      }\r\n      node = parent;\r\n    }\r\n    return indexA < indexB;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this node is the parent of the target node, false otherwise.\r\n   *\r\n   * @param targetNode - the would-be child node.\r\n   */\r\n  isParentOf(targetNode) {\r\n    const key = this.__key;\r\n    if (key === targetNode.__key) {\r\n      return false;\r\n    }\r\n    let node = targetNode;\r\n    while (node !== null) {\r\n      if (node.__key === key) {\r\n        return true;\r\n      }\r\n      node = node.getParent();\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // TO-DO: this function can be simplified a lot\r\n  /**\r\n   * Returns a list of nodes that are between this node and\r\n   * the target node in the EditorState.\r\n   *\r\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\r\n   */\r\n  getNodesBetween(targetNode) {\r\n    const isBefore = this.isBefore(targetNode);\r\n    const nodes = [];\r\n    const visited = new Set();\r\n    let node = this;\r\n    while (true) {\r\n      const key = node.__key;\r\n      if (!visited.has(key)) {\r\n        visited.add(key);\r\n        nodes.push(node);\r\n      }\r\n      if (node === targetNode) {\r\n        break;\r\n      }\r\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\r\n      if (child !== null) {\r\n        node = child;\r\n        continue;\r\n      }\r\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\r\n      if (nextSibling !== null) {\r\n        node = nextSibling;\r\n        continue;\r\n      }\r\n      const parent = node.getParentOrThrow();\r\n      if (!visited.has(parent.__key)) {\r\n        nodes.push(parent);\r\n      }\r\n      if (parent === targetNode) {\r\n        break;\r\n      }\r\n      let parentSibling = null;\r\n      let ancestor = parent;\r\n      do {\r\n        if (ancestor === null) {\r\n          {\r\n            throw Error(`getNodesBetween: ancestor is null`);\r\n          }\r\n        }\r\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\r\n        ancestor = ancestor.getParent();\r\n        if (ancestor !== null) {\r\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\r\n            nodes.push(ancestor);\r\n          }\r\n        }\r\n      } while (parentSibling === null);\r\n      node = parentSibling;\r\n    }\r\n    if (!isBefore) {\r\n      nodes.reverse();\r\n    }\r\n    return nodes;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this node has been marked dirty during this update cycle.\r\n   *\r\n   */\r\n  isDirty() {\r\n    const editor = getActiveEditor();\r\n    const dirtyLeaves = editor._dirtyLeaves;\r\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\r\n  }\r\n\r\n  /**\r\n   * Returns the latest version of the node from the active EditorState.\r\n   * This is used to avoid getting values from stale node references.\r\n   *\r\n   */\r\n  getLatest() {\r\n    const latest = $getNodeByKey(this.__key);\r\n    if (latest === null) {\r\n      {\r\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\r\n      }\r\n    }\r\n    return latest;\r\n  }\r\n\r\n  /**\r\n   * Returns a mutable version of the node. Will throw an error if\r\n   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.\r\n   *\r\n   */\r\n  getWritable() {\r\n    errorOnReadOnly();\r\n    const editorState = getActiveEditorState();\r\n    const editor = getActiveEditor();\r\n    const nodeMap = editorState._nodeMap;\r\n    const key = this.__key;\r\n    // Ensure we get the latest node from pending state\r\n    const latestNode = this.getLatest();\r\n    const parent = latestNode.__parent;\r\n    const cloneNotNeeded = editor._cloneNotNeeded;\r\n    const selection = $getSelection();\r\n    if (selection !== null) {\r\n      selection.setCachedNodes(null);\r\n    }\r\n    if (cloneNotNeeded.has(key)) {\r\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\r\n      internalMarkNodeAsDirty(latestNode);\r\n      return latestNode;\r\n    }\r\n    const constructor = latestNode.constructor;\r\n    const mutableNode = constructor.clone(latestNode);\r\n    mutableNode.__parent = parent;\r\n    mutableNode.__next = latestNode.__next;\r\n    mutableNode.__prev = latestNode.__prev;\r\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\r\n      mutableNode.__first = latestNode.__first;\r\n      mutableNode.__last = latestNode.__last;\r\n      mutableNode.__size = latestNode.__size;\r\n      mutableNode.__indent = latestNode.__indent;\r\n      mutableNode.__format = latestNode.__format;\r\n      mutableNode.__dir = latestNode.__dir;\r\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\r\n      mutableNode.__format = latestNode.__format;\r\n      mutableNode.__style = latestNode.__style;\r\n      mutableNode.__mode = latestNode.__mode;\r\n      mutableNode.__detail = latestNode.__detail;\r\n    }\r\n    cloneNotNeeded.add(key);\r\n    mutableNode.__key = key;\r\n    internalMarkNodeAsDirty(mutableNode);\r\n    // Update reference in node map\r\n    nodeMap.set(key, mutableNode);\r\n\r\n    // @ts-expect-error\r\n    return mutableNode;\r\n  }\r\n\r\n  /**\r\n   * Returns the text content of the node. Override this for\r\n   * custom nodes that should have a representation in plain text\r\n   * format (for copy + paste, for example)\r\n   *\r\n   */\r\n  getTextContent() {\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Returns the length of the string produced by calling getTextContent on this node.\r\n   *\r\n   */\r\n  getTextContentSize() {\r\n    return this.getTextContent().length;\r\n  }\r\n\r\n  // View\r\n\r\n  /**\r\n   * Called during the reconciliation process to determine which nodes\r\n   * to insert into the DOM for this Lexical Node.\r\n   *\r\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\r\n   *\r\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\r\n   *\r\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\r\n   * @param _editor - allows access to the editor for context during reconciliation.\r\n   *\r\n   * */\r\n  createDOM(_config, _editor) {\r\n    {\r\n      throw Error(`createDOM: base method not extended`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when a node changes and should update the DOM\r\n   * in whatever way is necessary to make it align with any changes that might\r\n   * have happened during the update.\r\n   *\r\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\r\n   * (by calling createDOM). You would need to do this if the element tag changes,\r\n   * for instance.\r\n   *\r\n   * */\r\n  updateDOM(_prevNode, _dom, _config) {\r\n    {\r\n      throw Error(`updateDOM: base method not extended`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Controls how the this node is serialized to HTML. This is important for\r\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\r\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\r\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\r\n   * also use this method to build your own HTML renderer.\r\n   *\r\n   * */\r\n  exportDOM(editor) {\r\n    const element = this.createDOM(editor._config, editor);\r\n    return {\r\n      element\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Controls how the this node is serialized to JSON. This is important for\r\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\r\n   * if you're serializing to JSON for persistent storage somewhere.\r\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\r\n   *\r\n   * */\r\n  exportJSON() {\r\n    {\r\n      throw Error(`exportJSON: base method not extended`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\r\n   * but provides an abstraction between the node implementation and serialized interface that can\r\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\r\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\r\n   *\r\n   * */\r\n  static importJSON(_serializedNode) {\r\n    {\r\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\r\n    }\r\n  }\r\n  /**\r\n   * @experimental\r\n   *\r\n   * Registers the returned function as a transform on the node during\r\n   * Editor initialization. Most such use cases should be addressed via\r\n   * the {@link LexicalEditor.registerNodeTransform} API.\r\n   *\r\n   * Experimental - use at your own risk.\r\n   */\r\n  static transform() {\r\n    return null;\r\n  }\r\n\r\n  // Setters and mutators\r\n\r\n  /**\r\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\r\n   * somewhere, the Lexical garbage collector will eventually clean it up.\r\n   *\r\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\r\n   * it's empty after the removal operation. This is the default behavior, subject to\r\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\r\n   * */\r\n  remove(preserveEmptyParent) {\r\n    removeNode(this, true, preserveEmptyParent);\r\n  }\r\n\r\n  /**\r\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\r\n   * of the replaced node to the replacing node.\r\n   *\r\n   * @param replaceWith - The node to replace this one with.\r\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\r\n   * */\r\n  replace(replaceWith, includeChildren) {\r\n    errorOnReadOnly();\r\n    let selection = $getSelection();\r\n    if (selection !== null) selection = selection.clone();\r\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\r\n    const self = this.getLatest();\r\n    const toReplaceKey = this.__key;\r\n    const key = replaceWith.__key;\r\n    const writableReplaceWith = replaceWith.getWritable();\r\n    const writableParent = this.getParentOrThrow().getWritable();\r\n    const size = writableParent.__size;\r\n    removeFromParent(writableReplaceWith);\r\n    const prevSibling = self.getPreviousSibling();\r\n    const nextSibling = self.getNextSibling();\r\n    const prevKey = self.__prev;\r\n    const nextKey = self.__next;\r\n    const parentKey = self.__parent;\r\n    removeNode(self, false, true);\r\n    if (prevSibling === null) {\r\n      writableParent.__first = key;\r\n    } else {\r\n      const writablePrevSibling = prevSibling.getWritable();\r\n      writablePrevSibling.__next = key;\r\n    }\r\n    writableReplaceWith.__prev = prevKey;\r\n    if (nextSibling === null) {\r\n      writableParent.__last = key;\r\n    } else {\r\n      const writableNextSibling = nextSibling.getWritable();\r\n      writableNextSibling.__prev = key;\r\n    }\r\n    writableReplaceWith.__next = nextKey;\r\n    writableReplaceWith.__parent = parentKey;\r\n    writableParent.__size = size;\r\n    if (includeChildren) {\r\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\r\n        throw Error(`includeChildren should only be true for ElementNodes`);\r\n      }\r\n      this.getChildren().forEach(child => {\r\n        writableReplaceWith.append(child);\r\n      });\r\n    }\r\n    if ($isRangeSelection(selection)) {\r\n      $setSelection(selection);\r\n      const anchor = selection.anchor;\r\n      const focus = selection.focus;\r\n      if (anchor.key === toReplaceKey) {\r\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\r\n      }\r\n      if (focus.key === toReplaceKey) {\r\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\r\n      }\r\n    }\r\n    if ($getCompositionKey() === toReplaceKey) {\r\n      $setCompositionKey(key);\r\n    }\r\n    return writableReplaceWith;\r\n  }\r\n\r\n  /**\r\n   * Inserts a node after this LexicalNode (as the next sibling).\r\n   *\r\n   * @param nodeToInsert - The node to insert after this one.\r\n   * @param restoreSelection - Whether or not to attempt to resolve the\r\n   * selection to the appropriate place after the operation is complete.\r\n   * */\r\n  insertAfter(nodeToInsert, restoreSelection = true) {\r\n    errorOnReadOnly();\r\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\r\n    const writableSelf = this.getWritable();\r\n    const writableNodeToInsert = nodeToInsert.getWritable();\r\n    const oldParent = writableNodeToInsert.getParent();\r\n    const selection = $getSelection();\r\n    let elementAnchorSelectionOnNode = false;\r\n    let elementFocusSelectionOnNode = false;\r\n    if (oldParent !== null) {\r\n      // TODO: this is O(n), can we improve?\r\n      const oldIndex = nodeToInsert.getIndexWithinParent();\r\n      removeFromParent(writableNodeToInsert);\r\n      if ($isRangeSelection(selection)) {\r\n        const oldParentKey = oldParent.__key;\r\n        const anchor = selection.anchor;\r\n        const focus = selection.focus;\r\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\r\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\r\n      }\r\n    }\r\n    const nextSibling = this.getNextSibling();\r\n    const writableParent = this.getParentOrThrow().getWritable();\r\n    const insertKey = writableNodeToInsert.__key;\r\n    const nextKey = writableSelf.__next;\r\n    if (nextSibling === null) {\r\n      writableParent.__last = insertKey;\r\n    } else {\r\n      const writableNextSibling = nextSibling.getWritable();\r\n      writableNextSibling.__prev = insertKey;\r\n    }\r\n    writableParent.__size++;\r\n    writableSelf.__next = insertKey;\r\n    writableNodeToInsert.__next = nextKey;\r\n    writableNodeToInsert.__prev = writableSelf.__key;\r\n    writableNodeToInsert.__parent = writableSelf.__parent;\r\n    if (restoreSelection && $isRangeSelection(selection)) {\r\n      const index = this.getIndexWithinParent();\r\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\r\n      const writableParentKey = writableParent.__key;\r\n      if (elementAnchorSelectionOnNode) {\r\n        selection.anchor.set(writableParentKey, index + 2, 'element');\r\n      }\r\n      if (elementFocusSelectionOnNode) {\r\n        selection.focus.set(writableParentKey, index + 2, 'element');\r\n      }\r\n    }\r\n    return nodeToInsert;\r\n  }\r\n\r\n  /**\r\n   * Inserts a node before this LexicalNode (as the previous sibling).\r\n   *\r\n   * @param nodeToInsert - The node to insert before this one.\r\n   * @param restoreSelection - Whether or not to attempt to resolve the\r\n   * selection to the appropriate place after the operation is complete.\r\n   * */\r\n  insertBefore(nodeToInsert, restoreSelection = true) {\r\n    errorOnReadOnly();\r\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\r\n    const writableSelf = this.getWritable();\r\n    const writableNodeToInsert = nodeToInsert.getWritable();\r\n    const insertKey = writableNodeToInsert.__key;\r\n    removeFromParent(writableNodeToInsert);\r\n    const prevSibling = this.getPreviousSibling();\r\n    const writableParent = this.getParentOrThrow().getWritable();\r\n    const prevKey = writableSelf.__prev;\r\n    // TODO: this is O(n), can we improve?\r\n    const index = this.getIndexWithinParent();\r\n    if (prevSibling === null) {\r\n      writableParent.__first = insertKey;\r\n    } else {\r\n      const writablePrevSibling = prevSibling.getWritable();\r\n      writablePrevSibling.__next = insertKey;\r\n    }\r\n    writableParent.__size++;\r\n    writableSelf.__prev = insertKey;\r\n    writableNodeToInsert.__prev = prevKey;\r\n    writableNodeToInsert.__next = writableSelf.__key;\r\n    writableNodeToInsert.__parent = writableSelf.__parent;\r\n    const selection = $getSelection();\r\n    if (restoreSelection && $isRangeSelection(selection)) {\r\n      const parent = this.getParentOrThrow();\r\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\r\n    }\r\n    return nodeToInsert;\r\n  }\r\n\r\n  /**\r\n   * Whether or not this node has a required parent. Used during copy + paste operations\r\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\r\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\r\n   *\r\n   * */\r\n  isParentRequired() {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\r\n   *\r\n   * */\r\n  createParentElementNode() {\r\n    return $createParagraphNode();\r\n  }\r\n  selectStart() {\r\n    return this.selectPrevious();\r\n  }\r\n  selectEnd() {\r\n    return this.selectNext(0, 0);\r\n  }\r\n\r\n  /**\r\n   * Moves selection to the previous sibling of this node, at the specified offsets.\r\n   *\r\n   * @param anchorOffset - The anchor offset for selection.\r\n   * @param focusOffset -  The focus offset for selection\r\n   * */\r\n  selectPrevious(anchorOffset, focusOffset) {\r\n    errorOnReadOnly();\r\n    const prevSibling = this.getPreviousSibling();\r\n    const parent = this.getParentOrThrow();\r\n    if (prevSibling === null) {\r\n      return parent.select(0, 0);\r\n    }\r\n    if ($isElementNode(prevSibling)) {\r\n      return prevSibling.select();\r\n    } else if (!$isTextNode(prevSibling)) {\r\n      const index = prevSibling.getIndexWithinParent() + 1;\r\n      return parent.select(index, index);\r\n    }\r\n    return prevSibling.select(anchorOffset, focusOffset);\r\n  }\r\n\r\n  /**\r\n   * Moves selection to the next sibling of this node, at the specified offsets.\r\n   *\r\n   * @param anchorOffset - The anchor offset for selection.\r\n   * @param focusOffset -  The focus offset for selection\r\n   * */\r\n  selectNext(anchorOffset, focusOffset) {\r\n    errorOnReadOnly();\r\n    const nextSibling = this.getNextSibling();\r\n    const parent = this.getParentOrThrow();\r\n    if (nextSibling === null) {\r\n      return parent.select();\r\n    }\r\n    if ($isElementNode(nextSibling)) {\r\n      return nextSibling.select(0, 0);\r\n    } else if (!$isTextNode(nextSibling)) {\r\n      const index = nextSibling.getIndexWithinParent();\r\n      return parent.select(index, index);\r\n    }\r\n    return nextSibling.select(anchorOffset, focusOffset);\r\n  }\r\n\r\n  /**\r\n   * Marks a node dirty, triggering transforms and\r\n   * forcing it to be reconciled during the update cycle.\r\n   *\r\n   * */\r\n  markDirty() {\r\n    this.getWritable();\r\n  }\r\n}\r\nfunction errorOnTypeKlassMismatch(type, klass) {\r\n  const registeredNode = getActiveEditor()._nodes.get(type);\r\n  // Common error - split in its own invariant\r\n  if (registeredNode === undefined) {\r\n    {\r\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\r\n    }\r\n  }\r\n  const editorKlass = registeredNode.klass;\r\n  if (editorKlass !== klass) {\r\n    {\r\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Insert a series of nodes after this LexicalNode (as next siblings)\r\n *\r\n * @param firstToInsert - The first node to insert after this one.\r\n * @param lastToInsert - The last node to insert after this one. Must be a\r\n * later sibling of FirstNode. If not provided, it will be its last sibling.\r\n */\r\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\r\n  const lastToInsert2 = lastToInsert || firstToInsert.getParentOrThrow().getLastChild();\r\n  let current = firstToInsert;\r\n  const nodesToInsert = [firstToInsert];\r\n  while (current !== lastToInsert2) {\r\n    if (!current.getNextSibling()) {\r\n      {\r\n        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\r\n      }\r\n    }\r\n    current = current.getNextSibling();\r\n    nodesToInsert.push(current);\r\n  }\r\n  let currentNode = node;\r\n  for (const nodeToInsert of nodesToInsert) {\r\n    currentNode = currentNode.insertAfter(nodeToInsert);\r\n  }\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass LineBreakNode extends LexicalNode {\r\n  static getType() {\r\n    return 'linebreak';\r\n  }\r\n  static clone(node) {\r\n    return new LineBreakNode(node.__key);\r\n  }\r\n  constructor(key) {\r\n    super(key);\r\n  }\r\n  getTextContent() {\r\n    return '\\n';\r\n  }\r\n  createDOM() {\r\n    return document.createElement('br');\r\n  }\r\n  updateDOM() {\r\n    return false;\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      br: node => {\r\n        if (isOnlyChild(node)) {\r\n          return null;\r\n        }\r\n        return {\r\n          conversion: convertLineBreakElement,\r\n          priority: 0\r\n        };\r\n      }\r\n    };\r\n  }\r\n  static importJSON(serializedLineBreakNode) {\r\n    return $createLineBreakNode();\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      type: 'linebreak',\r\n      version: 1\r\n    };\r\n  }\r\n}\r\nfunction convertLineBreakElement(node) {\r\n  return {\r\n    node: $createLineBreakNode()\r\n  };\r\n}\r\nfunction $createLineBreakNode() {\r\n  return $applyNodeReplacement(new LineBreakNode());\r\n}\r\nfunction $isLineBreakNode(node) {\r\n  return node instanceof LineBreakNode;\r\n}\r\nfunction isOnlyChild(node) {\r\n  const parentElement = node.parentElement;\r\n  if (parentElement !== null) {\r\n    const firstChild = parentElement.firstChild;\r\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\r\n      const lastChild = parentElement.lastChild;\r\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\nfunction isWhitespaceDomTextNode(node) {\r\n  return node.nodeType === DOM_TEXT_TYPE && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction getElementOuterTag(node, format) {\r\n  if (format & IS_CODE) {\r\n    return 'code';\r\n  }\r\n  if (format & IS_HIGHLIGHT) {\r\n    return 'mark';\r\n  }\r\n  if (format & IS_SUBSCRIPT) {\r\n    return 'sub';\r\n  }\r\n  if (format & IS_SUPERSCRIPT) {\r\n    return 'sup';\r\n  }\r\n  return null;\r\n}\r\nfunction getElementInnerTag(node, format) {\r\n  if (format & IS_BOLD) {\r\n    return 'strong';\r\n  }\r\n  if (format & IS_ITALIC) {\r\n    return 'em';\r\n  }\r\n  return 'span';\r\n}\r\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\r\n  const domClassList = dom.classList;\r\n  // Firstly we handle the base theme.\r\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\r\n  if (classNames !== undefined) {\r\n    domClassList.add(...classNames);\r\n  }\r\n  // Secondly we handle the special case: underline + strikethrough.\r\n  // We have to do this as we need a way to compose the fact that\r\n  // the same CSS property will need to be used: text-decoration.\r\n  // In an ideal world we shouldn't have to do this, but there's no\r\n  // easy workaround for many atomic CSS systems today.\r\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\r\n  let hasUnderlineStrikethrough = false;\r\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\r\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\r\n  if (classNames !== undefined) {\r\n    if (nextUnderlineStrikethrough) {\r\n      hasUnderlineStrikethrough = true;\r\n      if (!prevUnderlineStrikethrough) {\r\n        domClassList.add(...classNames);\r\n      }\r\n    } else if (prevUnderlineStrikethrough) {\r\n      domClassList.remove(...classNames);\r\n    }\r\n  }\r\n  for (const key in TEXT_TYPE_TO_FORMAT) {\r\n    const format = key;\r\n    const flag = TEXT_TYPE_TO_FORMAT[format];\r\n    classNames = getCachedClassNameArray(textClassNames, key);\r\n    if (classNames !== undefined) {\r\n      if (nextFormat & flag) {\r\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\r\n          if (prevFormat & flag) {\r\n            domClassList.remove(...classNames);\r\n          }\r\n          continue;\r\n        }\r\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\r\n          domClassList.add(...classNames);\r\n        }\r\n      } else if (prevFormat & flag) {\r\n        domClassList.remove(...classNames);\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction diffComposedText(a, b) {\r\n  const aLength = a.length;\r\n  const bLength = b.length;\r\n  let left = 0;\r\n  let right = 0;\r\n  while (left < aLength && left < bLength && a[left] === b[left]) {\r\n    left++;\r\n  }\r\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\r\n    right++;\r\n  }\r\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\r\n}\r\nfunction setTextContent(nextText, dom, node) {\r\n  const firstChild = dom.firstChild;\r\n  const isComposing = node.isComposing();\r\n  // Always add a suffix if we're composing a node\r\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\r\n  const text = nextText + suffix;\r\n  if (firstChild == null) {\r\n    dom.textContent = text;\r\n  } else {\r\n    const nodeValue = firstChild.nodeValue;\r\n    if (nodeValue !== text) {\r\n      if (isComposing || IS_FIREFOX) {\r\n        // We also use the diff composed text for general text in FF to avoid\r\n        // the spellcheck red line from flickering.\r\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\r\n        if (remove !== 0) {\r\n          // @ts-expect-error\r\n          firstChild.deleteData(index, remove);\r\n        }\r\n        // @ts-expect-error\r\n        firstChild.insertData(index, insert);\r\n      } else {\r\n        firstChild.nodeValue = text;\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\r\n  setTextContent(text, innerDOM, node);\r\n  const theme = config.theme;\r\n  // Apply theme class names\r\n  const textClassNames = theme.text;\r\n  if (textClassNames !== undefined) {\r\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\r\n  }\r\n}\r\nfunction wrapElementWith(element, tag) {\r\n  const el = document.createElement(tag);\r\n  el.appendChild(element);\r\n  return el;\r\n}\r\n\r\n/** @noInheritDoc */\r\nclass TextNode extends LexicalNode {\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  static getType() {\r\n    return 'text';\r\n  }\r\n  static clone(node) {\r\n    return new TextNode(node.__text, node.__key);\r\n  }\r\n  constructor(text, key) {\r\n    super(key);\r\n    this.__text = text;\r\n    this.__format = 0;\r\n    this.__style = '';\r\n    this.__mode = 0;\r\n    this.__detail = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\r\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\r\n   *\r\n   * @returns a number representing the format of the text node.\r\n   */\r\n  getFormat() {\r\n    const self = this.getLatest();\r\n    return self.__format;\r\n  }\r\n\r\n  /**\r\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\r\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\r\n   * or TextNode.isUnmergeable instead.\r\n   *\r\n   * @returns a number representing the detail of the text node.\r\n   */\r\n  getDetail() {\r\n    const self = this.getLatest();\r\n    return self.__detail;\r\n  }\r\n\r\n  /**\r\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\r\n   *\r\n   * @returns TextModeType.\r\n   */\r\n  getMode() {\r\n    const self = this.getLatest();\r\n    return TEXT_TYPE_TO_MODE[self.__mode];\r\n  }\r\n\r\n  /**\r\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\r\n   *\r\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\r\n   */\r\n  getStyle() {\r\n    const self = this.getLatest();\r\n    return self.__style;\r\n  }\r\n\r\n  /**\r\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\r\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\r\n   *\r\n   * @returns true if the node is in token mode, false otherwise.\r\n   */\r\n  isToken() {\r\n    const self = this.getLatest();\r\n    return self.__mode === IS_TOKEN;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\r\n   * mutate the TextNode, false otherwise.\r\n   */\r\n  isComposing() {\r\n    return this.__key === $getCompositionKey();\r\n  }\r\n\r\n  /**\r\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\r\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\r\n   *\r\n   * @returns true if the node is in segmented mode, false otherwise.\r\n   */\r\n  isSegmented() {\r\n    const self = this.getLatest();\r\n    return self.__mode === IS_SEGMENTED;\r\n  }\r\n  /**\r\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\r\n   *\r\n   * @returns true if the node is directionless, false otherwise.\r\n   */\r\n  isDirectionless() {\r\n    const self = this.getLatest();\r\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\r\n  }\r\n  /**\r\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\r\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\r\n   *\r\n   * @returns true if the node is unmergeable, false otherwise.\r\n   */\r\n  isUnmergeable() {\r\n    const self = this.getLatest();\r\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\r\n  }\r\n\r\n  /**\r\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\r\n   * string values to get the format of a TextNode.\r\n   *\r\n   * @param type - the TextFormatType to check for.\r\n   *\r\n   * @returns true if the node has the provided format, false otherwise.\r\n   */\r\n  hasFormat(type) {\r\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\r\n    return (this.getFormat() & formatFlag) !== 0;\r\n  }\r\n\r\n  /**\r\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\r\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\r\n   *\r\n   * @returns true if the node is simple text, false otherwise.\r\n   */\r\n  isSimpleText() {\r\n    return this.__type === 'text' && this.__mode === 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the text content of the node as a string.\r\n   *\r\n   * @returns a string representing the text content of the node.\r\n   */\r\n  getTextContent() {\r\n    const self = this.getLatest();\r\n    return self.__text;\r\n  }\r\n\r\n  /**\r\n   * Returns the format flags applied to the node as a 32-bit integer.\r\n   *\r\n   * @returns a number representing the TextFormatTypes applied to the node.\r\n   */\r\n  getFormatFlags(type, alignWithFormat) {\r\n    const self = this.getLatest();\r\n    const format = self.__format;\r\n    return toggleTextFormatType(format, type, alignWithFormat);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns true if the text node supports font styling, false otherwise.\r\n   */\r\n  canHaveFormat() {\r\n    return true;\r\n  }\r\n\r\n  // View\r\n\r\n  createDOM(config, editor) {\r\n    const format = this.__format;\r\n    const outerTag = getElementOuterTag(this, format);\r\n    const innerTag = getElementInnerTag(this, format);\r\n    const tag = outerTag === null ? innerTag : outerTag;\r\n    const dom = document.createElement(tag);\r\n    let innerDOM = dom;\r\n    if (this.hasFormat('code')) {\r\n      dom.setAttribute('spellcheck', 'false');\r\n    }\r\n    if (outerTag !== null) {\r\n      innerDOM = document.createElement(innerTag);\r\n      dom.appendChild(innerDOM);\r\n    }\r\n    const text = this.__text;\r\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\r\n    const style = this.__style;\r\n    if (style !== '') {\r\n      dom.style.cssText = style;\r\n    }\r\n    return dom;\r\n  }\r\n  updateDOM(prevNode, dom, config) {\r\n    const nextText = this.__text;\r\n    const prevFormat = prevNode.__format;\r\n    const nextFormat = this.__format;\r\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\r\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\r\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\r\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\r\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\r\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\r\n    if (prevTag !== nextTag) {\r\n      return true;\r\n    }\r\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\r\n      // should always be an element\r\n      const prevInnerDOM = dom.firstChild;\r\n      if (prevInnerDOM == null) {\r\n        {\r\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\r\n        }\r\n      }\r\n      const nextInnerDOM = document.createElement(nextInnerTag);\r\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\r\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\r\n      return false;\r\n    }\r\n    let innerDOM = dom;\r\n    if (nextOuterTag !== null) {\r\n      if (prevOuterTag !== null) {\r\n        innerDOM = dom.firstChild;\r\n        if (innerDOM == null) {\r\n          {\r\n            throw Error(`updateDOM: innerDOM is null or undefined`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    setTextContent(nextText, innerDOM, this);\r\n    const theme = config.theme;\r\n    // Apply theme class names\r\n    const textClassNames = theme.text;\r\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\r\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\r\n    }\r\n    const prevStyle = prevNode.__style;\r\n    const nextStyle = this.__style;\r\n    if (prevStyle !== nextStyle) {\r\n      dom.style.cssText = nextStyle;\r\n    }\r\n    return false;\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      '#text': () => ({\r\n        conversion: convertTextDOMNode,\r\n        priority: 0\r\n      }),\r\n      b: () => ({\r\n        conversion: convertBringAttentionToElement,\r\n        priority: 0\r\n      }),\r\n      code: () => ({\r\n        conversion: convertTextFormatElement,\r\n        priority: 0\r\n      }),\r\n      em: () => ({\r\n        conversion: convertTextFormatElement,\r\n        priority: 0\r\n      }),\r\n      i: () => ({\r\n        conversion: convertTextFormatElement,\r\n        priority: 0\r\n      }),\r\n      s: () => ({\r\n        conversion: convertTextFormatElement,\r\n        priority: 0\r\n      }),\r\n      span: () => ({\r\n        conversion: convertSpanElement,\r\n        priority: 0\r\n      }),\r\n      strong: () => ({\r\n        conversion: convertTextFormatElement,\r\n        priority: 0\r\n      }),\r\n      sub: () => ({\r\n        conversion: convertTextFormatElement,\r\n        priority: 0\r\n      }),\r\n      sup: () => ({\r\n        conversion: convertTextFormatElement,\r\n        priority: 0\r\n      }),\r\n      u: () => ({\r\n        conversion: convertTextFormatElement,\r\n        priority: 0\r\n      })\r\n    };\r\n  }\r\n  static importJSON(serializedNode) {\r\n    const node = $createTextNode(serializedNode.text);\r\n    node.setFormat(serializedNode.format);\r\n    node.setDetail(serializedNode.detail);\r\n    node.setMode(serializedNode.mode);\r\n    node.setStyle(serializedNode.style);\r\n    return node;\r\n  }\r\n\r\n  // This improves Lexical's basic text output in copy+paste plus\r\n  // for headless mode where people might use Lexical to generate\r\n  // HTML content and not have the ability to use CSS classes.\r\n  exportDOM(editor) {\r\n    let {\r\n      element\r\n    } = super.exportDOM(editor);\r\n    if (!(element !== null && isHTMLElement(element))) {\r\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\r\n    }\r\n    element.style.whiteSpace = 'pre-wrap';\r\n    // This is the only way to properly add support for most clients,\r\n    // even if it's semantically incorrect to have to resort to using\r\n    // <b>, <u>, <s>, <i> elements.\r\n    if (this.hasFormat('bold')) {\r\n      element = wrapElementWith(element, 'b');\r\n    }\r\n    if (this.hasFormat('italic')) {\r\n      element = wrapElementWith(element, 'i');\r\n    }\r\n    if (this.hasFormat('strikethrough')) {\r\n      element = wrapElementWith(element, 's');\r\n    }\r\n    if (this.hasFormat('underline')) {\r\n      element = wrapElementWith(element, 'u');\r\n    }\r\n    return {\r\n      element\r\n    };\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      detail: this.getDetail(),\r\n      format: this.getFormat(),\r\n      mode: this.getMode(),\r\n      style: this.getStyle(),\r\n      text: this.getTextContent(),\r\n      type: 'text',\r\n      version: 1\r\n    };\r\n  }\r\n\r\n  // Mutators\r\n  selectionTransform(prevSelection, nextSelection) {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\r\n   * version of the argument can only specify one format and doing so will remove all other formats that\r\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\r\n   *\r\n   * @param format - TextFormatType or 32-bit integer representing the node format.\r\n   *\r\n   * @returns this TextNode.\r\n   * // TODO 0.12 This should just be a `string`.\r\n   */\r\n  setFormat(format) {\r\n    const self = this.getWritable();\r\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\r\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\r\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\r\n   * or {@link TextNode.togglerUnmergeable}\r\n   *\r\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\r\n   *\r\n   * @returns this TextNode.\r\n   * // TODO 0.12 This should just be a `string`.\r\n   */\r\n  setDetail(detail) {\r\n    const self = this.getWritable();\r\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * Sets the node style to the provided CSSText-like string. Set this property as you\r\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\r\n   *\r\n   * @param style - CSSText to be applied to the underlying HTMLElement.\r\n   *\r\n   * @returns this TextNode.\r\n   */\r\n  setStyle(style) {\r\n    const self = this.getWritable();\r\n    self.__style = style;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\r\n   * The subscript and superscript formats are mutually exclusive.\r\n   * Prefer using this method to turn specific formats on and off.\r\n   *\r\n   * @param type - TextFormatType to toggle.\r\n   *\r\n   * @returns this TextNode.\r\n   */\r\n  toggleFormat(type) {\r\n    const format = this.getFormat();\r\n    const newFormat = toggleTextFormatType(format, type, null);\r\n    return this.setFormat(newFormat);\r\n  }\r\n\r\n  /**\r\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\r\n   *\r\n   * @returns this TextNode.\r\n   */\r\n  toggleDirectionless() {\r\n    const self = this.getWritable();\r\n    self.__detail ^= IS_DIRECTIONLESS;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\r\n   *\r\n   * @returns this TextNode.\r\n   */\r\n  toggleUnmergeable() {\r\n    const self = this.getWritable();\r\n    self.__detail ^= IS_UNMERGEABLE;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * Sets the mode of the node.\r\n   *\r\n   * @returns this TextNode.\r\n   */\r\n  setMode(type) {\r\n    const mode = TEXT_MODE_TO_TYPE[type];\r\n    if (this.__mode === mode) {\r\n      return this;\r\n    }\r\n    const self = this.getWritable();\r\n    self.__mode = mode;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * Sets the text content of the node.\r\n   *\r\n   * @param text - the string to set as the text value of the node.\r\n   *\r\n   * @returns this TextNode.\r\n   */\r\n  setTextContent(text) {\r\n    if (this.__text === text) {\r\n      return this;\r\n    }\r\n    const self = this.getWritable();\r\n    self.__text = text;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\r\n   *\r\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\r\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\r\n   *\r\n   * @returns the new RangeSelection.\r\n   */\r\n  select(_anchorOffset, _focusOffset) {\r\n    errorOnReadOnly();\r\n    let anchorOffset = _anchorOffset;\r\n    let focusOffset = _focusOffset;\r\n    const selection = $getSelection();\r\n    const text = this.getTextContent();\r\n    const key = this.__key;\r\n    if (typeof text === 'string') {\r\n      const lastOffset = text.length;\r\n      if (anchorOffset === undefined) {\r\n        anchorOffset = lastOffset;\r\n      }\r\n      if (focusOffset === undefined) {\r\n        focusOffset = lastOffset;\r\n      }\r\n    } else {\r\n      anchorOffset = 0;\r\n      focusOffset = 0;\r\n    }\r\n    if (!$isRangeSelection(selection)) {\r\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\r\n    } else {\r\n      const compositionKey = $getCompositionKey();\r\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\r\n        $setCompositionKey(key);\r\n      }\r\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\r\n    }\r\n    return selection;\r\n  }\r\n  selectStart() {\r\n    return this.select(0, 0);\r\n  }\r\n  selectEnd() {\r\n    const size = this.getTextContentSize();\r\n    return this.select(size, size);\r\n  }\r\n\r\n  /**\r\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\r\n   * specified. Can optionally calculate a new selection after the operation is complete.\r\n   *\r\n   * @param offset - the offset at which the splice operation should begin.\r\n   * @param delCount - the number of characters to delete, starting from the offset.\r\n   * @param newText - the text to insert into the TextNode at the offset.\r\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\r\n   *\r\n   * @returns this TextNode.\r\n   */\r\n  spliceText(offset, delCount, newText, moveSelection) {\r\n    const writableSelf = this.getWritable();\r\n    const text = writableSelf.__text;\r\n    const handledTextLength = newText.length;\r\n    let index = offset;\r\n    if (index < 0) {\r\n      index = handledTextLength + index;\r\n      if (index < 0) {\r\n        index = 0;\r\n      }\r\n    }\r\n    const selection = $getSelection();\r\n    if (moveSelection && $isRangeSelection(selection)) {\r\n      const newOffset = offset + handledTextLength;\r\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\r\n    }\r\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\r\n    writableSelf.__text = updatedText;\r\n    return writableSelf;\r\n  }\r\n\r\n  /**\r\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\r\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\r\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\r\n   *\r\n   * @returns true if text can be inserted before the node, false otherwise.\r\n   */\r\n  canInsertTextBefore() {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\r\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\r\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\r\n   *\r\n   * @returns true if text can be inserted after the node, false otherwise.\r\n   */\r\n  canInsertTextAfter() {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\r\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\r\n   *\r\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\r\n   *\r\n   * @returns an Array containing the newly-created TextNodes.\r\n   */\r\n  splitText(...splitOffsets) {\r\n    errorOnReadOnly();\r\n    const self = this.getLatest();\r\n    const textContent = self.getTextContent();\r\n    const key = self.__key;\r\n    const compositionKey = $getCompositionKey();\r\n    const offsetsSet = new Set(splitOffsets);\r\n    const parts = [];\r\n    const textLength = textContent.length;\r\n    let string = '';\r\n    for (let i = 0; i < textLength; i++) {\r\n      if (string !== '' && offsetsSet.has(i)) {\r\n        parts.push(string);\r\n        string = '';\r\n      }\r\n      string += textContent[i];\r\n    }\r\n    if (string !== '') {\r\n      parts.push(string);\r\n    }\r\n    const partsLength = parts.length;\r\n    if (partsLength === 0) {\r\n      return [];\r\n    } else if (parts[0] === textContent) {\r\n      return [self];\r\n    }\r\n    const firstPart = parts[0];\r\n    const parent = self.getParentOrThrow();\r\n    let writableNode;\r\n    const format = self.getFormat();\r\n    const style = self.getStyle();\r\n    const detail = self.__detail;\r\n    let hasReplacedSelf = false;\r\n    if (self.isSegmented()) {\r\n      // Create a new TextNode\r\n      writableNode = $createTextNode(firstPart);\r\n      writableNode.__format = format;\r\n      writableNode.__style = style;\r\n      writableNode.__detail = detail;\r\n      hasReplacedSelf = true;\r\n    } else {\r\n      // For the first part, update the existing node\r\n      writableNode = self.getWritable();\r\n      writableNode.__text = firstPart;\r\n    }\r\n\r\n    // Handle selection\r\n    const selection = $getSelection();\r\n\r\n    // Then handle all other parts\r\n    const splitNodes = [writableNode];\r\n    let textSize = firstPart.length;\r\n    for (let i = 1; i < partsLength; i++) {\r\n      const part = parts[i];\r\n      const partSize = part.length;\r\n      const sibling = $createTextNode(part).getWritable();\r\n      sibling.__format = format;\r\n      sibling.__style = style;\r\n      sibling.__detail = detail;\r\n      const siblingKey = sibling.__key;\r\n      const nextTextSize = textSize + partSize;\r\n      if ($isRangeSelection(selection)) {\r\n        const anchor = selection.anchor;\r\n        const focus = selection.focus;\r\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\r\n          anchor.key = siblingKey;\r\n          anchor.offset -= textSize;\r\n          selection.dirty = true;\r\n        }\r\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\r\n          focus.key = siblingKey;\r\n          focus.offset -= textSize;\r\n          selection.dirty = true;\r\n        }\r\n      }\r\n      if (compositionKey === key) {\r\n        $setCompositionKey(siblingKey);\r\n      }\r\n      textSize = nextTextSize;\r\n      splitNodes.push(sibling);\r\n    }\r\n\r\n    // Insert the nodes into the parent's children\r\n    internalMarkSiblingsAsDirty(this);\r\n    const writableParent = parent.getWritable();\r\n    const insertionIndex = this.getIndexWithinParent();\r\n    if (hasReplacedSelf) {\r\n      writableParent.splice(insertionIndex, 0, splitNodes);\r\n      this.remove();\r\n    } else {\r\n      writableParent.splice(insertionIndex, 1, splitNodes);\r\n    }\r\n    if ($isRangeSelection(selection)) {\r\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\r\n    }\r\n    return splitNodes;\r\n  }\r\n\r\n  /**\r\n   * Merges the target TextNode into this TextNode, removing the target node.\r\n   *\r\n   * @param target - the TextNode to merge into this one.\r\n   *\r\n   * @returns this TextNode.\r\n   */\r\n  mergeWithSibling(target) {\r\n    const isBefore = target === this.getPreviousSibling();\r\n    if (!isBefore && target !== this.getNextSibling()) {\r\n      {\r\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\r\n      }\r\n    }\r\n    const key = this.__key;\r\n    const targetKey = target.__key;\r\n    const text = this.__text;\r\n    const textLength = text.length;\r\n    const compositionKey = $getCompositionKey();\r\n    if (compositionKey === targetKey) {\r\n      $setCompositionKey(key);\r\n    }\r\n    const selection = $getSelection();\r\n    if ($isRangeSelection(selection)) {\r\n      const anchor = selection.anchor;\r\n      const focus = selection.focus;\r\n      if (anchor !== null && anchor.key === targetKey) {\r\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\r\n        selection.dirty = true;\r\n      }\r\n      if (focus !== null && focus.key === targetKey) {\r\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\r\n        selection.dirty = true;\r\n      }\r\n    }\r\n    const targetText = target.__text;\r\n    const newText = isBefore ? targetText + text : text + targetText;\r\n    this.setTextContent(newText);\r\n    const writableSelf = this.getWritable();\r\n    target.remove();\r\n    return writableSelf;\r\n  }\r\n\r\n  /**\r\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\r\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\r\n   * node class that you create and replace matched text with should return true from this method.\r\n   *\r\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\r\n   */\r\n  isTextEntity() {\r\n    return false;\r\n  }\r\n}\r\nfunction convertSpanElement(domNode) {\r\n  // domNode is a <span> since we matched it by nodeName\r\n  const span = domNode;\r\n  // Google Docs uses span tags + font-weight for bold text\r\n  const hasBoldFontWeight = span.style.fontWeight === '700';\r\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\r\n  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through';\r\n  // Google Docs uses span tags + font-style for italic text\r\n  const hasItalicFontStyle = span.style.fontStyle === 'italic';\r\n  // Google Docs uses span tags + text-decoration: underline for underline text\r\n  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline';\r\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\r\n  const verticalAlign = span.style.verticalAlign;\r\n  return {\r\n    forChild: lexicalNode => {\r\n      if (!$isTextNode(lexicalNode)) {\r\n        return lexicalNode;\r\n      }\r\n      if (hasBoldFontWeight) {\r\n        lexicalNode.toggleFormat('bold');\r\n      }\r\n      if (hasLinethroughTextDecoration) {\r\n        lexicalNode.toggleFormat('strikethrough');\r\n      }\r\n      if (hasItalicFontStyle) {\r\n        lexicalNode.toggleFormat('italic');\r\n      }\r\n      if (hasUnderlineTextDecoration) {\r\n        lexicalNode.toggleFormat('underline');\r\n      }\r\n      if (verticalAlign === 'sub') {\r\n        lexicalNode.toggleFormat('subscript');\r\n      }\r\n      if (verticalAlign === 'super') {\r\n        lexicalNode.toggleFormat('superscript');\r\n      }\r\n      return lexicalNode;\r\n    },\r\n    node: null\r\n  };\r\n}\r\nfunction convertBringAttentionToElement(domNode) {\r\n  // domNode is a <b> since we matched it by nodeName\r\n  const b = domNode;\r\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\r\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\r\n  return {\r\n    forChild: lexicalNode => {\r\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\r\n        lexicalNode.toggleFormat('bold');\r\n      }\r\n      return lexicalNode;\r\n    },\r\n    node: null\r\n  };\r\n}\r\nconst preParentCache = new WeakMap();\r\nfunction isNodePre(node) {\r\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style !== undefined && node.style.whiteSpace !== undefined && node.style.whiteSpace.startsWith('pre');\r\n}\r\nfunction findParentPreDOMNode(node) {\r\n  let cached;\r\n  let parent = node.parentNode;\r\n  const visited = [node];\r\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\r\n    visited.push(parent);\r\n    parent = parent.parentNode;\r\n  }\r\n  const resultNode = cached === undefined ? parent : cached;\r\n  for (let i = 0; i < visited.length; i++) {\r\n    preParentCache.set(visited[i], resultNode);\r\n  }\r\n  return resultNode;\r\n}\r\nfunction convertTextDOMNode(domNode) {\r\n  const domNode_ = domNode;\r\n  const parentDom = domNode.parentElement;\r\n  if (!(parentDom !== null)) {\r\n    throw Error(`Expected parentElement of Text not to be null`);\r\n  }\r\n  let textContent = domNode_.textContent || '';\r\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\r\n  if (findParentPreDOMNode(domNode_) !== null) {\r\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\r\n    const nodes = [];\r\n    const length = parts.length;\r\n    for (let i = 0; i < length; i++) {\r\n      const part = parts[i];\r\n      if (part === '\\n' || part === '\\r\\n') {\r\n        nodes.push($createLineBreakNode());\r\n      } else if (part === '\\t') {\r\n        nodes.push($createTabNode());\r\n      } else if (part !== '') {\r\n        nodes.push($createTextNode(part));\r\n      }\r\n    }\r\n    return {\r\n      node: nodes\r\n    };\r\n  }\r\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\r\n  if (textContent === '') {\r\n    return {\r\n      node: null\r\n    };\r\n  }\r\n  if (textContent[0] === ' ') {\r\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\r\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\r\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\r\n    let previousText = domNode_;\r\n    let isStartOfLine = true;\r\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\r\n      const previousTextContent = previousText.textContent || '';\r\n      if (previousTextContent.length > 0) {\r\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\r\n          textContent = textContent.slice(1);\r\n        }\r\n        isStartOfLine = false;\r\n        break;\r\n      }\r\n    }\r\n    if (isStartOfLine) {\r\n      textContent = textContent.slice(1);\r\n    }\r\n  }\r\n  if (textContent[textContent.length - 1] === ' ') {\r\n    // Traverse forward while in the same line, preserve if next inline will require a space\r\n    let nextText = domNode_;\r\n    let isEndOfLine = true;\r\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\r\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\r\n      if (nextTextContent.length > 0) {\r\n        isEndOfLine = false;\r\n        break;\r\n      }\r\n    }\r\n    if (isEndOfLine) {\r\n      textContent = textContent.slice(0, textContent.length - 1);\r\n    }\r\n  }\r\n  if (textContent === '') {\r\n    return {\r\n      node: null\r\n    };\r\n  }\r\n  return {\r\n    node: $createTextNode(textContent)\r\n  };\r\n}\r\nconst inlineParents = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, 'i');\r\nfunction findTextInLine(text, forward) {\r\n  let node = text;\r\n  // eslint-disable-next-line no-constant-condition\r\n  while (true) {\r\n    let sibling;\r\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\r\n      const parentElement = node.parentElement;\r\n      if (parentElement === null) {\r\n        return null;\r\n      }\r\n      node = parentElement;\r\n    }\r\n    node = sibling;\r\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\r\n      const display = node.style.display;\r\n      if (display === '' && node.nodeName.match(inlineParents) === null || display !== '' && !display.startsWith('inline')) {\r\n        return null;\r\n      }\r\n    }\r\n    let descendant = node;\r\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\r\n      node = descendant;\r\n    }\r\n    if (node.nodeType === DOM_TEXT_TYPE) {\r\n      return node;\r\n    } else if (node.nodeName === 'BR') {\r\n      return null;\r\n    }\r\n  }\r\n}\r\nconst nodeNameToTextFormat = {\r\n  code: 'code',\r\n  em: 'italic',\r\n  i: 'italic',\r\n  s: 'strikethrough',\r\n  strong: 'bold',\r\n  sub: 'subscript',\r\n  sup: 'superscript',\r\n  u: 'underline'\r\n};\r\nfunction convertTextFormatElement(domNode) {\r\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\r\n  if (format === undefined) {\r\n    return {\r\n      node: null\r\n    };\r\n  }\r\n  return {\r\n    forChild: lexicalNode => {\r\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\r\n        lexicalNode.toggleFormat(format);\r\n      }\r\n      return lexicalNode;\r\n    },\r\n    node: null\r\n  };\r\n}\r\nfunction $createTextNode(text = '') {\r\n  return $applyNodeReplacement(new TextNode(text));\r\n}\r\nfunction $isTextNode(node) {\r\n  return node instanceof TextNode;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass TabNode extends TextNode {\r\n  static getType() {\r\n    return 'tab';\r\n  }\r\n  static clone(node) {\r\n    const newNode = new TabNode(node.__key);\r\n    // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\r\n    newNode.__text = node.__text;\r\n    newNode.__format = node.__format;\r\n    newNode.__style = node.__style;\r\n    return newNode;\r\n  }\r\n  constructor(key) {\r\n    super('\\t', key);\r\n    this.__detail = IS_UNMERGEABLE;\r\n  }\r\n  static importDOM() {\r\n    return null;\r\n  }\r\n  static importJSON(serializedTabNode) {\r\n    const node = $createTabNode();\r\n    node.setFormat(serializedTabNode.format);\r\n    node.setStyle(serializedTabNode.style);\r\n    return node;\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      type: 'tab',\r\n      version: 1\r\n    };\r\n  }\r\n  setTextContent(_text) {\r\n    {\r\n      throw Error(`TabNode does not support setTextContent`);\r\n    }\r\n  }\r\n  setDetail(_detail) {\r\n    {\r\n      throw Error(`TabNode does not support setDetail`);\r\n    }\r\n  }\r\n  setMode(_type) {\r\n    {\r\n      throw Error(`TabNode does not support setMode`);\r\n    }\r\n  }\r\n  canInsertTextBefore() {\r\n    return false;\r\n  }\r\n  canInsertTextAfter() {\r\n    return false;\r\n  }\r\n}\r\nfunction $createTabNode() {\r\n  return $applyNodeReplacement(new TabNode());\r\n}\r\nfunction $isTabNode(node) {\r\n  return node instanceof TabNode;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nclass Point {\r\n  constructor(key, offset, type) {\r\n    this._selection = null;\r\n    this.key = key;\r\n    this.offset = offset;\r\n    this.type = type;\r\n  }\r\n  is(point) {\r\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\r\n  }\r\n  isBefore(b) {\r\n    let aNode = this.getNode();\r\n    let bNode = b.getNode();\r\n    const aOffset = this.offset;\r\n    const bOffset = b.offset;\r\n    if ($isElementNode(aNode)) {\r\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\r\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\r\n    }\r\n    if ($isElementNode(bNode)) {\r\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\r\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\r\n    }\r\n    if (aNode === bNode) {\r\n      return aOffset < bOffset;\r\n    }\r\n    return aNode.isBefore(bNode);\r\n  }\r\n  getNode() {\r\n    const key = this.key;\r\n    const node = $getNodeByKey(key);\r\n    if (node === null) {\r\n      {\r\n        throw Error(`Point.getNode: node not found`);\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n  set(key, offset, type) {\r\n    const selection = this._selection;\r\n    const oldKey = this.key;\r\n    this.key = key;\r\n    this.offset = offset;\r\n    this.type = type;\r\n    if (!isCurrentlyReadOnlyMode()) {\r\n      if ($getCompositionKey() === oldKey) {\r\n        $setCompositionKey(key);\r\n      }\r\n      if (selection !== null) {\r\n        selection.setCachedNodes(null);\r\n        selection.dirty = true;\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction $createPoint(key, offset, type) {\r\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\r\n  return new Point(key, offset, type);\r\n}\r\nfunction selectPointOnNode(point, node) {\r\n  let key = node.__key;\r\n  let offset = point.offset;\r\n  let type = 'element';\r\n  if ($isTextNode(node)) {\r\n    type = 'text';\r\n    const textContentLength = node.getTextContentSize();\r\n    if (offset > textContentLength) {\r\n      offset = textContentLength;\r\n    }\r\n  } else if (!$isElementNode(node)) {\r\n    const nextSibling = node.getNextSibling();\r\n    if ($isTextNode(nextSibling)) {\r\n      key = nextSibling.__key;\r\n      offset = 0;\r\n      type = 'text';\r\n    } else {\r\n      const parentNode = node.getParent();\r\n      if (parentNode) {\r\n        key = parentNode.__key;\r\n        offset = node.getIndexWithinParent() + 1;\r\n      }\r\n    }\r\n  }\r\n  point.set(key, offset, type);\r\n}\r\nfunction $moveSelectionPointToEnd(point, node) {\r\n  if ($isElementNode(node)) {\r\n    const lastNode = node.getLastDescendant();\r\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\r\n      selectPointOnNode(point, lastNode);\r\n    } else {\r\n      selectPointOnNode(point, node);\r\n    }\r\n  } else {\r\n    selectPointOnNode(point, node);\r\n  }\r\n}\r\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\r\n  const element = start.getNode();\r\n  const placementNode = element.getChildAtIndex(start.offset);\r\n  const textNode = $createTextNode();\r\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\r\n  textNode.setFormat(format);\r\n  textNode.setStyle(style);\r\n  if (placementNode === null) {\r\n    element.append(target);\r\n  } else {\r\n    placementNode.insertBefore(target);\r\n  }\r\n  // Transfer the element point to a text point.\r\n  if (start.is(end)) {\r\n    end.set(textNode.__key, 0, 'text');\r\n  }\r\n  start.set(textNode.__key, 0, 'text');\r\n}\r\nfunction $setPointValues(point, key, offset, type) {\r\n  point.key = key;\r\n  point.offset = offset;\r\n  point.type = type;\r\n}\r\nclass NodeSelection {\r\n  constructor(objects) {\r\n    this._cachedNodes = null;\r\n    this._nodes = objects;\r\n    this.dirty = false;\r\n  }\r\n  getCachedNodes() {\r\n    return this._cachedNodes;\r\n  }\r\n  setCachedNodes(nodes) {\r\n    this._cachedNodes = nodes;\r\n  }\r\n  is(selection) {\r\n    if (!$isNodeSelection(selection)) {\r\n      return false;\r\n    }\r\n    const a = this._nodes;\r\n    const b = selection._nodes;\r\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\r\n  }\r\n  isCollapsed() {\r\n    return false;\r\n  }\r\n  isBackward() {\r\n    return false;\r\n  }\r\n  getStartEndPoints() {\r\n    return null;\r\n  }\r\n  add(key) {\r\n    this.dirty = true;\r\n    this._nodes.add(key);\r\n    this._cachedNodes = null;\r\n  }\r\n  delete(key) {\r\n    this.dirty = true;\r\n    this._nodes.delete(key);\r\n    this._cachedNodes = null;\r\n  }\r\n  clear() {\r\n    this.dirty = true;\r\n    this._nodes.clear();\r\n    this._cachedNodes = null;\r\n  }\r\n  has(key) {\r\n    return this._nodes.has(key);\r\n  }\r\n  clone() {\r\n    return new NodeSelection(new Set(this._nodes));\r\n  }\r\n  extract() {\r\n    return this.getNodes();\r\n  }\r\n  insertRawText(text) {\r\n    // Do nothing?\r\n  }\r\n  insertText() {\r\n    // Do nothing?\r\n  }\r\n  insertNodes(nodes) {\r\n    const selectedNodes = this.getNodes();\r\n    const selectedNodesLength = selectedNodes.length;\r\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\r\n    let selectionAtEnd;\r\n    // Insert nodes\r\n    if ($isTextNode(lastSelectedNode)) {\r\n      selectionAtEnd = lastSelectedNode.select();\r\n    } else {\r\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\r\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\r\n    }\r\n    selectionAtEnd.insertNodes(nodes);\r\n    // Remove selected nodes\r\n    for (let i = 0; i < selectedNodesLength; i++) {\r\n      selectedNodes[i].remove();\r\n    }\r\n  }\r\n  getNodes() {\r\n    const cachedNodes = this._cachedNodes;\r\n    if (cachedNodes !== null) {\r\n      return cachedNodes;\r\n    }\r\n    const objects = this._nodes;\r\n    const nodes = [];\r\n    for (const object of objects) {\r\n      const node = $getNodeByKey(object);\r\n      if (node !== null) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    if (!isCurrentlyReadOnlyMode()) {\r\n      this._cachedNodes = nodes;\r\n    }\r\n    return nodes;\r\n  }\r\n  getTextContent() {\r\n    const nodes = this.getNodes();\r\n    let textContent = '';\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      textContent += nodes[i].getTextContent();\r\n    }\r\n    return textContent;\r\n  }\r\n}\r\nfunction $isRangeSelection(x) {\r\n  return x instanceof RangeSelection;\r\n}\r\nclass RangeSelection {\r\n  constructor(anchor, focus, format, style) {\r\n    this.anchor = anchor;\r\n    this.focus = focus;\r\n    anchor._selection = this;\r\n    focus._selection = this;\r\n    this._cachedNodes = null;\r\n    this.format = format;\r\n    this.style = style;\r\n    this.dirty = false;\r\n  }\r\n  getCachedNodes() {\r\n    return this._cachedNodes;\r\n  }\r\n  setCachedNodes(nodes) {\r\n    this._cachedNodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * Used to check if the provided selections is equal to this one by value,\r\n   * inluding anchor, focus, format, and style properties.\r\n   * @param selection - the Selection to compare this one to.\r\n   * @returns true if the Selections are equal, false otherwise.\r\n   */\r\n  is(selection) {\r\n    if (!$isRangeSelection(selection)) {\r\n      return false;\r\n    }\r\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\r\n   * the same node and have the same offset.\r\n   *\r\n   * @returns true if the Selection is collapsed, false otherwise.\r\n   */\r\n  isCollapsed() {\r\n    return this.anchor.is(this.focus);\r\n  }\r\n\r\n  /**\r\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\r\n   * for use in hot paths.\r\n   *\r\n   * @returns an Array containing all the nodes in the Selection\r\n   */\r\n  getNodes() {\r\n    const cachedNodes = this._cachedNodes;\r\n    if (cachedNodes !== null) {\r\n      return cachedNodes;\r\n    }\r\n    const anchor = this.anchor;\r\n    const focus = this.focus;\r\n    const isBefore = anchor.isBefore(focus);\r\n    const firstPoint = isBefore ? anchor : focus;\r\n    const lastPoint = isBefore ? focus : anchor;\r\n    let firstNode = firstPoint.getNode();\r\n    let lastNode = lastPoint.getNode();\r\n    const startOffset = firstPoint.offset;\r\n    const endOffset = lastPoint.offset;\r\n    if ($isElementNode(firstNode)) {\r\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\r\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\r\n    }\r\n    if ($isElementNode(lastNode)) {\r\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);\r\n      // We don't want to over-select, as node selection infers the child before\r\n      // the last descendant, not including that descendant.\r\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\r\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\r\n      }\r\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\r\n    }\r\n    let nodes;\r\n    if (firstNode.is(lastNode)) {\r\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\r\n        nodes = [];\r\n      } else {\r\n        nodes = [firstNode];\r\n      }\r\n    } else {\r\n      nodes = firstNode.getNodesBetween(lastNode);\r\n    }\r\n    if (!isCurrentlyReadOnlyMode()) {\r\n      this._cachedNodes = nodes;\r\n    }\r\n    return nodes;\r\n  }\r\n\r\n  /**\r\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\r\n   *\r\n   * @param anchorNode - the anchor node to set on the Selection\r\n   * @param anchorOffset - the offset to set on the Selection\r\n   * @param focusNode - the focus node to set on the Selection\r\n   * @param focusOffset - the focus offset to set on the Selection\r\n   */\r\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\r\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\r\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\r\n    this._cachedNodes = null;\r\n    this.dirty = true;\r\n  }\r\n\r\n  /**\r\n   * Gets the (plain) text content of all the nodes in the selection.\r\n   *\r\n   * @returns a string representing the text content of all the nodes in the Selection\r\n   */\r\n  getTextContent() {\r\n    const nodes = this.getNodes();\r\n    if (nodes.length === 0) {\r\n      return '';\r\n    }\r\n    const firstNode = nodes[0];\r\n    const lastNode = nodes[nodes.length - 1];\r\n    const anchor = this.anchor;\r\n    const focus = this.focus;\r\n    const isBefore = anchor.isBefore(focus);\r\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\r\n    let textContent = '';\r\n    let prevWasElement = true;\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      const node = nodes[i];\r\n      if ($isElementNode(node) && !node.isInline()) {\r\n        if (!prevWasElement) {\r\n          textContent += '\\n';\r\n        }\r\n        if (node.isEmpty()) {\r\n          prevWasElement = false;\r\n        } else {\r\n          prevWasElement = true;\r\n        }\r\n      } else {\r\n        prevWasElement = false;\r\n        if ($isTextNode(node)) {\r\n          let text = node.getTextContent();\r\n          if (node === firstNode) {\r\n            if (node === lastNode) {\r\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\r\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\r\n              }\r\n            } else {\r\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\r\n            }\r\n          } else if (node === lastNode) {\r\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\r\n          }\r\n          textContent += text;\r\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\r\n          textContent += node.getTextContent();\r\n        }\r\n      }\r\n    }\r\n    return textContent;\r\n  }\r\n\r\n  /**\r\n   * Attempts to map a DOM selection range onto this Lexical Selection,\r\n   * setting the anchor, focus, and type accordingly\r\n   *\r\n   * @param range a DOM Selection range conforming to the StaticRange interface.\r\n   */\r\n  applyDOMRange(range) {\r\n    const editor = getActiveEditor();\r\n    const currentEditorState = editor.getEditorState();\r\n    const lastSelection = currentEditorState._selection;\r\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\r\n    if (resolvedSelectionPoints === null) {\r\n      return;\r\n    }\r\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\r\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\r\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\r\n    this._cachedNodes = null;\r\n  }\r\n\r\n  /**\r\n   * Creates a new RangeSelection, copying over all the property values from this one.\r\n   *\r\n   * @returns a new RangeSelection with the same property values as this one.\r\n   */\r\n  clone() {\r\n    const anchor = this.anchor;\r\n    const focus = this.focus;\r\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\r\n    return selection;\r\n  }\r\n\r\n  /**\r\n   * Toggles the provided format on all the TextNodes in the Selection.\r\n   *\r\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\r\n   */\r\n  toggleFormat(format) {\r\n    this.format = toggleTextFormatType(this.format, format, null);\r\n    this.dirty = true;\r\n  }\r\n\r\n  /**\r\n   * Sets the value of the style property on the Selection\r\n   *\r\n   * @param style - the style to set at the value of the style property.\r\n   */\r\n  setStyle(style) {\r\n    this.style = style;\r\n    this.dirty = true;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\r\n   * has the specified format.\r\n   *\r\n   * @param type the TextFormatType to check for.\r\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\r\n   */\r\n  hasFormat(type) {\r\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\r\n    return (this.format & formatFlag) !== 0;\r\n  }\r\n\r\n  /**\r\n   * Attempts to insert the provided text into the EditorState at the current Selection.\r\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\r\n   *\r\n   * @param text the text to insert into the Selection\r\n   */\r\n  insertRawText(text) {\r\n    const parts = text.split(/(\\r?\\n|\\t)/);\r\n    const nodes = [];\r\n    const length = parts.length;\r\n    for (let i = 0; i < length; i++) {\r\n      const part = parts[i];\r\n      if (part === '\\n' || part === '\\r\\n') {\r\n        nodes.push($createLineBreakNode());\r\n      } else if (part === '\\t') {\r\n        nodes.push($createTabNode());\r\n      } else {\r\n        nodes.push($createTextNode(part));\r\n      }\r\n    }\r\n    this.insertNodes(nodes);\r\n  }\r\n\r\n  /**\r\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\r\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\r\n   *\r\n   * @param text the text to insert into the Selection\r\n   */\r\n  insertText(text) {\r\n    const anchor = this.anchor;\r\n    const focus = this.focus;\r\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\r\n    const format = this.format;\r\n    const style = this.style;\r\n    if (isBefore && anchor.type === 'element') {\r\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\r\n    } else if (!isBefore && focus.type === 'element') {\r\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\r\n    }\r\n    const selectedNodes = this.getNodes();\r\n    const selectedNodesLength = selectedNodes.length;\r\n    const firstPoint = isBefore ? anchor : focus;\r\n    const endPoint = isBefore ? focus : anchor;\r\n    const startOffset = firstPoint.offset;\r\n    const endOffset = endPoint.offset;\r\n    let firstNode = selectedNodes[0];\r\n    if (!$isTextNode(firstNode)) {\r\n      {\r\n        throw Error(`insertText: first node is not a text node`);\r\n      }\r\n    }\r\n    const firstNodeText = firstNode.getTextContent();\r\n    const firstNodeTextLength = firstNodeText.length;\r\n    const firstNodeParent = firstNode.getParentOrThrow();\r\n    const lastIndex = selectedNodesLength - 1;\r\n    let lastNode = selectedNodes[lastIndex];\r\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\r\n      let nextSibling = firstNode.getNextSibling();\r\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\r\n        nextSibling = $createTextNode();\r\n        nextSibling.setFormat(format);\r\n        if (!firstNodeParent.canInsertTextAfter()) {\r\n          firstNodeParent.insertAfter(nextSibling);\r\n        } else {\r\n          firstNode.insertAfter(nextSibling);\r\n        }\r\n      }\r\n      nextSibling.select(0, 0);\r\n      firstNode = nextSibling;\r\n      if (text !== '') {\r\n        this.insertText(text);\r\n        return;\r\n      }\r\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\r\n      let prevSibling = firstNode.getPreviousSibling();\r\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\r\n        prevSibling = $createTextNode();\r\n        prevSibling.setFormat(format);\r\n        if (!firstNodeParent.canInsertTextBefore()) {\r\n          firstNodeParent.insertBefore(prevSibling);\r\n        } else {\r\n          firstNode.insertBefore(prevSibling);\r\n        }\r\n      }\r\n      prevSibling.select();\r\n      firstNode = prevSibling;\r\n      if (text !== '') {\r\n        this.insertText(text);\r\n        return;\r\n      }\r\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\r\n      const textNode = $createTextNode(firstNode.getTextContent());\r\n      textNode.setFormat(format);\r\n      firstNode.replace(textNode);\r\n      firstNode = textNode;\r\n    } else if (!this.isCollapsed() && text !== '') {\r\n      // When the firstNode or lastNode parents are elements that\r\n      // do not allow text to be inserted before or after, we first\r\n      // clear the content. Then we normalize selection, then insert\r\n      // the new content.\r\n      const lastNodeParent = lastNode.getParent();\r\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\r\n        this.insertText('');\r\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\r\n        this.insertText(text);\r\n        return;\r\n      }\r\n    }\r\n    if (selectedNodesLength === 1) {\r\n      if (firstNode.isToken()) {\r\n        const textNode = $createTextNode(text);\r\n        textNode.select();\r\n        firstNode.replace(textNode);\r\n        return;\r\n      }\r\n      const firstNodeFormat = firstNode.getFormat();\r\n      const firstNodeStyle = firstNode.getStyle();\r\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\r\n        if (firstNode.getTextContent() === '') {\r\n          firstNode.setFormat(format);\r\n          firstNode.setStyle(style);\r\n        } else {\r\n          const textNode = $createTextNode(text);\r\n          textNode.setFormat(format);\r\n          textNode.setStyle(style);\r\n          textNode.select();\r\n          if (startOffset === 0) {\r\n            firstNode.insertBefore(textNode, false);\r\n          } else {\r\n            const [targetNode] = firstNode.splitText(startOffset);\r\n            targetNode.insertAfter(textNode, false);\r\n          }\r\n          // When composing, we need to adjust the anchor offset so that\r\n          // we correctly replace that right range.\r\n          if (textNode.isComposing() && this.anchor.type === 'text') {\r\n            this.anchor.offset -= text.length;\r\n          }\r\n          return;\r\n        }\r\n      } else if ($isTabNode(firstNode)) {\r\n        // We don't need to check for delCount because there is only the entire selected node case\r\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\r\n        const textNode = $createTextNode(text);\r\n        textNode.setFormat(format);\r\n        textNode.setStyle(style);\r\n        textNode.select();\r\n        firstNode.replace(textNode);\r\n        return;\r\n      }\r\n      const delCount = endOffset - startOffset;\r\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\r\n      if (firstNode.getTextContent() === '') {\r\n        firstNode.remove();\r\n      } else if (this.anchor.type === 'text') {\r\n        if (firstNode.isComposing()) {\r\n          // When composing, we need to adjust the anchor offset so that\r\n          // we correctly replace that right range.\r\n          this.anchor.offset -= text.length;\r\n        } else {\r\n          this.format = firstNodeFormat;\r\n          this.style = firstNodeStyle;\r\n        }\r\n      }\r\n    } else {\r\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\r\n\r\n      // We have to get the parent elements before the next section,\r\n      // as in that section we might mutate the lastNode.\r\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\r\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\r\n      let lastElementChild = lastNode;\r\n\r\n      // If the last element is inline, we should instead look at getting\r\n      // the nodes of its parent, rather than itself. This behavior will\r\n      // then better match how text node insertions work. We will need to\r\n      // also update the last element's child accordingly as we do this.\r\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\r\n        // Keep traversing till we have a non-inline element parent.\r\n        do {\r\n          lastElementChild = lastElement;\r\n          lastElement = lastElement.getParentOrThrow();\r\n        } while (lastElement.isInline());\r\n      }\r\n\r\n      // Handle mutations to the last node.\r\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\r\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\r\n          if (lastNode.isSegmented()) {\r\n            const textNode = $createTextNode(lastNode.getTextContent());\r\n            lastNode.replace(textNode);\r\n            lastNode = textNode;\r\n          }\r\n          // root node selections only select whole nodes, so no text splice is necessary\r\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\r\n            lastNode = lastNode.spliceText(0, endOffset, '');\r\n          }\r\n          markedNodeKeysForKeep.add(lastNode.__key);\r\n        } else {\r\n          const lastNodeParent = lastNode.getParentOrThrow();\r\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\r\n            lastNodeParent.remove();\r\n          } else {\r\n            lastNode.remove();\r\n          }\r\n        }\r\n      } else {\r\n        markedNodeKeysForKeep.add(lastNode.__key);\r\n      }\r\n\r\n      // Either move the remaining nodes of the last parent to after\r\n      // the first child, or remove them entirely. If the last parent\r\n      // is the same as the first parent, this logic also works.\r\n      const lastNodeChildren = lastElement.getChildren();\r\n      const selectedNodesSet = new Set(selectedNodes);\r\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\r\n\r\n      // We choose a target to insert all nodes after. In the case of having\r\n      // and inline starting parent element with a starting node that has no\r\n      // siblings, we should insert after the starting parent element, otherwise\r\n      // we will incorrectly merge into the starting parent element.\r\n      // TODO: should we keep on traversing parents if we're inside another\r\n      // nested inline element?\r\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\r\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\r\n        const lastNodeChild = lastNodeChildren[i];\r\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\r\n          break;\r\n        }\r\n        if (lastNodeChild.isAttached()) {\r\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\r\n            if (!firstAndLastElementsAreEqual) {\r\n              insertionTarget.insertAfter(lastNodeChild, false);\r\n            }\r\n          } else {\r\n            lastNodeChild.remove();\r\n          }\r\n        }\r\n      }\r\n      if (!firstAndLastElementsAreEqual) {\r\n        // Check if we have already moved out all the nodes of the\r\n        // last parent, and if so, traverse the parent tree and mark\r\n        // them all as being able to deleted too.\r\n        let parent = lastElement;\r\n        let lastRemovedParent = null;\r\n        while (parent !== null) {\r\n          const children = parent.getChildren();\r\n          const childrenLength = children.length;\r\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\r\n            markedNodeKeysForKeep.delete(parent.__key);\r\n            lastRemovedParent = parent;\r\n          }\r\n          parent = parent.getParent();\r\n        }\r\n      }\r\n\r\n      // Ensure we do splicing after moving of nodes, as splicing\r\n      // can have side-effects (in the case of hashtags).\r\n      if (!firstNode.isToken()) {\r\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\r\n        if (firstNode.getTextContent() === '') {\r\n          firstNode.remove();\r\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\r\n          // When composing, we need to adjust the anchor offset so that\r\n          // we correctly replace that right range.\r\n          this.anchor.offset -= text.length;\r\n        }\r\n      } else if (startOffset === firstNodeTextLength) {\r\n        firstNode.select();\r\n      } else {\r\n        const textNode = $createTextNode(text);\r\n        textNode.select();\r\n        firstNode.replace(textNode);\r\n      }\r\n\r\n      // Remove all selected nodes that haven't already been removed.\r\n      for (let i = 1; i < selectedNodesLength; i++) {\r\n        const selectedNode = selectedNodes[i];\r\n        const key = selectedNode.__key;\r\n        if (!markedNodeKeysForKeep.has(key)) {\r\n          selectedNode.remove();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\r\n   */\r\n  removeText() {\r\n    this.insertText('');\r\n  }\r\n\r\n  /**\r\n   * Applies the provided format to the TextNodes in the Selection, splitting or\r\n   * merging nodes as necessary.\r\n   *\r\n   * @param formatType the format type to apply to the nodes in the Selection.\r\n   */\r\n  formatText(formatType) {\r\n    if (this.isCollapsed()) {\r\n      this.toggleFormat(formatType);\r\n      // When changing format, we should stop composition\r\n      $setCompositionKey(null);\r\n      return;\r\n    }\r\n    const selectedNodes = this.getNodes();\r\n    const selectedTextNodes = [];\r\n    for (const selectedNode of selectedNodes) {\r\n      if ($isTextNode(selectedNode)) {\r\n        selectedTextNodes.push(selectedNode);\r\n      }\r\n    }\r\n    const selectedTextNodesLength = selectedTextNodes.length;\r\n    if (selectedTextNodesLength === 0) {\r\n      this.toggleFormat(formatType);\r\n      // When changing format, we should stop composition\r\n      $setCompositionKey(null);\r\n      return;\r\n    }\r\n    const anchor = this.anchor;\r\n    const focus = this.focus;\r\n    const isBackward = this.isBackward();\r\n    const startPoint = isBackward ? focus : anchor;\r\n    const endPoint = isBackward ? anchor : focus;\r\n    let firstIndex = 0;\r\n    let firstNode = selectedTextNodes[0];\r\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\r\n\r\n    // In case selection started at the end of text node use next text node\r\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\r\n      firstIndex = 1;\r\n      firstNode = selectedTextNodes[1];\r\n      startOffset = 0;\r\n    }\r\n    if (firstNode == null) {\r\n      return;\r\n    }\r\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\r\n    const lastIndex = selectedTextNodesLength - 1;\r\n    let lastNode = selectedTextNodes[lastIndex];\r\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\r\n\r\n    // Single node selected\r\n    if (firstNode.is(lastNode)) {\r\n      // No actual text is selected, so do nothing.\r\n      if (startOffset === endOffset) {\r\n        return;\r\n      }\r\n      // The entire node is selected, so just format it\r\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\r\n        firstNode.setFormat(firstNextFormat);\r\n      } else {\r\n        // Node is partially selected, so split it into two nodes\r\n        // add style the selected one.\r\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\r\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\r\n        replacement.setFormat(firstNextFormat);\r\n\r\n        // Update selection only if starts/ends on text node\r\n        if (startPoint.type === 'text') {\r\n          startPoint.set(replacement.__key, 0, 'text');\r\n        }\r\n        if (endPoint.type === 'text') {\r\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\r\n        }\r\n      }\r\n      this.format = firstNextFormat;\r\n      return;\r\n    }\r\n    // Multiple nodes selected\r\n    // The entire first node isn't selected, so split it\r\n    if (startOffset !== 0) {\r\n      [, firstNode] = firstNode.splitText(startOffset);\r\n      startOffset = 0;\r\n    }\r\n    firstNode.setFormat(firstNextFormat);\r\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\r\n    // If the offset is 0, it means no actual characters are selected,\r\n    // so we skip formatting the last node altogether.\r\n    if (endOffset > 0) {\r\n      if (endOffset !== lastNode.getTextContentSize()) {\r\n        [lastNode] = lastNode.splitText(endOffset);\r\n      }\r\n      lastNode.setFormat(lastNextFormat);\r\n    }\r\n\r\n    // Process all text nodes in between\r\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\r\n      const textNode = selectedTextNodes[i];\r\n      if (!textNode.isToken()) {\r\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\r\n        textNode.setFormat(nextFormat);\r\n      }\r\n    }\r\n\r\n    // Update selection only if starts/ends on text node\r\n    if (startPoint.type === 'text') {\r\n      startPoint.set(firstNode.__key, startOffset, 'text');\r\n    }\r\n    if (endPoint.type === 'text') {\r\n      endPoint.set(lastNode.__key, endOffset, 'text');\r\n    }\r\n    this.format = firstNextFormat | lastNextFormat;\r\n  }\r\n\r\n  /**\r\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\r\n   * current Selection according to a set of heuristics that determine how surrounding nodes\r\n   * should be changed, replaced, or moved to accomodate the incoming ones.\r\n   *\r\n   * @param nodes - the nodes to insert\r\n   */\r\n  insertNodes(nodes) {\r\n    if (nodes.length === 0) {\r\n      return;\r\n    }\r\n    if (this.anchor.key === 'root') {\r\n      this.insertParagraph();\r\n      const selection = $getSelection();\r\n      if (!$isRangeSelection(selection)) {\r\n        throw Error(`Expected RangeSelection after insertParagraph`);\r\n      }\r\n      return selection.insertNodes(nodes);\r\n    }\r\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\r\n    const firstBlock = $getAncestor(firstPoint.getNode(), INTERNAL_$isBlock);\r\n    const last = nodes[nodes.length - 1];\r\n\r\n    // CASE 1: insert inside a code block\r\n    if ('__language' in firstBlock && $isElementNode(firstBlock)) {\r\n      if ('__language' in nodes[0]) {\r\n        this.insertText(nodes[0].getTextContent());\r\n      } else {\r\n        const index = removeTextAndSplitBlock(this);\r\n        firstBlock.splice(index, 0, nodes);\r\n        last.selectEnd();\r\n      }\r\n      return;\r\n    }\r\n\r\n    // CASE 2: All elements of the array are inline\r\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\r\n    if (!nodes.some(notInline)) {\r\n      if (!$isElementNode(firstBlock)) {\r\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\r\n      }\r\n      const index = removeTextAndSplitBlock(this);\r\n      firstBlock.splice(index, 0, nodes);\r\n      last.selectEnd();\r\n      return;\r\n    }\r\n\r\n    // CASE 3: At least 1 element of the array is not inline\r\n    const blocksParent = $wrapInlineNodes(nodes);\r\n    const nodeToSelect = blocksParent.getLastDescendant();\r\n    const blocks = blocksParent.getChildren();\r\n    const isLI = node => '__value' in node && '__checked' in node;\r\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || isLI(firstBlock));\r\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\r\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\r\n    const lastToInsert = blocks[blocks.length - 1];\r\n    let firstToInsert = blocks[0];\r\n    if (isMergeable(firstToInsert)) {\r\n      if (!$isElementNode(firstBlock)) {\r\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\r\n      }\r\n      firstBlock.append(...firstToInsert.getChildren());\r\n      firstToInsert = blocks[1];\r\n    }\r\n    if (firstToInsert) {\r\n      insertRangeAfter(firstBlock, firstToInsert);\r\n    }\r\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\r\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (isLI(insertedParagraph) || INTERNAL_$isBlock(lastToInsert))) {\r\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\r\n      insertedParagraph.remove();\r\n    }\r\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\r\n      firstBlock.remove();\r\n    }\r\n    nodeToSelect.selectEnd();\r\n\r\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\r\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\r\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\r\n      lastChild.remove();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\r\n   *\r\n   * @returns the newly inserted node.\r\n   */\r\n  insertParagraph() {\r\n    if (this.anchor.key === 'root') {\r\n      const paragraph = $createParagraphNode();\r\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\r\n      paragraph.select();\r\n      return paragraph;\r\n    }\r\n    const index = removeTextAndSplitBlock(this);\r\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\r\n    if (!$isElementNode(block)) {\r\n      throw Error(`Expected ancestor to be an ElementNode`);\r\n    }\r\n    const firstToAppend = block.getChildAtIndex(index);\r\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\r\n    const newBlock = block.insertNewAfter(this, false);\r\n    if (newBlock) {\r\n      newBlock.append(...nodesToInsert);\r\n      newBlock.selectStart();\r\n      return newBlock;\r\n    }\r\n    // if newBlock is null, it means that block is of type CodeNode.\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\r\n   * current Selection.\r\n   */\r\n  insertLineBreak(selectStart) {\r\n    const lineBreak = $createLineBreakNode();\r\n    this.insertNodes([lineBreak]);\r\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\r\n    if (selectStart) {\r\n      const parent = lineBreak.getParentOrThrow();\r\n      const index = lineBreak.getIndexWithinParent();\r\n      parent.select(index, index);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extracts the nodes in the Selection, splitting nodes where necessary\r\n   * to get offset-level precision.\r\n   *\r\n   * @returns The nodes in the Selection\r\n   */\r\n  extract() {\r\n    const selectedNodes = this.getNodes();\r\n    const selectedNodesLength = selectedNodes.length;\r\n    const lastIndex = selectedNodesLength - 1;\r\n    const anchor = this.anchor;\r\n    const focus = this.focus;\r\n    let firstNode = selectedNodes[0];\r\n    let lastNode = selectedNodes[lastIndex];\r\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\r\n    if (selectedNodesLength === 0) {\r\n      return [];\r\n    } else if (selectedNodesLength === 1) {\r\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\r\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\r\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\r\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\r\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\r\n        return node != null ? [node] : [];\r\n      }\r\n      return [firstNode];\r\n    }\r\n    const isBefore = anchor.isBefore(focus);\r\n    if ($isTextNode(firstNode)) {\r\n      const startOffset = isBefore ? anchorOffset : focusOffset;\r\n      if (startOffset === firstNode.getTextContentSize()) {\r\n        selectedNodes.shift();\r\n      } else if (startOffset !== 0) {\r\n        [, firstNode] = firstNode.splitText(startOffset);\r\n        selectedNodes[0] = firstNode;\r\n      }\r\n    }\r\n    if ($isTextNode(lastNode)) {\r\n      const lastNodeText = lastNode.getTextContent();\r\n      const lastNodeTextLength = lastNodeText.length;\r\n      const endOffset = isBefore ? focusOffset : anchorOffset;\r\n      if (endOffset === 0) {\r\n        selectedNodes.pop();\r\n      } else if (endOffset !== lastNodeTextLength) {\r\n        [lastNode] = lastNode.splitText(endOffset);\r\n        selectedNodes[lastIndex] = lastNode;\r\n      }\r\n    }\r\n    return selectedNodes;\r\n  }\r\n\r\n  /**\r\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\r\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\r\n   * dealing explicitly with all the possible node types.\r\n   *\r\n   * @param alter the type of modification to perform\r\n   * @param isBackward whether or not selection is backwards\r\n   * @param granularity the granularity at which to apply the modification\r\n   */\r\n  modify(alter, isBackward, granularity) {\r\n    const focus = this.focus;\r\n    const anchor = this.anchor;\r\n    const collapse = alter === 'move';\r\n\r\n    // Handle the selection movement around decorators.\r\n    const possibleNode = $getAdjacentNode(focus, isBackward);\r\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\r\n      // Make it possible to move selection from range selection to\r\n      // node selection on the node.\r\n      if (collapse && possibleNode.isKeyboardSelectable()) {\r\n        const nodeSelection = $createNodeSelection();\r\n        nodeSelection.add(possibleNode.__key);\r\n        $setSelection(nodeSelection);\r\n        return;\r\n      }\r\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\r\n      if (!$isTextNode(sibling)) {\r\n        const parent = possibleNode.getParentOrThrow();\r\n        let offset;\r\n        let elementKey;\r\n        if ($isElementNode(sibling)) {\r\n          elementKey = sibling.__key;\r\n          offset = isBackward ? sibling.getChildrenSize() : 0;\r\n        } else {\r\n          offset = possibleNode.getIndexWithinParent();\r\n          elementKey = parent.__key;\r\n          if (!isBackward) {\r\n            offset++;\r\n          }\r\n        }\r\n        focus.set(elementKey, offset, 'element');\r\n        if (collapse) {\r\n          anchor.set(elementKey, offset, 'element');\r\n        }\r\n        return;\r\n      } else {\r\n        const siblingKey = sibling.__key;\r\n        const offset = isBackward ? sibling.getTextContent().length : 0;\r\n        focus.set(siblingKey, offset, 'text');\r\n        if (collapse) {\r\n          anchor.set(siblingKey, offset, 'text');\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    const editor = getActiveEditor();\r\n    const domSelection = getDOMSelection(editor._window);\r\n    if (!domSelection) {\r\n      return;\r\n    }\r\n    const blockCursorElement = editor._blockCursorElement;\r\n    const rootElement = editor._rootElement;\r\n    // Remove the block cursor element if it exists. This will ensure selection\r\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\r\n    // occur. :/\r\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\r\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\r\n    }\r\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\r\n    // will be. We then use it to update the Lexical selection accordingly. This\r\n    // is much more reliable than waiting for a beforeinput and using the ranges\r\n    // from getTargetRanges(), and is also better than trying to do it ourselves\r\n    // using Intl.Segmenter or other workarounds that struggle with word segments\r\n    // and line segments (especially with word wrapping and non-Roman languages).\r\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\r\n    // Guard against no ranges\r\n    if (domSelection.rangeCount > 0) {\r\n      const range = domSelection.getRangeAt(0);\r\n      // Apply the DOM selection to our Lexical selection.\r\n      const anchorNode = this.anchor.getNode();\r\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\r\n      this.applyDOMRange(range);\r\n      this.dirty = true;\r\n      if (!collapse) {\r\n        // Validate selection; make sure that the new extended selection respects shadow roots\r\n        const nodes = this.getNodes();\r\n        const validNodes = [];\r\n        let shrinkSelection = false;\r\n        for (let i = 0; i < nodes.length; i++) {\r\n          const nextNode = nodes[i];\r\n          if ($hasAncestor(nextNode, root)) {\r\n            validNodes.push(nextNode);\r\n          } else {\r\n            shrinkSelection = true;\r\n          }\r\n        }\r\n        if (shrinkSelection && validNodes.length > 0) {\r\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\r\n          // will return an empty array in this case\r\n          if (isBackward) {\r\n            const firstValidNode = validNodes[0];\r\n            if ($isElementNode(firstValidNode)) {\r\n              firstValidNode.selectStart();\r\n            } else {\r\n              firstValidNode.getParentOrThrow().selectStart();\r\n            }\r\n          } else {\r\n            const lastValidNode = validNodes[validNodes.length - 1];\r\n            if ($isElementNode(lastValidNode)) {\r\n              lastValidNode.selectEnd();\r\n            } else {\r\n              lastValidNode.getParentOrThrow().selectEnd();\r\n            }\r\n          }\r\n        }\r\n\r\n        // Because a range works on start and end, we might need to flip\r\n        // the anchor and focus points to match what the DOM has, not what\r\n        // the range has specifically.\r\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\r\n          $swapPoints(this);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\r\n   * Handles different node types.\r\n   *\r\n   * @param isBackward whether or not the selection is backwards.\r\n   */\r\n  deleteCharacter(isBackward) {\r\n    const wasCollapsed = this.isCollapsed();\r\n    if (this.isCollapsed()) {\r\n      const anchor = this.anchor;\r\n      const focus = this.focus;\r\n      let anchorNode = anchor.getNode();\r\n      if (!isBackward && (\r\n      // Delete forward handle case\r\n      anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\r\n        const parent = anchorNode.getParent();\r\n        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\r\n        if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\r\n          return;\r\n        }\r\n      }\r\n      // Handle the deletion around decorators.\r\n      const possibleNode = $getAdjacentNode(focus, isBackward);\r\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\r\n        // Make it possible to move selection from range selection to\r\n        // node selection on the node.\r\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\r\n          anchorNode.remove();\r\n          const nodeSelection = $createNodeSelection();\r\n          nodeSelection.add(possibleNode.__key);\r\n          $setSelection(nodeSelection);\r\n        } else {\r\n          possibleNode.remove();\r\n          const editor = getActiveEditor();\r\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\r\n        }\r\n        return;\r\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\r\n        anchorNode.remove();\r\n        possibleNode.selectStart();\r\n        return;\r\n      }\r\n      this.modify('extend', isBackward, 'character');\r\n      if (!this.isCollapsed()) {\r\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\r\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\r\n        if (focusNode !== null && focusNode.isSegmented()) {\r\n          const offset = focus.offset;\r\n          const textContentSize = focusNode.getTextContentSize();\r\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\r\n            $removeSegment(focusNode, isBackward, offset);\r\n            return;\r\n          }\r\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\r\n          const offset = anchor.offset;\r\n          const textContentSize = anchorNode.getTextContentSize();\r\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\r\n            $removeSegment(anchorNode, isBackward, offset);\r\n            return;\r\n          }\r\n        }\r\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\r\n      } else if (isBackward && anchor.offset === 0) {\r\n        // Special handling around rich text nodes\r\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\r\n        if (element.collapseAtStart(this)) {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n    this.removeText();\r\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\r\n      const anchorNode = this.anchor.getNode();\r\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\r\n        anchorNode.collapseAtStart(this);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\r\n   * Handles different node types.\r\n   *\r\n   * @param isBackward whether or not the selection is backwards.\r\n   */\r\n  deleteLine(isBackward) {\r\n    if (this.isCollapsed()) {\r\n      if (this.anchor.type === 'text') {\r\n        this.modify('extend', isBackward, 'lineboundary');\r\n      }\r\n\r\n      // If selection is extended to cover text edge then extend it one character more\r\n      // to delete its parent element. Otherwise text content will be deleted but empty\r\n      // parent node will remain\r\n      const endPoint = isBackward ? this.focus : this.anchor;\r\n      if (endPoint.offset === 0) {\r\n        this.modify('extend', isBackward, 'character');\r\n      }\r\n    }\r\n    this.removeText();\r\n  }\r\n\r\n  /**\r\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\r\n   * Handles different node types.\r\n   *\r\n   * @param isBackward whether or not the selection is backwards.\r\n   */\r\n  deleteWord(isBackward) {\r\n    if (this.isCollapsed()) {\r\n      this.modify('extend', isBackward, 'word');\r\n    }\r\n    this.removeText();\r\n  }\r\n\r\n  /**\r\n   * Returns whether the Selection is \"backwards\", meaning the focus\r\n   * logically precedes the anchor in the EditorState.\r\n   * @returns true if the Selection is backwards, false otherwise.\r\n   */\r\n  isBackward() {\r\n    return this.focus.isBefore(this.anchor);\r\n  }\r\n  getStartEndPoints() {\r\n    return [this.anchor, this.focus];\r\n  }\r\n}\r\nfunction $isNodeSelection(x) {\r\n  return x instanceof NodeSelection;\r\n}\r\nfunction getCharacterOffset(point) {\r\n  const offset = point.offset;\r\n  if (point.type === 'text') {\r\n    return offset;\r\n  }\r\n  const parent = point.getNode();\r\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\r\n}\r\nfunction $getCharacterOffsets(selection) {\r\n  const anchorAndFocus = selection.getStartEndPoints();\r\n  if (anchorAndFocus === null) {\r\n    return [0, 0];\r\n  }\r\n  const [anchor, focus] = anchorAndFocus;\r\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\r\n    return [0, 0];\r\n  }\r\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\r\n}\r\nfunction $swapPoints(selection) {\r\n  const focus = selection.focus;\r\n  const anchor = selection.anchor;\r\n  const anchorKey = anchor.key;\r\n  const anchorOffset = anchor.offset;\r\n  const anchorType = anchor.type;\r\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\r\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\r\n  selection._cachedNodes = null;\r\n}\r\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\r\n  // Selection.modify() method applies a change to the current selection or cursor position,\r\n  // but is still non-standard in some browsers.\r\n  domSelection.modify(alter, direction, granularity);\r\n}\r\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\r\n  const anchor = selection.anchor;\r\n  const focus = selection.focus;\r\n  const anchorNode = anchor.getNode();\r\n  const focusNode = focus.getNode();\r\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\r\n    // Handling of multibyte characters\r\n    const anchorOffset = anchor.offset;\r\n    const focusOffset = focus.offset;\r\n    const isBefore = anchorOffset < focusOffset;\r\n    const startOffset = isBefore ? anchorOffset : focusOffset;\r\n    const endOffset = isBefore ? focusOffset : anchorOffset;\r\n    const characterOffset = endOffset - 1;\r\n    if (startOffset !== characterOffset) {\r\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\r\n      if (!doesContainGrapheme(text)) {\r\n        if (isBackward) {\r\n          focus.offset = characterOffset;\r\n        } else {\r\n          anchor.offset = characterOffset;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction $removeSegment(node, isBackward, offset) {\r\n  const textNode = node;\r\n  const textContent = textNode.getTextContent();\r\n  const split = textContent.split(/(?=\\s)/g);\r\n  const splitLength = split.length;\r\n  let segmentOffset = 0;\r\n  let restoreOffset = 0;\r\n  for (let i = 0; i < splitLength; i++) {\r\n    const text = split[i];\r\n    const isLast = i === splitLength - 1;\r\n    restoreOffset = segmentOffset;\r\n    segmentOffset += text.length;\r\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\r\n      split.splice(i, 1);\r\n      if (isLast) {\r\n        restoreOffset = undefined;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  const nextTextContent = split.join('').trim();\r\n  if (nextTextContent === '') {\r\n    textNode.remove();\r\n  } else {\r\n    textNode.setTextContent(nextTextContent);\r\n    textNode.select(restoreOffset, restoreOffset);\r\n  }\r\n}\r\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\r\n  const parent = resolvedElement.getParent();\r\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\r\n}\r\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\r\n  let resolvedOffset = offset;\r\n  let resolvedNode;\r\n  // If we have selection on an element, we will\r\n  // need to figure out (using the offset) what text\r\n  // node should be selected.\r\n\r\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\r\n    // Resolve element to a ElementNode, or TextNode, or null\r\n    let moveSelectionToEnd = false;\r\n    // Given we're moving selection to another node, selection is\r\n    // definitely dirty.\r\n    // We use the anchor to find which child node to select\r\n    const childNodes = dom.childNodes;\r\n    const childNodesLength = childNodes.length;\r\n    // If the anchor is the same as length, then this means we\r\n    // need to select the very last text node.\r\n    if (resolvedOffset === childNodesLength) {\r\n      moveSelectionToEnd = true;\r\n      resolvedOffset = childNodesLength - 1;\r\n    }\r\n    let childDOM = childNodes[resolvedOffset];\r\n    let hasBlockCursor = false;\r\n    if (childDOM === editor._blockCursorElement) {\r\n      childDOM = childNodes[resolvedOffset + 1];\r\n      hasBlockCursor = true;\r\n    } else if (editor._blockCursorElement !== null) {\r\n      resolvedOffset--;\r\n    }\r\n    resolvedNode = getNodeFromDOM(childDOM);\r\n    if ($isTextNode(resolvedNode)) {\r\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\r\n    } else {\r\n      let resolvedElement = getNodeFromDOM(dom);\r\n      // Ensure resolvedElement is actually a element.\r\n      if (resolvedElement === null) {\r\n        return null;\r\n      }\r\n      if ($isElementNode(resolvedElement)) {\r\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\r\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\r\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\r\n          if (descendant === null) {\r\n            resolvedElement = child;\r\n            resolvedOffset = 0;\r\n          } else {\r\n            child = descendant;\r\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\r\n          }\r\n        }\r\n        if ($isTextNode(child)) {\r\n          resolvedNode = child;\r\n          resolvedElement = null;\r\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\r\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\r\n          resolvedOffset++;\r\n        }\r\n      } else {\r\n        const index = resolvedElement.getIndexWithinParent();\r\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\r\n        // and instead we should be checking if we're using the offset\r\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\r\n          resolvedOffset = index;\r\n        } else {\r\n          resolvedOffset = index + 1;\r\n        }\r\n        resolvedElement = resolvedElement.getParentOrThrow();\r\n      }\r\n      if ($isElementNode(resolvedElement)) {\r\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\r\n      }\r\n    }\r\n  } else {\r\n    // TextNode or null\r\n    resolvedNode = getNodeFromDOM(dom);\r\n  }\r\n  if (!$isTextNode(resolvedNode)) {\r\n    return null;\r\n  }\r\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\r\n}\r\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\r\n  const offset = point.offset;\r\n  const node = point.getNode();\r\n  if (offset === 0) {\r\n    const prevSibling = node.getPreviousSibling();\r\n    const parent = node.getParent();\r\n    if (!isBackward) {\r\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\r\n        point.key = prevSibling.__key;\r\n        point.offset = prevSibling.getChildrenSize();\r\n        // @ts-expect-error: intentional\r\n        point.type = 'element';\r\n      } else if ($isTextNode(prevSibling)) {\r\n        point.key = prevSibling.__key;\r\n        point.offset = prevSibling.getTextContent().length;\r\n      }\r\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\r\n      const parentSibling = parent.getPreviousSibling();\r\n      if ($isTextNode(parentSibling)) {\r\n        point.key = parentSibling.__key;\r\n        point.offset = parentSibling.getTextContent().length;\r\n      }\r\n    }\r\n  } else if (offset === node.getTextContent().length) {\r\n    const nextSibling = node.getNextSibling();\r\n    const parent = node.getParent();\r\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\r\n      point.key = nextSibling.__key;\r\n      point.offset = 0;\r\n      // @ts-expect-error: intentional\r\n      point.type = 'element';\r\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\r\n      const parentSibling = parent.getNextSibling();\r\n      if ($isTextNode(parentSibling)) {\r\n        point.key = parentSibling.__key;\r\n        point.offset = 0;\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\r\n  if (anchor.type === 'text' && focus.type === 'text') {\r\n    const isBackward = anchor.isBefore(focus);\r\n    const isCollapsed = anchor.is(focus);\r\n\r\n    // Attempt to normalize the offset to the previous sibling if we're at the\r\n    // start of a text node and the sibling is a text node or inline element.\r\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\r\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\r\n    if (isCollapsed) {\r\n      focus.key = anchor.key;\r\n      focus.offset = anchor.offset;\r\n      focus.type = anchor.type;\r\n    }\r\n    const editor = getActiveEditor();\r\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\r\n      const lastAnchor = lastSelection.anchor;\r\n      const lastFocus = lastSelection.focus;\r\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\r\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\r\n    }\r\n  }\r\n}\r\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\r\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\r\n    return null;\r\n  }\r\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\r\n  if (resolvedAnchorPoint === null) {\r\n    return null;\r\n  }\r\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\r\n  if (resolvedFocusPoint === null) {\r\n    return null;\r\n  }\r\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\r\n    const anchorNode = getNodeFromDOM(anchorDOM);\r\n    const focusNode = getNodeFromDOM(focusDOM);\r\n    // Ensure if we're selecting the content of a decorator that we\r\n    // return null for this point, as it's not in the controlled scope\r\n    // of Lexical.\r\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Handle normalization of selection when it is at the boundaries.\r\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\r\n  return [resolvedAnchorPoint, resolvedFocusPoint];\r\n}\r\nfunction $isBlockElementNode(node) {\r\n  return $isElementNode(node) && !node.isInline();\r\n}\r\n\r\n// This is used to make a selection when the existing\r\n// selection is null, i.e. forcing selection on the editor\r\n// when it current exists outside the editor.\r\n\r\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\r\n  const editorState = getActiveEditorState();\r\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\r\n  selection.dirty = true;\r\n  editorState._selection = selection;\r\n  return selection;\r\n}\r\nfunction $createRangeSelection() {\r\n  const anchor = $createPoint('root', 0, 'element');\r\n  const focus = $createPoint('root', 0, 'element');\r\n  return new RangeSelection(anchor, focus, 0, '');\r\n}\r\nfunction $createNodeSelection() {\r\n  return new NodeSelection(new Set());\r\n}\r\nfunction internalCreateSelection(editor) {\r\n  const currentEditorState = editor.getEditorState();\r\n  const lastSelection = currentEditorState._selection;\r\n  const domSelection = getDOMSelection(editor._window);\r\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\r\n    return internalCreateRangeSelection(lastSelection, domSelection, editor, null);\r\n  }\r\n  return lastSelection.clone();\r\n}\r\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\r\n  const windowObj = editor._window;\r\n  if (windowObj === null) {\r\n    return null;\r\n  }\r\n  // When we create a selection, we try to use the previous\r\n  // selection where possible, unless an actual user selection\r\n  // change has occurred. When we do need to create a new selection\r\n  // we validate we can have text nodes for both anchor and focus\r\n  // nodes. If that holds true, we then return that selection\r\n  // as a mutable object that we use for the editor state for this\r\n  // update cycle. If a selection gets changed, and requires a\r\n  // update to native DOM selection, it gets marked as \"dirty\".\r\n  // If the selection changes, but matches with the existing\r\n  // DOM selection, then we only need to sync it. Otherwise,\r\n  // we generally bail out of doing an update to selection during\r\n  // reconciliation unless there are dirty nodes that need\r\n  // reconciling.\r\n\r\n  const windowEvent = event || windowObj.event;\r\n  const eventType = windowEvent ? windowEvent.type : undefined;\r\n  const isSelectionChange = eventType === 'selectionchange';\r\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\r\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\r\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\r\n    if (domSelection === null) {\r\n      return null;\r\n    }\r\n    anchorDOM = domSelection.anchorNode;\r\n    focusDOM = domSelection.focusNode;\r\n    anchorOffset = domSelection.anchorOffset;\r\n    focusOffset = domSelection.focusOffset;\r\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\r\n      return lastSelection.clone();\r\n    }\r\n  } else {\r\n    return lastSelection.clone();\r\n  }\r\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\r\n  // native selection.\r\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\r\n  if (resolvedSelectionPoints === null) {\r\n    return null;\r\n  }\r\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\r\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\r\n}\r\nfunction $getSelection() {\r\n  const editorState = getActiveEditorState();\r\n  return editorState._selection;\r\n}\r\nfunction $getPreviousSelection() {\r\n  const editor = getActiveEditor();\r\n  return editor._editorState._selection;\r\n}\r\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\r\n  const anchor = selection.anchor;\r\n  const focus = selection.focus;\r\n  const anchorNode = anchor.getNode();\r\n  const focusNode = focus.getNode();\r\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\r\n    return;\r\n  }\r\n  const parentKey = parentNode.__key;\r\n  // Single node. We shift selection but never redimension it\r\n  if (selection.isCollapsed()) {\r\n    const selectionOffset = anchor.offset;\r\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\r\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\r\n      anchor.set(parentKey, newSelectionOffset, 'element');\r\n      focus.set(parentKey, newSelectionOffset, 'element');\r\n      // The new selection might point to text nodes, try to resolve them\r\n      $updateSelectionResolveTextNodes(selection);\r\n    }\r\n  } else {\r\n    // Multiple nodes selected. We shift or redimension selection\r\n    const isBackward = selection.isBackward();\r\n    const firstPoint = isBackward ? focus : anchor;\r\n    const firstPointNode = firstPoint.getNode();\r\n    const lastPoint = isBackward ? anchor : focus;\r\n    const lastPointNode = lastPoint.getNode();\r\n    if (parentNode.is(firstPointNode)) {\r\n      const firstPointOffset = firstPoint.offset;\r\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\r\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\r\n      }\r\n    }\r\n    if (parentNode.is(lastPointNode)) {\r\n      const lastPointOffset = lastPoint.offset;\r\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\r\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\r\n      }\r\n    }\r\n  }\r\n  // The new selection might point to text nodes, try to resolve them\r\n  $updateSelectionResolveTextNodes(selection);\r\n}\r\nfunction $updateSelectionResolveTextNodes(selection) {\r\n  const anchor = selection.anchor;\r\n  const anchorOffset = anchor.offset;\r\n  const focus = selection.focus;\r\n  const focusOffset = focus.offset;\r\n  const anchorNode = anchor.getNode();\r\n  const focusNode = focus.getNode();\r\n  if (selection.isCollapsed()) {\r\n    if (!$isElementNode(anchorNode)) {\r\n      return;\r\n    }\r\n    const childSize = anchorNode.getChildrenSize();\r\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\r\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\r\n    if ($isTextNode(child)) {\r\n      let newOffset = 0;\r\n      if (anchorOffsetAtEnd) {\r\n        newOffset = child.getTextContentSize();\r\n      }\r\n      anchor.set(child.__key, newOffset, 'text');\r\n      focus.set(child.__key, newOffset, 'text');\r\n    }\r\n    return;\r\n  }\r\n  if ($isElementNode(anchorNode)) {\r\n    const childSize = anchorNode.getChildrenSize();\r\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\r\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\r\n    if ($isTextNode(child)) {\r\n      let newOffset = 0;\r\n      if (anchorOffsetAtEnd) {\r\n        newOffset = child.getTextContentSize();\r\n      }\r\n      anchor.set(child.__key, newOffset, 'text');\r\n    }\r\n  }\r\n  if ($isElementNode(focusNode)) {\r\n    const childSize = focusNode.getChildrenSize();\r\n    const focusOffsetAtEnd = focusOffset >= childSize;\r\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\r\n    if ($isTextNode(child)) {\r\n      let newOffset = 0;\r\n      if (focusOffsetAtEnd) {\r\n        newOffset = child.getTextContentSize();\r\n      }\r\n      focus.set(child.__key, newOffset, 'text');\r\n    }\r\n  }\r\n}\r\nfunction applySelectionTransforms(nextEditorState, editor) {\r\n  const prevEditorState = editor.getEditorState();\r\n  const prevSelection = prevEditorState._selection;\r\n  const nextSelection = nextEditorState._selection;\r\n  if ($isRangeSelection(nextSelection)) {\r\n    const anchor = nextSelection.anchor;\r\n    const focus = nextSelection.focus;\r\n    let anchorNode;\r\n    if (anchor.type === 'text') {\r\n      anchorNode = anchor.getNode();\r\n      anchorNode.selectionTransform(prevSelection, nextSelection);\r\n    }\r\n    if (focus.type === 'text') {\r\n      const focusNode = focus.getNode();\r\n      if (anchorNode !== focusNode) {\r\n        focusNode.selectionTransform(prevSelection, nextSelection);\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\r\n  let siblingKey = null;\r\n  let offset = 0;\r\n  let type = null;\r\n  if (prevSibling !== null) {\r\n    siblingKey = prevSibling.__key;\r\n    if ($isTextNode(prevSibling)) {\r\n      offset = prevSibling.getTextContentSize();\r\n      type = 'text';\r\n    } else if ($isElementNode(prevSibling)) {\r\n      offset = prevSibling.getChildrenSize();\r\n      type = 'element';\r\n    }\r\n  } else {\r\n    if (nextSibling !== null) {\r\n      siblingKey = nextSibling.__key;\r\n      if ($isTextNode(nextSibling)) {\r\n        type = 'text';\r\n      } else if ($isElementNode(nextSibling)) {\r\n        type = 'element';\r\n      }\r\n    }\r\n  }\r\n  if (siblingKey !== null && type !== null) {\r\n    point.set(siblingKey, offset, type);\r\n  } else {\r\n    offset = node.getIndexWithinParent();\r\n    if (offset === -1) {\r\n      // Move selection to end of parent\r\n      offset = parent.getChildrenSize();\r\n    }\r\n    point.set(parent.__key, offset, 'element');\r\n  }\r\n}\r\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\r\n  if (point.type === 'text') {\r\n    point.key = key;\r\n    if (!isBefore) {\r\n      point.offset += textLength;\r\n    }\r\n  } else if (point.offset > target.getIndexWithinParent()) {\r\n    point.offset -= 1;\r\n  }\r\n}\r\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\r\n  const anchorDOMNode = domSelection.anchorNode;\r\n  const focusDOMNode = domSelection.focusNode;\r\n  const anchorOffset = domSelection.anchorOffset;\r\n  const focusOffset = domSelection.focusOffset;\r\n  const activeElement = document.activeElement;\r\n\r\n  // TODO: make this not hard-coded, and add another config option\r\n  // that makes this configurable.\r\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\r\n    return;\r\n  }\r\n  if (!$isRangeSelection(nextSelection)) {\r\n    // We don't remove selection if the prevSelection is null because\r\n    // of editor.setRootElement(). If this occurs on init when the\r\n    // editor is already focused, then this can cause the editor to\r\n    // lose focus.\r\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\r\n      domSelection.removeAllRanges();\r\n    }\r\n    return;\r\n  }\r\n  const anchor = nextSelection.anchor;\r\n  const focus = nextSelection.focus;\r\n  const anchorKey = anchor.key;\r\n  const focusKey = focus.key;\r\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\r\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\r\n  const nextAnchorOffset = anchor.offset;\r\n  const nextFocusOffset = focus.offset;\r\n  const nextFormat = nextSelection.format;\r\n  const nextStyle = nextSelection.style;\r\n  const isCollapsed = nextSelection.isCollapsed();\r\n  let nextAnchorNode = anchorDOM;\r\n  let nextFocusNode = focusDOM;\r\n  let anchorFormatOrStyleChanged = false;\r\n  if (anchor.type === 'text') {\r\n    nextAnchorNode = getDOMTextNode(anchorDOM);\r\n    const anchorNode = anchor.getNode();\r\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\r\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\r\n    anchorFormatOrStyleChanged = true;\r\n  }\r\n  if (focus.type === 'text') {\r\n    nextFocusNode = getDOMTextNode(focusDOM);\r\n  }\r\n\r\n  // If we can't get an underlying text node for selection, then\r\n  // we should avoid setting selection to something incorrect.\r\n  if (nextAnchorNode === null || nextFocusNode === null) {\r\n    return;\r\n  }\r\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\r\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\r\n  }\r\n\r\n  // Diff against the native DOM selection to ensure we don't do\r\n  // an unnecessary selection update. We also skip this check if\r\n  // we're moving selection to within an element, as this can\r\n  // sometimes be problematic around scrolling.\r\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\r\n  // Badly interpreted range selection when collapsed - #1482\r\n  !(domSelection.type === 'Range' && isCollapsed)) {\r\n    // If the root element does not have focus, ensure it has focus\r\n    if (activeElement === null || !rootElement.contains(activeElement)) {\r\n      rootElement.focus({\r\n        preventScroll: true\r\n      });\r\n    }\r\n    if (anchor.type !== 'element') {\r\n      return;\r\n    }\r\n  }\r\n\r\n  // Apply the updated selection to the DOM. Note: this will trigger\r\n  // a \"selectionchange\" event, although it will be asynchronous.\r\n  try {\r\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\r\n  } catch (error) {\r\n    // If we encounter an error, continue. This can sometimes\r\n    // occur with FF and there's no good reason as to why it\r\n    // should happen.\r\n  }\r\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\r\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\r\n    if (selectionTarget !== null) {\r\n      let selectionRect;\r\n      if (selectionTarget instanceof Text) {\r\n        const range = document.createRange();\r\n        range.selectNode(selectionTarget);\r\n        selectionRect = range.getBoundingClientRect();\r\n      } else {\r\n        selectionRect = selectionTarget.getBoundingClientRect();\r\n      }\r\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\r\n    }\r\n  }\r\n  markSelectionChangeFromDOMUpdate();\r\n}\r\nfunction $insertNodes(nodes) {\r\n  let selection = $getSelection() || $getPreviousSelection();\r\n  if (selection === null) {\r\n    selection = $getRoot().selectEnd();\r\n  }\r\n  selection.insertNodes(nodes);\r\n}\r\nfunction $getTextContent() {\r\n  const selection = $getSelection();\r\n  if (selection === null) {\r\n    return '';\r\n  }\r\n  return selection.getTextContent();\r\n}\r\nfunction removeTextAndSplitBlock(selection) {\r\n  if (!selection.isCollapsed()) {\r\n    selection.removeText();\r\n  }\r\n  const anchor = selection.anchor;\r\n  let node = anchor.getNode();\r\n  let offset = anchor.offset;\r\n  while (!INTERNAL_$isBlock(node)) {\r\n    [node, offset] = splitNodeAtPoint(node, offset);\r\n  }\r\n  return offset;\r\n}\r\nfunction splitNodeAtPoint(node, offset) {\r\n  const parent = node.getParent();\r\n  if (!parent) {\r\n    const paragraph = $createParagraphNode();\r\n    $getRoot().append(paragraph);\r\n    paragraph.select();\r\n    return [$getRoot(), 0];\r\n  }\r\n  if ($isTextNode(node)) {\r\n    const split = node.splitText(offset);\r\n    if (split.length === 0) {\r\n      return [parent, node.getIndexWithinParent()];\r\n    }\r\n    const x = offset === 0 ? 0 : 1;\r\n    const index = split[0].getIndexWithinParent() + x;\r\n    return [parent, index];\r\n  }\r\n  if (!$isElementNode(node) || offset === 0) {\r\n    return [parent, node.getIndexWithinParent()];\r\n  }\r\n  const firstToAppend = node.getChildAtIndex(offset);\r\n  if (firstToAppend) {\r\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\r\n    const newElement = node.insertNewAfter(insertPoint);\r\n    if (newElement) {\r\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\r\n    }\r\n  }\r\n  return [parent, node.getIndexWithinParent() + 1];\r\n}\r\nfunction $wrapInlineNodes(nodes) {\r\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\r\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\r\n  const virtualRoot = $createParagraphNode();\r\n  let currentBlock = null;\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n    const isLineBreakNode = $isLineBreakNode(node);\r\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\r\n      if (currentBlock === null) {\r\n        currentBlock = node.createParentElementNode();\r\n        virtualRoot.append(currentBlock);\r\n        // In the case of LineBreakNode, we just need to\r\n        // add an empty ParagraphNode to the topLevelBlocks.\r\n        if (isLineBreakNode) {\r\n          continue;\r\n        }\r\n      }\r\n      if (currentBlock !== null) {\r\n        currentBlock.append(node);\r\n      }\r\n    } else {\r\n      virtualRoot.append(node);\r\n      currentBlock = null;\r\n    }\r\n  }\r\n  return virtualRoot;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nlet activeEditorState = null;\r\nlet activeEditor = null;\r\nlet isReadOnlyMode = false;\r\nlet isAttemptingToRecoverFromReconcilerError = false;\r\nlet infiniteTransformCount = 0;\r\nconst observerOptions = {\r\n  characterData: true,\r\n  childList: true,\r\n  subtree: true\r\n};\r\nfunction isCurrentlyReadOnlyMode() {\r\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\r\n}\r\nfunction errorOnReadOnly() {\r\n  if (isReadOnlyMode) {\r\n    {\r\n      throw Error(`Cannot use method in read-only mode.`);\r\n    }\r\n  }\r\n}\r\nfunction errorOnInfiniteTransforms() {\r\n  if (infiniteTransformCount > 99) {\r\n    {\r\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\r\n    }\r\n  }\r\n}\r\nfunction getActiveEditorState() {\r\n  if (activeEditorState === null) {\r\n    {\r\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\r\n    }\r\n  }\r\n  return activeEditorState;\r\n}\r\nfunction getActiveEditor() {\r\n  if (activeEditor === null) {\r\n    {\r\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\r\n    }\r\n  }\r\n  return activeEditor;\r\n}\r\nfunction internalGetActiveEditor() {\r\n  return activeEditor;\r\n}\r\nfunction $applyTransforms(editor, node, transformsCache) {\r\n  const type = node.__type;\r\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\r\n  let transformsArr = transformsCache.get(type);\r\n  if (transformsArr === undefined) {\r\n    transformsArr = Array.from(registeredNode.transforms);\r\n    transformsCache.set(type, transformsArr);\r\n  }\r\n  const transformsArrLength = transformsArr.length;\r\n  for (let i = 0; i < transformsArrLength; i++) {\r\n    transformsArr[i](node);\r\n    if (!node.isAttached()) {\r\n      break;\r\n    }\r\n  }\r\n}\r\nfunction $isNodeValidForTransform(node, compositionKey) {\r\n  return node !== undefined &&\r\n  // We don't want to transform nodes being composed\r\n  node.__key !== compositionKey && node.isAttached();\r\n}\r\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\r\n  const dirtyLeaves = editor._dirtyLeaves;\r\n  const nodeMap = editorState._nodeMap;\r\n  for (const nodeKey of dirtyLeaves) {\r\n    const node = nodeMap.get(nodeKey);\r\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\r\n      $normalizeTextNode(node);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Transform heuristic:\r\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\r\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\r\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\r\n * If element transforms only generate additional dirty elements we only repeat step 2.\r\n *\r\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\r\n * editor._subtrees which we reset in every loop.\r\n */\r\nfunction $applyAllTransforms(editorState, editor) {\r\n  const dirtyLeaves = editor._dirtyLeaves;\r\n  const dirtyElements = editor._dirtyElements;\r\n  const nodeMap = editorState._nodeMap;\r\n  const compositionKey = $getCompositionKey();\r\n  const transformsCache = new Map();\r\n  let untransformedDirtyLeaves = dirtyLeaves;\r\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\r\n  let untransformedDirtyElements = dirtyElements;\r\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\r\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\r\n    if (untransformedDirtyLeavesLength > 0) {\r\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\r\n      editor._dirtyLeaves = new Set();\r\n      for (const nodeKey of untransformedDirtyLeaves) {\r\n        const node = nodeMap.get(nodeKey);\r\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\r\n          $normalizeTextNode(node);\r\n        }\r\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\r\n          $applyTransforms(editor, node, transformsCache);\r\n        }\r\n        dirtyLeaves.add(nodeKey);\r\n      }\r\n      untransformedDirtyLeaves = editor._dirtyLeaves;\r\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\r\n\r\n      // We want to prioritize node transforms over element transforms\r\n      if (untransformedDirtyLeavesLength > 0) {\r\n        infiniteTransformCount++;\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // All dirty leaves have been processed. Let's do elements!\r\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\r\n    // new ones caused by element transforms\r\n    editor._dirtyLeaves = new Set();\r\n    editor._dirtyElements = new Map();\r\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\r\n      const nodeKey = currentUntransformedDirtyElement[0];\r\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\r\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\r\n        continue;\r\n      }\r\n      const node = nodeMap.get(nodeKey);\r\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\r\n        $applyTransforms(editor, node, transformsCache);\r\n      }\r\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\r\n    }\r\n    untransformedDirtyLeaves = editor._dirtyLeaves;\r\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\r\n    untransformedDirtyElements = editor._dirtyElements;\r\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\r\n    infiniteTransformCount++;\r\n  }\r\n  editor._dirtyLeaves = dirtyLeaves;\r\n  editor._dirtyElements = dirtyElements;\r\n}\r\nfunction $parseSerializedNode(serializedNode) {\r\n  const internalSerializedNode = serializedNode;\r\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\r\n}\r\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\r\n  const type = serializedNode.type;\r\n  const registeredNode = registeredNodes.get(type);\r\n  if (registeredNode === undefined) {\r\n    {\r\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\r\n    }\r\n  }\r\n  const nodeClass = registeredNode.klass;\r\n  if (serializedNode.type !== nodeClass.getType()) {\r\n    {\r\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\r\n    }\r\n  }\r\n  const node = nodeClass.importJSON(serializedNode);\r\n  const children = serializedNode.children;\r\n  if ($isElementNode(node) && Array.isArray(children)) {\r\n    for (let i = 0; i < children.length; i++) {\r\n      const serializedJSONChildNode = children[i];\r\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\r\n      node.append(childNode);\r\n    }\r\n  }\r\n  return node;\r\n}\r\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\r\n  const editorState = createEmptyEditorState();\r\n  const previousActiveEditorState = activeEditorState;\r\n  const previousReadOnlyMode = isReadOnlyMode;\r\n  const previousActiveEditor = activeEditor;\r\n  const previousDirtyElements = editor._dirtyElements;\r\n  const previousDirtyLeaves = editor._dirtyLeaves;\r\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\r\n  const previousDirtyType = editor._dirtyType;\r\n  editor._dirtyElements = new Map();\r\n  editor._dirtyLeaves = new Set();\r\n  editor._cloneNotNeeded = new Set();\r\n  editor._dirtyType = 0;\r\n  activeEditorState = editorState;\r\n  isReadOnlyMode = false;\r\n  activeEditor = editor;\r\n  try {\r\n    const registeredNodes = editor._nodes;\r\n    const serializedNode = serializedEditorState.root;\r\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\r\n    if (updateFn) {\r\n      updateFn();\r\n    }\r\n\r\n    // Make the editorState immutable\r\n    editorState._readOnly = true;\r\n    {\r\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\r\n    }\r\n  } catch (error) {\r\n    if (error instanceof Error) {\r\n      editor._onError(error);\r\n    }\r\n  } finally {\r\n    editor._dirtyElements = previousDirtyElements;\r\n    editor._dirtyLeaves = previousDirtyLeaves;\r\n    editor._cloneNotNeeded = previousCloneNotNeeded;\r\n    editor._dirtyType = previousDirtyType;\r\n    activeEditorState = previousActiveEditorState;\r\n    isReadOnlyMode = previousReadOnlyMode;\r\n    activeEditor = previousActiveEditor;\r\n  }\r\n  return editorState;\r\n}\r\n\r\n// This technically isn't an update but given we need\r\n// exposure to the module's active bindings, we have this\r\n// function here\r\n\r\nfunction readEditorState(editorState, callbackFn) {\r\n  const previousActiveEditorState = activeEditorState;\r\n  const previousReadOnlyMode = isReadOnlyMode;\r\n  const previousActiveEditor = activeEditor;\r\n  activeEditorState = editorState;\r\n  isReadOnlyMode = true;\r\n  activeEditor = null;\r\n  try {\r\n    return callbackFn();\r\n  } finally {\r\n    activeEditorState = previousActiveEditorState;\r\n    isReadOnlyMode = previousReadOnlyMode;\r\n    activeEditor = previousActiveEditor;\r\n  }\r\n}\r\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\r\n  // Given we can't Object.freeze the nodeMap as it's a Map,\r\n  // we instead replace its set, clear and delete methods.\r\n  const nodeMap = pendingEditorState._nodeMap;\r\n  nodeMap.set = () => {\r\n    throw new Error('Cannot call set() on a frozen Lexical node map');\r\n  };\r\n  nodeMap.clear = () => {\r\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\r\n  };\r\n  nodeMap.delete = () => {\r\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\r\n  };\r\n}\r\nfunction commitPendingUpdates(editor, recoveryEditorState) {\r\n  const pendingEditorState = editor._pendingEditorState;\r\n  const rootElement = editor._rootElement;\r\n  const shouldSkipDOM = editor._headless || rootElement === null;\r\n  if (pendingEditorState === null) {\r\n    return;\r\n  }\r\n\r\n  // ======\r\n  // Reconciliation has started.\r\n  // ======\r\n\r\n  const currentEditorState = editor._editorState;\r\n  const currentSelection = currentEditorState._selection;\r\n  const pendingSelection = pendingEditorState._selection;\r\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\r\n  const previousActiveEditorState = activeEditorState;\r\n  const previousReadOnlyMode = isReadOnlyMode;\r\n  const previousActiveEditor = activeEditor;\r\n  const previouslyUpdating = editor._updating;\r\n  const observer = editor._observer;\r\n  let mutatedNodes = null;\r\n  editor._pendingEditorState = null;\r\n  editor._editorState = pendingEditorState;\r\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\r\n    activeEditor = editor;\r\n    activeEditorState = pendingEditorState;\r\n    isReadOnlyMode = false;\r\n    // We don't want updates to sync block the reconciliation.\r\n    editor._updating = true;\r\n    try {\r\n      const dirtyType = editor._dirtyType;\r\n      const dirtyElements = editor._dirtyElements;\r\n      const dirtyLeaves = editor._dirtyLeaves;\r\n      observer.disconnect();\r\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\r\n    } catch (error) {\r\n      // Report errors\r\n      if (error instanceof Error) {\r\n        editor._onError(error);\r\n      }\r\n\r\n      // Reset editor and restore incoming editor state to the DOM\r\n      if (!isAttemptingToRecoverFromReconcilerError) {\r\n        resetEditor(editor, null, rootElement, pendingEditorState);\r\n        initMutationObserver(editor);\r\n        editor._dirtyType = FULL_RECONCILE;\r\n        isAttemptingToRecoverFromReconcilerError = true;\r\n        commitPendingUpdates(editor, currentEditorState);\r\n        isAttemptingToRecoverFromReconcilerError = false;\r\n      } else {\r\n        // To avoid a possible situation of infinite loops, lets throw\r\n        throw error;\r\n      }\r\n      return;\r\n    } finally {\r\n      observer.observe(rootElement, observerOptions);\r\n      editor._updating = previouslyUpdating;\r\n      activeEditorState = previousActiveEditorState;\r\n      isReadOnlyMode = previousReadOnlyMode;\r\n      activeEditor = previousActiveEditor;\r\n    }\r\n  }\r\n  if (!pendingEditorState._readOnly) {\r\n    pendingEditorState._readOnly = true;\r\n    {\r\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\r\n      if ($isRangeSelection(pendingSelection)) {\r\n        Object.freeze(pendingSelection.anchor);\r\n        Object.freeze(pendingSelection.focus);\r\n      }\r\n      Object.freeze(pendingSelection);\r\n    }\r\n  }\r\n  const dirtyLeaves = editor._dirtyLeaves;\r\n  const dirtyElements = editor._dirtyElements;\r\n  const normalizedNodes = editor._normalizedNodes;\r\n  const tags = editor._updateTags;\r\n  const deferred = editor._deferred;\r\n  if (needsUpdate) {\r\n    editor._dirtyType = NO_DIRTY_NODES;\r\n    editor._cloneNotNeeded.clear();\r\n    editor._dirtyLeaves = new Set();\r\n    editor._dirtyElements = new Map();\r\n    editor._normalizedNodes = new Set();\r\n    editor._updateTags = new Set();\r\n  }\r\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\r\n\r\n  // ======\r\n  // Reconciliation has finished. Now update selection and trigger listeners.\r\n  // ======\r\n\r\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\r\n\r\n  // Attempt to update the DOM selection, including focusing of the root element,\r\n  // and scroll into view if needed.\r\n  if (editor._editable &&\r\n  // domSelection will be null in headless\r\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\r\n    activeEditor = editor;\r\n    activeEditorState = pendingEditorState;\r\n    try {\r\n      if (observer !== null) {\r\n        observer.disconnect();\r\n      }\r\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\r\n        const blockCursorElement = editor._blockCursorElement;\r\n        if (blockCursorElement !== null) {\r\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\r\n        }\r\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\r\n      }\r\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\r\n      if (observer !== null) {\r\n        observer.observe(rootElement, observerOptions);\r\n      }\r\n    } finally {\r\n      activeEditor = previousActiveEditor;\r\n      activeEditorState = previousActiveEditorState;\r\n    }\r\n  }\r\n  if (mutatedNodes !== null) {\r\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\r\n  }\r\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\r\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\r\n  }\r\n  /**\r\n   * Capture pendingDecorators after garbage collecting detached decorators\r\n   */\r\n  const pendingDecorators = editor._pendingDecorators;\r\n  if (pendingDecorators !== null) {\r\n    editor._decorators = pendingDecorators;\r\n    editor._pendingDecorators = null;\r\n    triggerListeners('decorator', editor, true, pendingDecorators);\r\n  }\r\n\r\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\r\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\r\n  // listeners, but instead use recoverEditorState which is current editor state before reset\r\n  // This specifically important for collab that relies on prevEditorState from update\r\n  // listener to calculate delta of changed nodes/properties\r\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\r\n  triggerListeners('update', editor, true, {\r\n    dirtyElements,\r\n    dirtyLeaves,\r\n    editorState: pendingEditorState,\r\n    normalizedNodes,\r\n    prevEditorState: recoveryEditorState || currentEditorState,\r\n    tags\r\n  });\r\n  triggerDeferredUpdateCallbacks(editor, deferred);\r\n  triggerEnqueuedUpdates(editor);\r\n}\r\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\r\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\r\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\r\n  if (currentTextContent !== latestTextContent) {\r\n    triggerListeners('textcontent', editor, true, latestTextContent);\r\n  }\r\n}\r\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\r\n  const listeners = Array.from(editor._listeners.mutation);\r\n  const listenersLength = listeners.length;\r\n  for (let i = 0; i < listenersLength; i++) {\r\n    const [listener, klass] = listeners[i];\r\n    const mutatedNodesByType = mutatedNodes.get(klass);\r\n    if (mutatedNodesByType !== undefined) {\r\n      listener(mutatedNodesByType, {\r\n        dirtyLeaves,\r\n        prevEditorState,\r\n        updateTags\r\n      });\r\n    }\r\n  }\r\n}\r\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\r\n  const previouslyUpdating = editor._updating;\r\n  editor._updating = isCurrentlyEnqueuingUpdates;\r\n  try {\r\n    const listeners = Array.from(editor._listeners[type]);\r\n    for (let i = 0; i < listeners.length; i++) {\r\n      // @ts-ignore\r\n      listeners[i].apply(null, payload);\r\n    }\r\n  } finally {\r\n    editor._updating = previouslyUpdating;\r\n  }\r\n}\r\nfunction triggerCommandListeners(editor, type, payload) {\r\n  if (editor._updating === false || activeEditor !== editor) {\r\n    let returnVal = false;\r\n    editor.update(() => {\r\n      returnVal = triggerCommandListeners(editor, type, payload);\r\n    });\r\n    return returnVal;\r\n  }\r\n  const editors = getEditorsToPropagate(editor);\r\n  for (let i = 4; i >= 0; i--) {\r\n    for (let e = 0; e < editors.length; e++) {\r\n      const currentEditor = editors[e];\r\n      const commandListeners = currentEditor._commands;\r\n      const listenerInPriorityOrder = commandListeners.get(type);\r\n      if (listenerInPriorityOrder !== undefined) {\r\n        const listenersSet = listenerInPriorityOrder[i];\r\n        if (listenersSet !== undefined) {\r\n          const listeners = Array.from(listenersSet);\r\n          const listenersLength = listeners.length;\r\n          for (let j = 0; j < listenersLength; j++) {\r\n            if (listeners[j](payload, editor) === true) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\nfunction triggerEnqueuedUpdates(editor) {\r\n  const queuedUpdates = editor._updates;\r\n  if (queuedUpdates.length !== 0) {\r\n    const queuedUpdate = queuedUpdates.shift();\r\n    if (queuedUpdate) {\r\n      const [updateFn, options] = queuedUpdate;\r\n      beginUpdate(editor, updateFn, options);\r\n    }\r\n  }\r\n}\r\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\r\n  editor._deferred = [];\r\n  if (deferred.length !== 0) {\r\n    const previouslyUpdating = editor._updating;\r\n    editor._updating = true;\r\n    try {\r\n      for (let i = 0; i < deferred.length; i++) {\r\n        deferred[i]();\r\n      }\r\n    } finally {\r\n      editor._updating = previouslyUpdating;\r\n    }\r\n  }\r\n}\r\nfunction processNestedUpdates(editor, initialSkipTransforms) {\r\n  const queuedUpdates = editor._updates;\r\n  let skipTransforms = initialSkipTransforms || false;\r\n\r\n  // Updates might grow as we process them, we so we'll need\r\n  // to handle each update as we go until the updates array is\r\n  // empty.\r\n  while (queuedUpdates.length !== 0) {\r\n    const queuedUpdate = queuedUpdates.shift();\r\n    if (queuedUpdate) {\r\n      const [nextUpdateFn, options] = queuedUpdate;\r\n      let onUpdate;\r\n      let tag;\r\n      if (options !== undefined) {\r\n        onUpdate = options.onUpdate;\r\n        tag = options.tag;\r\n        if (options.skipTransforms) {\r\n          skipTransforms = true;\r\n        }\r\n        if (onUpdate) {\r\n          editor._deferred.push(onUpdate);\r\n        }\r\n        if (tag) {\r\n          editor._updateTags.add(tag);\r\n        }\r\n      }\r\n      nextUpdateFn();\r\n    }\r\n  }\r\n  return skipTransforms;\r\n}\r\nfunction beginUpdate(editor, updateFn, options) {\r\n  const updateTags = editor._updateTags;\r\n  let onUpdate;\r\n  let tag;\r\n  let skipTransforms = false;\r\n  let discrete = false;\r\n  if (options !== undefined) {\r\n    onUpdate = options.onUpdate;\r\n    tag = options.tag;\r\n    if (tag != null) {\r\n      updateTags.add(tag);\r\n    }\r\n    skipTransforms = options.skipTransforms || false;\r\n    discrete = options.discrete || false;\r\n  }\r\n  if (onUpdate) {\r\n    editor._deferred.push(onUpdate);\r\n  }\r\n  const currentEditorState = editor._editorState;\r\n  let pendingEditorState = editor._pendingEditorState;\r\n  let editorStateWasCloned = false;\r\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\r\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\r\n    editorStateWasCloned = true;\r\n  }\r\n  pendingEditorState._flushSync = discrete;\r\n  const previousActiveEditorState = activeEditorState;\r\n  const previousReadOnlyMode = isReadOnlyMode;\r\n  const previousActiveEditor = activeEditor;\r\n  const previouslyUpdating = editor._updating;\r\n  activeEditorState = pendingEditorState;\r\n  isReadOnlyMode = false;\r\n  editor._updating = true;\r\n  activeEditor = editor;\r\n  try {\r\n    if (editorStateWasCloned) {\r\n      if (editor._headless) {\r\n        if (currentEditorState._selection !== null) {\r\n          pendingEditorState._selection = currentEditorState._selection.clone();\r\n        }\r\n      } else {\r\n        pendingEditorState._selection = internalCreateSelection(editor);\r\n      }\r\n    }\r\n    const startingCompositionKey = editor._compositionKey;\r\n    updateFn();\r\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\r\n    applySelectionTransforms(pendingEditorState, editor);\r\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\r\n      if (skipTransforms) {\r\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\r\n      } else {\r\n        $applyAllTransforms(pendingEditorState, editor);\r\n      }\r\n      processNestedUpdates(editor);\r\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\r\n    }\r\n    const endingCompositionKey = editor._compositionKey;\r\n    if (startingCompositionKey !== endingCompositionKey) {\r\n      pendingEditorState._flushSync = true;\r\n    }\r\n    const pendingSelection = pendingEditorState._selection;\r\n    if ($isRangeSelection(pendingSelection)) {\r\n      const pendingNodeMap = pendingEditorState._nodeMap;\r\n      const anchorKey = pendingSelection.anchor.key;\r\n      const focusKey = pendingSelection.focus.key;\r\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\r\n        {\r\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\r\n        }\r\n      }\r\n    } else if ($isNodeSelection(pendingSelection)) {\r\n      // TODO: we should also validate node selection?\r\n      if (pendingSelection._nodes.size === 0) {\r\n        pendingEditorState._selection = null;\r\n      }\r\n    }\r\n  } catch (error) {\r\n    // Report errors\r\n    if (error instanceof Error) {\r\n      editor._onError(error);\r\n    }\r\n\r\n    // Restore existing editor state to the DOM\r\n    editor._pendingEditorState = currentEditorState;\r\n    editor._dirtyType = FULL_RECONCILE;\r\n    editor._cloneNotNeeded.clear();\r\n    editor._dirtyLeaves = new Set();\r\n    editor._dirtyElements.clear();\r\n    commitPendingUpdates(editor);\r\n    return;\r\n  } finally {\r\n    activeEditorState = previousActiveEditorState;\r\n    isReadOnlyMode = previousReadOnlyMode;\r\n    activeEditor = previousActiveEditor;\r\n    editor._updating = previouslyUpdating;\r\n    infiniteTransformCount = 0;\r\n  }\r\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\r\n  if (shouldUpdate) {\r\n    if (pendingEditorState._flushSync) {\r\n      pendingEditorState._flushSync = false;\r\n      commitPendingUpdates(editor);\r\n    } else if (editorStateWasCloned) {\r\n      scheduleMicroTask(() => {\r\n        commitPendingUpdates(editor);\r\n      });\r\n    }\r\n  } else {\r\n    pendingEditorState._flushSync = false;\r\n    if (editorStateWasCloned) {\r\n      updateTags.clear();\r\n      editor._deferred = [];\r\n      editor._pendingEditorState = null;\r\n    }\r\n  }\r\n}\r\nfunction updateEditor(editor, updateFn, options) {\r\n  if (editor._updating) {\r\n    editor._updates.push([updateFn, options]);\r\n  } else {\r\n    beginUpdate(editor, updateFn, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n/** @noInheritDoc */\r\nclass DecoratorNode extends LexicalNode {\r\n  constructor(key) {\r\n    super(key);\r\n  }\r\n\r\n  /**\r\n   * The returned value is added to the LexicalEditor._decorators\r\n   */\r\n  decorate(editor, config) {\r\n    {\r\n      throw Error(`decorate: base method not extended`);\r\n    }\r\n  }\r\n  isIsolated() {\r\n    return false;\r\n  }\r\n  isInline() {\r\n    return true;\r\n  }\r\n  isKeyboardSelectable() {\r\n    return true;\r\n  }\r\n}\r\nfunction $isDecoratorNode(node) {\r\n  return node instanceof DecoratorNode;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass ElementNode extends LexicalNode {\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  constructor(key) {\r\n    super(key);\r\n    this.__first = null;\r\n    this.__last = null;\r\n    this.__size = 0;\r\n    this.__format = 0;\r\n    this.__indent = 0;\r\n    this.__dir = null;\r\n  }\r\n  getFormat() {\r\n    const self = this.getLatest();\r\n    return self.__format;\r\n  }\r\n  getFormatType() {\r\n    const format = this.getFormat();\r\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\r\n  }\r\n  getIndent() {\r\n    const self = this.getLatest();\r\n    return self.__indent;\r\n  }\r\n  getChildren() {\r\n    const children = [];\r\n    let child = this.getFirstChild();\r\n    while (child !== null) {\r\n      children.push(child);\r\n      child = child.getNextSibling();\r\n    }\r\n    return children;\r\n  }\r\n  getChildrenKeys() {\r\n    const children = [];\r\n    let child = this.getFirstChild();\r\n    while (child !== null) {\r\n      children.push(child.__key);\r\n      child = child.getNextSibling();\r\n    }\r\n    return children;\r\n  }\r\n  getChildrenSize() {\r\n    const self = this.getLatest();\r\n    return self.__size;\r\n  }\r\n  isEmpty() {\r\n    return this.getChildrenSize() === 0;\r\n  }\r\n  isDirty() {\r\n    const editor = getActiveEditor();\r\n    const dirtyElements = editor._dirtyElements;\r\n    return dirtyElements !== null && dirtyElements.has(this.__key);\r\n  }\r\n  isLastChild() {\r\n    const self = this.getLatest();\r\n    const parentLastChild = this.getParentOrThrow().getLastChild();\r\n    return parentLastChild !== null && parentLastChild.is(self);\r\n  }\r\n  getAllTextNodes() {\r\n    const textNodes = [];\r\n    let child = this.getFirstChild();\r\n    while (child !== null) {\r\n      if ($isTextNode(child)) {\r\n        textNodes.push(child);\r\n      }\r\n      if ($isElementNode(child)) {\r\n        const subChildrenNodes = child.getAllTextNodes();\r\n        textNodes.push(...subChildrenNodes);\r\n      }\r\n      child = child.getNextSibling();\r\n    }\r\n    return textNodes;\r\n  }\r\n  getFirstDescendant() {\r\n    let node = this.getFirstChild();\r\n    while (node !== null) {\r\n      if ($isElementNode(node)) {\r\n        const child = node.getFirstChild();\r\n        if (child !== null) {\r\n          node = child;\r\n          continue;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    return node;\r\n  }\r\n  getLastDescendant() {\r\n    let node = this.getLastChild();\r\n    while (node !== null) {\r\n      if ($isElementNode(node)) {\r\n        const child = node.getLastChild();\r\n        if (child !== null) {\r\n          node = child;\r\n          continue;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    return node;\r\n  }\r\n  getDescendantByIndex(index) {\r\n    const children = this.getChildren();\r\n    const childrenLength = children.length;\r\n    // For non-empty element nodes, we resolve its descendant\r\n    // (either a leaf node or the bottom-most element)\r\n    if (index >= childrenLength) {\r\n      const resolvedNode = children[childrenLength - 1];\r\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\r\n    }\r\n    const resolvedNode = children[index];\r\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\r\n  }\r\n  getFirstChild() {\r\n    const self = this.getLatest();\r\n    const firstKey = self.__first;\r\n    return firstKey === null ? null : $getNodeByKey(firstKey);\r\n  }\r\n  getFirstChildOrThrow() {\r\n    const firstChild = this.getFirstChild();\r\n    if (firstChild === null) {\r\n      {\r\n        throw Error(`Expected node ${this.__key} to have a first child.`);\r\n      }\r\n    }\r\n    return firstChild;\r\n  }\r\n  getLastChild() {\r\n    const self = this.getLatest();\r\n    const lastKey = self.__last;\r\n    return lastKey === null ? null : $getNodeByKey(lastKey);\r\n  }\r\n  getLastChildOrThrow() {\r\n    const lastChild = this.getLastChild();\r\n    if (lastChild === null) {\r\n      {\r\n        throw Error(`Expected node ${this.__key} to have a last child.`);\r\n      }\r\n    }\r\n    return lastChild;\r\n  }\r\n  getChildAtIndex(index) {\r\n    const size = this.getChildrenSize();\r\n    let node;\r\n    let i;\r\n    if (index < size / 2) {\r\n      node = this.getFirstChild();\r\n      i = 0;\r\n      while (node !== null && i <= index) {\r\n        if (i === index) {\r\n          return node;\r\n        }\r\n        node = node.getNextSibling();\r\n        i++;\r\n      }\r\n      return null;\r\n    }\r\n    node = this.getLastChild();\r\n    i = size - 1;\r\n    while (node !== null && i >= index) {\r\n      if (i === index) {\r\n        return node;\r\n      }\r\n      node = node.getPreviousSibling();\r\n      i--;\r\n    }\r\n    return null;\r\n  }\r\n  getTextContent() {\r\n    let textContent = '';\r\n    const children = this.getChildren();\r\n    const childrenLength = children.length;\r\n    for (let i = 0; i < childrenLength; i++) {\r\n      const child = children[i];\r\n      textContent += child.getTextContent();\r\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\r\n        textContent += DOUBLE_LINE_BREAK;\r\n      }\r\n    }\r\n    return textContent;\r\n  }\r\n  getTextContentSize() {\r\n    let textContentSize = 0;\r\n    const children = this.getChildren();\r\n    const childrenLength = children.length;\r\n    for (let i = 0; i < childrenLength; i++) {\r\n      const child = children[i];\r\n      textContentSize += child.getTextContentSize();\r\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\r\n        textContentSize += DOUBLE_LINE_BREAK.length;\r\n      }\r\n    }\r\n    return textContentSize;\r\n  }\r\n  getDirection() {\r\n    const self = this.getLatest();\r\n    return self.__dir;\r\n  }\r\n  hasFormat(type) {\r\n    if (type !== '') {\r\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\r\n      return (this.getFormat() & formatFlag) !== 0;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Mutators\r\n\r\n  select(_anchorOffset, _focusOffset) {\r\n    errorOnReadOnly();\r\n    const selection = $getSelection();\r\n    let anchorOffset = _anchorOffset;\r\n    let focusOffset = _focusOffset;\r\n    const childrenCount = this.getChildrenSize();\r\n    if (!this.canBeEmpty()) {\r\n      if (_anchorOffset === 0 && _focusOffset === 0) {\r\n        const firstChild = this.getFirstChild();\r\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\r\n          return firstChild.select(0, 0);\r\n        }\r\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\r\n        const lastChild = this.getLastChild();\r\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\r\n          return lastChild.select();\r\n        }\r\n      }\r\n    }\r\n    if (anchorOffset === undefined) {\r\n      anchorOffset = childrenCount;\r\n    }\r\n    if (focusOffset === undefined) {\r\n      focusOffset = childrenCount;\r\n    }\r\n    const key = this.__key;\r\n    if (!$isRangeSelection(selection)) {\r\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\r\n    } else {\r\n      selection.anchor.set(key, anchorOffset, 'element');\r\n      selection.focus.set(key, focusOffset, 'element');\r\n      selection.dirty = true;\r\n    }\r\n    return selection;\r\n  }\r\n  selectStart() {\r\n    const firstNode = this.getFirstDescendant();\r\n    return firstNode ? firstNode.selectStart() : this.select();\r\n  }\r\n  selectEnd() {\r\n    const lastNode = this.getLastDescendant();\r\n    return lastNode ? lastNode.selectEnd() : this.select();\r\n  }\r\n  clear() {\r\n    const writableSelf = this.getWritable();\r\n    const children = this.getChildren();\r\n    children.forEach(child => child.remove());\r\n    return writableSelf;\r\n  }\r\n  append(...nodesToAppend) {\r\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\r\n  }\r\n  setDirection(direction) {\r\n    const self = this.getWritable();\r\n    self.__dir = direction;\r\n    return self;\r\n  }\r\n  setFormat(type) {\r\n    const self = this.getWritable();\r\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\r\n    return this;\r\n  }\r\n  setIndent(indentLevel) {\r\n    const self = this.getWritable();\r\n    self.__indent = indentLevel;\r\n    return this;\r\n  }\r\n  splice(start, deleteCount, nodesToInsert) {\r\n    const nodesToInsertLength = nodesToInsert.length;\r\n    const oldSize = this.getChildrenSize();\r\n    const writableSelf = this.getWritable();\r\n    const writableSelfKey = writableSelf.__key;\r\n    const nodesToInsertKeys = [];\r\n    const nodesToRemoveKeys = [];\r\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\r\n    let nodeBeforeRange = null;\r\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\r\n    if (start !== 0) {\r\n      if (start === oldSize) {\r\n        nodeBeforeRange = this.getLastChild();\r\n      } else {\r\n        const node = this.getChildAtIndex(start);\r\n        if (node !== null) {\r\n          nodeBeforeRange = node.getPreviousSibling();\r\n        }\r\n      }\r\n    }\r\n    if (deleteCount > 0) {\r\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\r\n      for (let i = 0; i < deleteCount; i++) {\r\n        if (nodeToDelete === null) {\r\n          {\r\n            throw Error(`splice: sibling not found`);\r\n          }\r\n        }\r\n        const nextSibling = nodeToDelete.getNextSibling();\r\n        const nodeKeyToDelete = nodeToDelete.__key;\r\n        const writableNodeToDelete = nodeToDelete.getWritable();\r\n        removeFromParent(writableNodeToDelete);\r\n        nodesToRemoveKeys.push(nodeKeyToDelete);\r\n        nodeToDelete = nextSibling;\r\n      }\r\n    }\r\n    let prevNode = nodeBeforeRange;\r\n    for (let i = 0; i < nodesToInsertLength; i++) {\r\n      const nodeToInsert = nodesToInsert[i];\r\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\r\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\r\n      }\r\n      const writableNodeToInsert = nodeToInsert.getWritable();\r\n      if (writableNodeToInsert.__parent === writableSelfKey) {\r\n        newSize--;\r\n      }\r\n      removeFromParent(writableNodeToInsert);\r\n      const nodeKeyToInsert = nodeToInsert.__key;\r\n      if (prevNode === null) {\r\n        writableSelf.__first = nodeKeyToInsert;\r\n        writableNodeToInsert.__prev = null;\r\n      } else {\r\n        const writablePrevNode = prevNode.getWritable();\r\n        writablePrevNode.__next = nodeKeyToInsert;\r\n        writableNodeToInsert.__prev = writablePrevNode.__key;\r\n      }\r\n      if (nodeToInsert.__key === writableSelfKey) {\r\n        {\r\n          throw Error(`append: attempting to append self`);\r\n        }\r\n      }\r\n      // Set child parent to self\r\n      writableNodeToInsert.__parent = writableSelfKey;\r\n      nodesToInsertKeys.push(nodeKeyToInsert);\r\n      prevNode = nodeToInsert;\r\n    }\r\n    if (start + deleteCount === oldSize) {\r\n      if (prevNode !== null) {\r\n        const writablePrevNode = prevNode.getWritable();\r\n        writablePrevNode.__next = null;\r\n        writableSelf.__last = prevNode.__key;\r\n      }\r\n    } else if (nodeAfterRange !== null) {\r\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\r\n      if (prevNode !== null) {\r\n        const writablePrevNode = prevNode.getWritable();\r\n        writableNodeAfterRange.__prev = prevNode.__key;\r\n        writablePrevNode.__next = nodeAfterRange.__key;\r\n      } else {\r\n        writableNodeAfterRange.__prev = null;\r\n      }\r\n    }\r\n    writableSelf.__size = newSize;\r\n\r\n    // In case of deletion we need to adjust selection, unlink removed nodes\r\n    // and clean up node itself if it becomes empty. None of these needed\r\n    // for insertion-only cases\r\n    if (nodesToRemoveKeys.length) {\r\n      // Adjusting selection, in case node that was anchor/focus will be deleted\r\n      const selection = $getSelection();\r\n      if ($isRangeSelection(selection)) {\r\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\r\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\r\n        const {\r\n          anchor,\r\n          focus\r\n        } = selection;\r\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\r\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\r\n        }\r\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\r\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\r\n        }\r\n        // Cleanup if node can't be empty\r\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\r\n          this.remove();\r\n        }\r\n      }\r\n    }\r\n    return writableSelf;\r\n  }\r\n  // JSON serialization\r\n  exportJSON() {\r\n    return {\r\n      children: [],\r\n      direction: this.getDirection(),\r\n      format: this.getFormatType(),\r\n      indent: this.getIndent(),\r\n      type: 'element',\r\n      version: 1\r\n    };\r\n  }\r\n  // These are intended to be extends for specific element heuristics.\r\n  insertNewAfter(selection, restoreSelection) {\r\n    return null;\r\n  }\r\n  canIndent() {\r\n    return true;\r\n  }\r\n  /*\r\n   * This method controls the behavior of a the node during backwards\r\n   * deletion (i.e., backspace) when selection is at the beginning of\r\n   * the node (offset 0)\r\n   */\r\n  collapseAtStart(selection) {\r\n    return false;\r\n  }\r\n  excludeFromCopy(destination) {\r\n    return false;\r\n  }\r\n  // TODO 0.10 deprecate\r\n  canExtractContents() {\r\n    return true;\r\n  }\r\n  canReplaceWith(replacement) {\r\n    return true;\r\n  }\r\n  canInsertAfter(node) {\r\n    return true;\r\n  }\r\n  canBeEmpty() {\r\n    return true;\r\n  }\r\n  canInsertTextBefore() {\r\n    return true;\r\n  }\r\n  canInsertTextAfter() {\r\n    return true;\r\n  }\r\n  isInline() {\r\n    return false;\r\n  }\r\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\r\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\r\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\r\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\r\n  isShadowRoot() {\r\n    return false;\r\n  }\r\n  canMergeWith(node) {\r\n    return false;\r\n  }\r\n  extractWithChild(child, selection, destination) {\r\n    return false;\r\n  }\r\n}\r\nfunction $isElementNode(node) {\r\n  return node instanceof ElementNode;\r\n}\r\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\r\n  let node = point.getNode();\r\n  while (node) {\r\n    const nodeKey = node.__key;\r\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\r\n      return true;\r\n    }\r\n    node = node.getParent();\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass RootNode extends ElementNode {\r\n  /** @internal */\r\n\r\n  static getType() {\r\n    return 'root';\r\n  }\r\n  static clone() {\r\n    return new RootNode();\r\n  }\r\n  constructor() {\r\n    super('root');\r\n    this.__cachedText = null;\r\n  }\r\n  getTopLevelElementOrThrow() {\r\n    {\r\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\r\n    }\r\n  }\r\n  getTextContent() {\r\n    const cachedText = this.__cachedText;\r\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\r\n      if (cachedText !== null) {\r\n        return cachedText;\r\n      }\r\n    }\r\n    return super.getTextContent();\r\n  }\r\n  remove() {\r\n    {\r\n      throw Error(`remove: cannot be called on root nodes`);\r\n    }\r\n  }\r\n  replace(node) {\r\n    {\r\n      throw Error(`replace: cannot be called on root nodes`);\r\n    }\r\n  }\r\n  insertBefore(nodeToInsert) {\r\n    {\r\n      throw Error(`insertBefore: cannot be called on root nodes`);\r\n    }\r\n  }\r\n  insertAfter(nodeToInsert) {\r\n    {\r\n      throw Error(`insertAfter: cannot be called on root nodes`);\r\n    }\r\n  }\r\n\r\n  // View\r\n\r\n  updateDOM(prevNode, dom) {\r\n    return false;\r\n  }\r\n\r\n  // Mutate\r\n\r\n  append(...nodesToAppend) {\r\n    for (let i = 0; i < nodesToAppend.length; i++) {\r\n      const node = nodesToAppend[i];\r\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\r\n        {\r\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\r\n        }\r\n      }\r\n    }\r\n    return super.append(...nodesToAppend);\r\n  }\r\n  static importJSON(serializedNode) {\r\n    // We don't create a root, and instead use the existing root.\r\n    const node = $getRoot();\r\n    node.setFormat(serializedNode.format);\r\n    node.setIndent(serializedNode.indent);\r\n    node.setDirection(serializedNode.direction);\r\n    return node;\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      children: [],\r\n      direction: this.getDirection(),\r\n      format: this.getFormatType(),\r\n      indent: this.getIndent(),\r\n      type: 'root',\r\n      version: 1\r\n    };\r\n  }\r\n  collapseAtStart() {\r\n    return true;\r\n  }\r\n}\r\nfunction $createRootNode() {\r\n  return new RootNode();\r\n}\r\nfunction $isRootNode(node) {\r\n  return node instanceof RootNode;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nfunction editorStateHasDirtySelection(editorState, editor) {\r\n  const currentSelection = editor.getEditorState()._selection;\r\n  const pendingSelection = editorState._selection;\r\n\r\n  // Check if we need to update because of changes in selection\r\n  if (pendingSelection !== null) {\r\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\r\n      return true;\r\n    }\r\n  } else if (currentSelection !== null) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nfunction cloneEditorState(current) {\r\n  return new EditorState(new Map(current._nodeMap));\r\n}\r\nfunction createEmptyEditorState() {\r\n  return new EditorState(new Map([['root', $createRootNode()]]));\r\n}\r\nfunction exportNodeToJSON(node) {\r\n  const serializedNode = node.exportJSON();\r\n  const nodeClass = node.constructor;\r\n  if (serializedNode.type !== nodeClass.getType()) {\r\n    {\r\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\r\n    }\r\n  }\r\n  if ($isElementNode(node)) {\r\n    const serializedChildren = serializedNode.children;\r\n    if (!Array.isArray(serializedChildren)) {\r\n      {\r\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\r\n      }\r\n    }\r\n    const children = node.getChildren();\r\n    for (let i = 0; i < children.length; i++) {\r\n      const child = children[i];\r\n      const serializedChildNode = exportNodeToJSON(child);\r\n      serializedChildren.push(serializedChildNode);\r\n    }\r\n  }\r\n\r\n  // @ts-expect-error\r\n  return serializedNode;\r\n}\r\nclass EditorState {\r\n  constructor(nodeMap, selection) {\r\n    this._nodeMap = nodeMap;\r\n    this._selection = selection || null;\r\n    this._flushSync = false;\r\n    this._readOnly = false;\r\n  }\r\n  isEmpty() {\r\n    return this._nodeMap.size === 1 && this._selection === null;\r\n  }\r\n  read(callbackFn) {\r\n    return readEditorState(this, callbackFn);\r\n  }\r\n  clone(selection) {\r\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\r\n    editorState._readOnly = true;\r\n    return editorState;\r\n  }\r\n  toJSON() {\r\n    return readEditorState(this, () => ({\r\n      root: exportNodeToJSON($getRoot())\r\n    }));\r\n  }\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n/** @noInheritDoc */\r\nclass ParagraphNode extends ElementNode {\r\n  static getType() {\r\n    return 'paragraph';\r\n  }\r\n  static clone(node) {\r\n    return new ParagraphNode(node.__key);\r\n  }\r\n\r\n  // View\r\n\r\n  createDOM(config) {\r\n    const dom = document.createElement('p');\r\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\r\n    if (classNames !== undefined) {\r\n      const domClassList = dom.classList;\r\n      domClassList.add(...classNames);\r\n    }\r\n    return dom;\r\n  }\r\n  updateDOM(prevNode, dom, config) {\r\n    return false;\r\n  }\r\n  static importDOM() {\r\n    return {\r\n      p: node => ({\r\n        conversion: convertParagraphElement,\r\n        priority: 0\r\n      })\r\n    };\r\n  }\r\n  exportDOM(editor) {\r\n    const {\r\n      element\r\n    } = super.exportDOM(editor);\r\n    if (element && isHTMLElement(element)) {\r\n      if (this.isEmpty()) element.append(document.createElement('br'));\r\n      const formatType = this.getFormatType();\r\n      element.style.textAlign = formatType;\r\n      const direction = this.getDirection();\r\n      if (direction) {\r\n        element.dir = direction;\r\n      }\r\n      const indent = this.getIndent();\r\n      if (indent > 0) {\r\n        // padding-inline-start is not widely supported in email HTML, but\r\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\r\n        element.style.textIndent = `${indent * 20}px`;\r\n      }\r\n    }\r\n    return {\r\n      element\r\n    };\r\n  }\r\n  static importJSON(serializedNode) {\r\n    const node = $createParagraphNode();\r\n    node.setFormat(serializedNode.format);\r\n    node.setIndent(serializedNode.indent);\r\n    node.setDirection(serializedNode.direction);\r\n    return node;\r\n  }\r\n  exportJSON() {\r\n    return {\r\n      ...super.exportJSON(),\r\n      type: 'paragraph',\r\n      version: 1\r\n    };\r\n  }\r\n\r\n  // Mutation\r\n\r\n  insertNewAfter(_, restoreSelection) {\r\n    const newElement = $createParagraphNode();\r\n    const direction = this.getDirection();\r\n    newElement.setDirection(direction);\r\n    this.insertAfter(newElement, restoreSelection);\r\n    return newElement;\r\n  }\r\n  collapseAtStart() {\r\n    const children = this.getChildren();\r\n    // If we have an empty (trimmed) first paragraph and try and remove it,\r\n    // delete the paragraph as long as we have another sibling to go to\r\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\r\n      const nextSibling = this.getNextSibling();\r\n      if (nextSibling !== null) {\r\n        this.selectNext();\r\n        this.remove();\r\n        return true;\r\n      }\r\n      const prevSibling = this.getPreviousSibling();\r\n      if (prevSibling !== null) {\r\n        this.selectPrevious();\r\n        this.remove();\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\nfunction convertParagraphElement(element) {\r\n  const node = $createParagraphNode();\r\n  if (element.style) {\r\n    node.setFormat(element.style.textAlign);\r\n    const indent = parseInt(element.style.textIndent, 10) / 20;\r\n    if (indent > 0) {\r\n      node.setIndent(indent);\r\n    }\r\n  }\r\n  return {\r\n    node\r\n  };\r\n}\r\nfunction $createParagraphNode() {\r\n  return $applyNodeReplacement(new ParagraphNode());\r\n}\r\nfunction $isParagraphNode(node) {\r\n  return node instanceof ParagraphNode;\r\n}\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n// https://github.com/microsoft/TypeScript/issues/3841\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst COMMAND_PRIORITY_EDITOR = 0;\r\nconst COMMAND_PRIORITY_LOW = 1;\r\nconst COMMAND_PRIORITY_NORMAL = 2;\r\nconst COMMAND_PRIORITY_HIGH = 3;\r\nconst COMMAND_PRIORITY_CRITICAL = 4;\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n\r\n/**\r\n * Type helper for extracting the payload type from a command.\r\n *\r\n * @example\r\n * ```ts\r\n * const MY_COMMAND = createCommand<SomeType>();\r\n *\r\n * // ...\r\n *\r\n * editor.registerCommand(MY_COMMAND, payload => {\r\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\r\n *   handleMyCommand(editor, payload);\r\n *   return true;\r\n * });\r\n *\r\n * function handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\r\n *   // `payload` is of type `SomeType`, extracted from the command.\r\n * }\r\n * ```\r\n */\r\n\r\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\r\n  const keyNodeMap = editor._keyToDOMMap;\r\n  keyNodeMap.clear();\r\n  editor._editorState = createEmptyEditorState();\r\n  editor._pendingEditorState = pendingEditorState;\r\n  editor._compositionKey = null;\r\n  editor._dirtyType = NO_DIRTY_NODES;\r\n  editor._cloneNotNeeded.clear();\r\n  editor._dirtyLeaves = new Set();\r\n  editor._dirtyElements.clear();\r\n  editor._normalizedNodes = new Set();\r\n  editor._updateTags = new Set();\r\n  editor._updates = [];\r\n  editor._blockCursorElement = null;\r\n  const observer = editor._observer;\r\n  if (observer !== null) {\r\n    observer.disconnect();\r\n    editor._observer = null;\r\n  }\r\n\r\n  // Remove all the DOM nodes from the root element\r\n  if (prevRootElement !== null) {\r\n    prevRootElement.textContent = '';\r\n  }\r\n  if (nextRootElement !== null) {\r\n    nextRootElement.textContent = '';\r\n    keyNodeMap.set('root', nextRootElement);\r\n  }\r\n}\r\nfunction initializeConversionCache(nodes, additionalConversions) {\r\n  const conversionCache = new Map();\r\n  const handledConversions = new Set();\r\n  const addConversionsToCache = map => {\r\n    Object.keys(map).forEach(key => {\r\n      let currentCache = conversionCache.get(key);\r\n      if (currentCache === undefined) {\r\n        currentCache = [];\r\n        conversionCache.set(key, currentCache);\r\n      }\r\n      currentCache.push(map[key]);\r\n    });\r\n  };\r\n  nodes.forEach(node => {\r\n    const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;\r\n    if (importDOM == null || handledConversions.has(importDOM)) {\r\n      return;\r\n    }\r\n    handledConversions.add(importDOM);\r\n    const map = importDOM();\r\n    if (map !== null) {\r\n      addConversionsToCache(map);\r\n    }\r\n  });\r\n  if (additionalConversions) {\r\n    addConversionsToCache(additionalConversions);\r\n  }\r\n  return conversionCache;\r\n}\r\n\r\n/**\r\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\r\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\r\n * consider using the appropriate abstractions, such as LexicalComposer\r\n * @param editorConfig - the editor configuration.\r\n * @returns a LexicalEditor instance\r\n */\r\nfunction createEditor(editorConfig) {\r\n  const config = editorConfig || {};\r\n  const activeEditor = internalGetActiveEditor();\r\n  const theme = config.theme || {};\r\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\r\n  const disableEvents = config.disableEvents || false;\r\n  const editorState = createEmptyEditorState();\r\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\r\n  const initialEditorState = config.editorState;\r\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ...(config.nodes || [])];\r\n  const {\r\n    onError,\r\n    html\r\n  } = config;\r\n  const isEditable = config.editable !== undefined ? config.editable : true;\r\n  let registeredNodes;\r\n  if (editorConfig === undefined && activeEditor !== null) {\r\n    registeredNodes = activeEditor._nodes;\r\n  } else {\r\n    registeredNodes = new Map();\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      let klass = nodes[i];\r\n      let replace = null;\r\n      let replaceWithKlass = null;\r\n      if (typeof klass !== 'function') {\r\n        const options = klass;\r\n        klass = options.replace;\r\n        replace = options.with;\r\n        replaceWithKlass = options.withKlass || null;\r\n      }\r\n      // Ensure custom nodes implement required methods.\r\n      {\r\n        const name = klass.name;\r\n        if (name !== 'RootNode') {\r\n          const proto = klass.prototype;\r\n          ['getType', 'clone'].forEach(method => {\r\n            // eslint-disable-next-line no-prototype-builtins\r\n            if (!klass.hasOwnProperty(method)) {\r\n              console.warn(`${name} must implement static \"${method}\" method`);\r\n            }\r\n          });\r\n          if (\r\n          // eslint-disable-next-line no-prototype-builtins\r\n          !klass.hasOwnProperty('importDOM') &&\r\n          // eslint-disable-next-line no-prototype-builtins\r\n          klass.hasOwnProperty('exportDOM')) {\r\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\r\n          }\r\n          if (proto instanceof DecoratorNode) {\r\n            // eslint-disable-next-line no-prototype-builtins\r\n            if (!proto.hasOwnProperty('decorate')) {\r\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\r\n            }\r\n          }\r\n          if (\r\n          // eslint-disable-next-line no-prototype-builtins\r\n          !klass.hasOwnProperty('importJSON')) {\r\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\r\n          }\r\n          if (\r\n          // eslint-disable-next-line no-prototype-builtins\r\n          !proto.hasOwnProperty('exportJSON')) {\r\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\r\n          }\r\n        }\r\n      }\r\n      const type = klass.getType();\r\n      const transform = klass.transform();\r\n      const transforms = new Set();\r\n      if (transform !== null) {\r\n        transforms.add(transform);\r\n      }\r\n      registeredNodes.set(type, {\r\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\r\n        klass,\r\n        replace,\r\n        replaceWithKlass,\r\n        transforms\r\n      });\r\n    }\r\n  }\r\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\r\n    disableEvents,\r\n    namespace,\r\n    theme\r\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable);\r\n  if (initialEditorState !== undefined) {\r\n    editor._pendingEditorState = initialEditorState;\r\n    editor._dirtyType = FULL_RECONCILE;\r\n  }\r\n  return editor;\r\n}\r\nclass LexicalEditor {\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n\r\n  /** @internal */\r\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\r\n    this._parentEditor = parentEditor;\r\n    // The root element associated with this editor\r\n    this._rootElement = null;\r\n    // The current editor state\r\n    this._editorState = editorState;\r\n    // Handling of drafts and updates\r\n    this._pendingEditorState = null;\r\n    // Used to help co-ordinate selection and events\r\n    this._compositionKey = null;\r\n    this._deferred = [];\r\n    // Used during reconciliation\r\n    this._keyToDOMMap = new Map();\r\n    this._updates = [];\r\n    this._updating = false;\r\n    // Listeners\r\n    this._listeners = {\r\n      decorator: new Set(),\r\n      editable: new Set(),\r\n      mutation: new Map(),\r\n      root: new Set(),\r\n      textcontent: new Set(),\r\n      update: new Set()\r\n    };\r\n    // Commands\r\n    this._commands = new Map();\r\n    // Editor configuration for theme/context.\r\n    this._config = config;\r\n    // Mapping of types to their nodes\r\n    this._nodes = nodes;\r\n    // React node decorators for portals\r\n    this._decorators = {};\r\n    this._pendingDecorators = null;\r\n    // Used to optimize reconciliation\r\n    this._dirtyType = NO_DIRTY_NODES;\r\n    this._cloneNotNeeded = new Set();\r\n    this._dirtyLeaves = new Set();\r\n    this._dirtyElements = new Map();\r\n    this._normalizedNodes = new Set();\r\n    this._updateTags = new Set();\r\n    // Handling of DOM mutations\r\n    this._observer = null;\r\n    // Used for identifying owning editors\r\n    this._key = createUID();\r\n    this._onError = onError;\r\n    this._htmlConversions = htmlConversions;\r\n    this._editable = editable;\r\n    this._headless = parentEditor !== null && parentEditor._headless;\r\n    this._window = null;\r\n    this._blockCursorElement = null;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\r\n   * through an IME, or 3P extension, for example. Returns false otherwise.\r\n   */\r\n  isComposing() {\r\n    return this._compositionKey != null;\r\n  }\r\n  /**\r\n   * Registers a listener for Editor update event. Will trigger the provided callback\r\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\r\n   * teardown function is called.\r\n   *\r\n   * @returns a teardown function that can be used to cleanup the listener.\r\n   */\r\n  registerUpdateListener(listener) {\r\n    const listenerSetOrMap = this._listeners.update;\r\n    listenerSetOrMap.add(listener);\r\n    return () => {\r\n      listenerSetOrMap.delete(listener);\r\n    };\r\n  }\r\n  /**\r\n   * Registers a listener for for when the editor changes between editable and non-editable states.\r\n   * Will trigger the provided callback each time the editor transitions between these states until the\r\n   * teardown function is called.\r\n   *\r\n   * @returns a teardown function that can be used to cleanup the listener.\r\n   */\r\n  registerEditableListener(listener) {\r\n    const listenerSetOrMap = this._listeners.editable;\r\n    listenerSetOrMap.add(listener);\r\n    return () => {\r\n      listenerSetOrMap.delete(listener);\r\n    };\r\n  }\r\n  /**\r\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\r\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\r\n   *\r\n   * Will trigger the provided callback each time the editor transitions between these states until the\r\n   * teardown function is called.\r\n   *\r\n   * @returns a teardown function that can be used to cleanup the listener.\r\n   */\r\n  registerDecoratorListener(listener) {\r\n    const listenerSetOrMap = this._listeners.decorator;\r\n    listenerSetOrMap.add(listener);\r\n    return () => {\r\n      listenerSetOrMap.delete(listener);\r\n    };\r\n  }\r\n  /**\r\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\r\n   * the editor changes from the previous state of the editor. If the text content is the\r\n   * same between updates, no notifications to the listeners will happen.\r\n   *\r\n   * Will trigger the provided callback each time the editor transitions between these states until the\r\n   * teardown function is called.\r\n   *\r\n   * @returns a teardown function that can be used to cleanup the listener.\r\n   */\r\n  registerTextContentListener(listener) {\r\n    const listenerSetOrMap = this._listeners.textcontent;\r\n    listenerSetOrMap.add(listener);\r\n    return () => {\r\n      listenerSetOrMap.delete(listener);\r\n    };\r\n  }\r\n  /**\r\n   * Registers a listener for when the editor's root DOM element (the content editable\r\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\r\n   *  element. The root listener function is executed directly upon registration and then on\r\n   * any subsequent update.\r\n   *\r\n   * Will trigger the provided callback each time the editor transitions between these states until the\r\n   * teardown function is called.\r\n   *\r\n   * @returns a teardown function that can be used to cleanup the listener.\r\n   */\r\n  registerRootListener(listener) {\r\n    const listenerSetOrMap = this._listeners.root;\r\n    listener(this._rootElement, null);\r\n    listenerSetOrMap.add(listener);\r\n    return () => {\r\n      listener(null, this._rootElement);\r\n      listenerSetOrMap.delete(listener);\r\n    };\r\n  }\r\n  /**\r\n   * Registers a listener that will trigger anytime the provided command\r\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\r\n   * commands and prevent them from propagating to other handlers by returning true.\r\n   *\r\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\r\n   *\r\n   * @param command - the command that will trigger the callback.\r\n   * @param listener - the function that will execute when the command is dispatched.\r\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\r\n   * @returns a teardown function that can be used to cleanup the listener.\r\n   */\r\n  registerCommand(command, listener, priority) {\r\n    if (priority === undefined) {\r\n      {\r\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\r\n      }\r\n    }\r\n    const commandsMap = this._commands;\r\n    if (!commandsMap.has(command)) {\r\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\r\n    }\r\n    const listenersInPriorityOrder = commandsMap.get(command);\r\n    if (listenersInPriorityOrder === undefined) {\r\n      {\r\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\r\n      }\r\n    }\r\n    const listeners = listenersInPriorityOrder[priority];\r\n    listeners.add(listener);\r\n    return () => {\r\n      listeners.delete(listener);\r\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\r\n        commandsMap.delete(command);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Registers a listener that will run when a Lexical node of the provided class is\r\n   * mutated. The listener will receive a list of nodes along with the type of mutation\r\n   * that was performed on each: created, destroyed, or updated.\r\n   *\r\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\r\n   * {@link LexicalEditor.getElementByKey} can be used for this.\r\n   *\r\n   * @param klass - The class of the node that you want to listen to mutations on.\r\n   * @param listener - The logic you want to run when the node is mutated.\r\n   * @returns a teardown function that can be used to cleanup the listener.\r\n   */\r\n  registerMutationListener(klass, listener) {\r\n    const registeredNode = this._nodes.get(klass.getType());\r\n    if (registeredNode === undefined) {\r\n      {\r\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\r\n      }\r\n    }\r\n    const mutations = this._listeners.mutation;\r\n    mutations.set(listener, klass);\r\n    return () => {\r\n      mutations.delete(listener);\r\n    };\r\n  }\r\n\r\n  /** @internal */\r\n  registerNodeTransformToKlass(klass, listener) {\r\n    const type = klass.getType();\r\n    const registeredNode = this._nodes.get(type);\r\n    if (registeredNode === undefined) {\r\n      {\r\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\r\n      }\r\n    }\r\n    const transforms = registeredNode.transforms;\r\n    transforms.add(listener);\r\n    return registeredNode;\r\n  }\r\n\r\n  /**\r\n   * Registers a listener that will run when a Lexical node of the provided class is\r\n   * marked dirty during an update. The listener will continue to run as long as the node\r\n   * is marked dirty. There are no guarantees around the order of transform execution!\r\n   *\r\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\r\n   * @param klass - The class of the node that you want to run transforms on.\r\n   * @param listener - The logic you want to run when the node is updated.\r\n   * @returns a teardown function that can be used to cleanup the listener.\r\n   */\r\n  registerNodeTransform(klass, listener) {\r\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\r\n    const registeredNodes = [registeredNode];\r\n    const replaceWithKlass = registeredNode.replaceWithKlass;\r\n    if (replaceWithKlass != null) {\r\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\r\n      registeredNodes.push(registeredReplaceWithNode);\r\n    }\r\n    markAllNodesAsDirty(this, klass.getType());\r\n    return () => {\r\n      registeredNodes.forEach(node => node.transforms.delete(listener));\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\r\n   * depend on have been registered.\r\n   * @returns True if the editor has registered the provided node type, false otherwise.\r\n   */\r\n  hasNode(node) {\r\n    return this._nodes.has(node.getType());\r\n  }\r\n\r\n  /**\r\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\r\n   * depend on have been registered.\r\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\r\n   */\r\n  hasNodes(nodes) {\r\n    return nodes.every(this.hasNode.bind(this));\r\n  }\r\n\r\n  /**\r\n   * Dispatches a command of the specified type with the specified payload.\r\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\r\n   * for this type, passing them the provided payload.\r\n   * @param type - the type of command listeners to trigger.\r\n   * @param payload - the data to pass as an argument to the command listeners.\r\n   */\r\n  dispatchCommand(type, payload) {\r\n    return dispatchCommand(this, type, payload);\r\n  }\r\n\r\n  /**\r\n   * Gets a map of all decorators in the editor.\r\n   * @returns A mapping of call decorator keys to their decorated content\r\n   */\r\n  getDecorators() {\r\n    return this._decorators;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns the current root element of the editor. If you want to register\r\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\r\n   * this reference may not be stable.\r\n   */\r\n  getRootElement() {\r\n    return this._rootElement;\r\n  }\r\n\r\n  /**\r\n   * Gets the key of the editor\r\n   * @returns The editor key\r\n   */\r\n  getKey() {\r\n    return this._key;\r\n  }\r\n\r\n  /**\r\n   * Imperatively set the root contenteditable element that Lexical listens\r\n   * for events on.\r\n   */\r\n  setRootElement(nextRootElement) {\r\n    const prevRootElement = this._rootElement;\r\n    if (nextRootElement !== prevRootElement) {\r\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\r\n      const pendingEditorState = this._pendingEditorState || this._editorState;\r\n      this._rootElement = nextRootElement;\r\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\r\n      if (prevRootElement !== null) {\r\n        // TODO: remove this flag once we no longer use UEv2 internally\r\n        if (!this._config.disableEvents) {\r\n          removeRootElementEvents(prevRootElement);\r\n        }\r\n        if (classNames != null) {\r\n          prevRootElement.classList.remove(...classNames);\r\n        }\r\n      }\r\n      if (nextRootElement !== null) {\r\n        const windowObj = getDefaultView(nextRootElement);\r\n        const style = nextRootElement.style;\r\n        style.userSelect = 'text';\r\n        style.whiteSpace = 'pre-wrap';\r\n        style.wordBreak = 'break-word';\r\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\r\n        this._window = windowObj;\r\n        this._dirtyType = FULL_RECONCILE;\r\n        initMutationObserver(this);\r\n        this._updateTags.add('history-merge');\r\n        commitPendingUpdates(this);\r\n\r\n        // TODO: remove this flag once we no longer use UEv2 internally\r\n        if (!this._config.disableEvents) {\r\n          addRootElementEvents(nextRootElement, this);\r\n        }\r\n        if (classNames != null) {\r\n          nextRootElement.classList.add(...classNames);\r\n        }\r\n      } else {\r\n        // If content editable is unmounted we'll reset editor state back to original\r\n        // (or pending) editor state since there will be no reconciliation\r\n        this._editorState = pendingEditorState;\r\n        this._pendingEditorState = null;\r\n        this._window = null;\r\n      }\r\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\r\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\r\n   * @param key - the key of the LexicalNode.\r\n   */\r\n  getElementByKey(key) {\r\n    return this._keyToDOMMap.get(key) || null;\r\n  }\r\n\r\n  /**\r\n   * Gets the active editor state.\r\n   * @returns The editor state\r\n   */\r\n  getEditorState() {\r\n    return this._editorState;\r\n  }\r\n\r\n  /**\r\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\r\n   * @param editorState - the state to set the editor\r\n   * @param options - options for the update.\r\n   */\r\n  setEditorState(editorState, options) {\r\n    if (editorState.isEmpty()) {\r\n      {\r\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\r\n      }\r\n    }\r\n    flushRootMutations(this);\r\n    const pendingEditorState = this._pendingEditorState;\r\n    const tags = this._updateTags;\r\n    const tag = options !== undefined ? options.tag : null;\r\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\r\n      if (tag != null) {\r\n        tags.add(tag);\r\n      }\r\n      commitPendingUpdates(this);\r\n    }\r\n    this._pendingEditorState = editorState;\r\n    this._dirtyType = FULL_RECONCILE;\r\n    this._dirtyElements.set('root', false);\r\n    this._compositionKey = null;\r\n    if (tag != null) {\r\n      tags.add(tag);\r\n    }\r\n    commitPendingUpdates(this);\r\n  }\r\n\r\n  /**\r\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\r\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\r\n   * deserliazation from JSON stored in a database uses this method.\r\n   * @param maybeStringifiedEditorState\r\n   * @param updateFn\r\n   * @returns\r\n   */\r\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\r\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\r\n    return parseEditorState(serializedEditorState, this, updateFn);\r\n  }\r\n\r\n  /**\r\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\r\n   * where Lexical editor state can be safely mutated.\r\n   * @param updateFn - A function that has access to writable editor state.\r\n   * @param options - A bag of options to control the behavior of the update.\r\n   * @param options.onUpdate - A function to run once the update is complete.\r\n   * Useful for synchronizing updates in some cases.\r\n   * @param options.skipTransforms - Setting this to true will suppress all node\r\n   * transforms for this update cycle.\r\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\r\n   * Some tags are reserved by the core and control update behavior in different ways.\r\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\r\n   * run synchronously.\r\n   */\r\n  update(updateFn, options) {\r\n    updateEditor(this, updateFn, options);\r\n  }\r\n\r\n  /**\r\n   * Focuses the editor\r\n   * @param callbackFn - A function to run after the editor is focused.\r\n   * @param options - A bag of options\r\n   * @param options.defaultSelection - Where to move selection when the editor is\r\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\r\n   */\r\n  focus(callbackFn, options = {}) {\r\n    const rootElement = this._rootElement;\r\n    if (rootElement !== null) {\r\n      // This ensures that iOS does not trigger caps lock upon focus\r\n      rootElement.setAttribute('autocapitalize', 'off');\r\n      updateEditor(this, () => {\r\n        const selection = $getSelection();\r\n        const root = $getRoot();\r\n        if (selection !== null) {\r\n          // Marking the selection dirty will force the selection back to it\r\n          selection.dirty = true;\r\n        } else if (root.getChildrenSize() !== 0) {\r\n          if (options.defaultSelection === 'rootStart') {\r\n            root.selectStart();\r\n          } else {\r\n            root.selectEnd();\r\n          }\r\n        }\r\n      }, {\r\n        onUpdate: () => {\r\n          rootElement.removeAttribute('autocapitalize');\r\n          if (callbackFn) {\r\n            callbackFn();\r\n          }\r\n        },\r\n        tag: 'focus'\r\n      });\r\n      // In the case where onUpdate doesn't fire (due to the focus update not\r\n      // occuring).\r\n      if (this._pendingEditorState === null) {\r\n        rootElement.removeAttribute('autocapitalize');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes focus from the editor.\r\n   */\r\n  blur() {\r\n    const rootElement = this._rootElement;\r\n    if (rootElement !== null) {\r\n      rootElement.blur();\r\n    }\r\n    const domSelection = getDOMSelection(this._window);\r\n    if (domSelection !== null) {\r\n      domSelection.removeAllRanges();\r\n    }\r\n  }\r\n  /**\r\n   * Returns true if the editor is editable, false otherwise.\r\n   * @returns True if the editor is editable, false otherwise.\r\n   */\r\n  isEditable() {\r\n    return this._editable;\r\n  }\r\n  /**\r\n   * Sets the editable property of the editor. When false, the\r\n   * editor will not listen for user events on the underling contenteditable.\r\n   * @param editable - the value to set the editable mode to.\r\n   */\r\n  setEditable(editable) {\r\n    if (this._editable !== editable) {\r\n      this._editable = editable;\r\n      triggerListeners('editable', this, true, editable);\r\n    }\r\n  }\r\n  /**\r\n   * Returns a JSON-serializable javascript object NOT a JSON string.\r\n   * You still must call JSON.stringify (or something else) to turn the\r\n   * state into a string you can transfer over the wire and store in a database.\r\n   *\r\n   * See {@link LexicalNode.exportJSON}\r\n   *\r\n   * @returns A JSON-serializable javascript object\r\n   */\r\n  toJSON() {\r\n    return {\r\n      editorState: this._editorState.toJSON()\r\n    };\r\n  }\r\n}\r\n\r\nexports.$addUpdateTag = $addUpdateTag;\r\nexports.$applyNodeReplacement = $applyNodeReplacement;\r\nexports.$copyNode = $copyNode;\r\nexports.$createLineBreakNode = $createLineBreakNode;\r\nexports.$createNodeSelection = $createNodeSelection;\r\nexports.$createParagraphNode = $createParagraphNode;\r\nexports.$createPoint = $createPoint;\r\nexports.$createRangeSelection = $createRangeSelection;\r\nexports.$createTabNode = $createTabNode;\r\nexports.$createTextNode = $createTextNode;\r\nexports.$getAdjacentNode = $getAdjacentNode;\r\nexports.$getCharacterOffsets = $getCharacterOffsets;\r\nexports.$getEditor = $getEditor;\r\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\r\nexports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;\r\nexports.$getNodeByKey = $getNodeByKey;\r\nexports.$getPreviousSelection = $getPreviousSelection;\r\nexports.$getRoot = $getRoot;\r\nexports.$getSelection = $getSelection;\r\nexports.$getTextContent = $getTextContent;\r\nexports.$hasAncestor = $hasAncestor;\r\nexports.$hasUpdateTag = $hasUpdateTag;\r\nexports.$insertNodes = $insertNodes;\r\nexports.$isBlockElementNode = $isBlockElementNode;\r\nexports.$isDecoratorNode = $isDecoratorNode;\r\nexports.$isElementNode = $isElementNode;\r\nexports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;\r\nexports.$isLeafNode = $isLeafNode;\r\nexports.$isLineBreakNode = $isLineBreakNode;\r\nexports.$isNodeSelection = $isNodeSelection;\r\nexports.$isParagraphNode = $isParagraphNode;\r\nexports.$isRangeSelection = $isRangeSelection;\r\nexports.$isRootNode = $isRootNode;\r\nexports.$isRootOrShadowRoot = $isRootOrShadowRoot;\r\nexports.$isTabNode = $isTabNode;\r\nexports.$isTextNode = $isTextNode;\r\nexports.$nodesOfType = $nodesOfType;\r\nexports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;\r\nexports.$parseSerializedNode = $parseSerializedNode;\r\nexports.$selectAll = $selectAll;\r\nexports.$setCompositionKey = $setCompositionKey;\r\nexports.$setSelection = $setSelection;\r\nexports.$splitNode = $splitNode;\r\nexports.BLUR_COMMAND = BLUR_COMMAND;\r\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\r\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\r\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\r\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\r\nexports.CLICK_COMMAND = CLICK_COMMAND;\r\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\r\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\r\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\r\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\r\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\r\nexports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;\r\nexports.COPY_COMMAND = COPY_COMMAND;\r\nexports.CUT_COMMAND = CUT_COMMAND;\r\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\r\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\r\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\r\nexports.DRAGEND_COMMAND = DRAGEND_COMMAND;\r\nexports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;\r\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\r\nexports.DROP_COMMAND = DROP_COMMAND;\r\nexports.DecoratorNode = DecoratorNode;\r\nexports.ElementNode = ElementNode;\r\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\r\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\r\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\r\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\r\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\r\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\r\nexports.INSERT_TAB_COMMAND = INSERT_TAB_COMMAND;\r\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\r\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\r\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\r\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\r\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\r\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\r\nexports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND;\r\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\r\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\r\nexports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;\r\nexports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;\r\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\r\nexports.LineBreakNode = LineBreakNode;\r\nexports.MOVE_TO_END = MOVE_TO_END;\r\nexports.MOVE_TO_START = MOVE_TO_START;\r\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\r\nexports.PASTE_COMMAND = PASTE_COMMAND;\r\nexports.ParagraphNode = ParagraphNode;\r\nexports.REDO_COMMAND = REDO_COMMAND;\r\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\r\nexports.RootNode = RootNode;\r\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\r\nexports.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = SELECTION_INSERT_CLIPBOARD_NODES_COMMAND;\r\nexports.SELECT_ALL_COMMAND = SELECT_ALL_COMMAND;\r\nexports.TabNode = TabNode;\r\nexports.TextNode = TextNode;\r\nexports.UNDO_COMMAND = UNDO_COMMAND;\r\nexports.createCommand = createCommand;\r\nexports.createEditor = createEditor;\r\nexports.getNearestEditorFromDOMNode = getNearestEditorFromDOMNode;\r\nexports.isCurrentlyReadOnlyMode = isCurrentlyReadOnlyMode;\r\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\r\nexports.isHTMLElement = isHTMLElement;\r\nexports.isSelectionCapturedInDecoratorInput = isSelectionCapturedInDecoratorInput;\r\nexports.isSelectionWithinEditor = isSelectionWithinEditor;\r\n", "/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n'use strict'\r\nconst Lexical = process.env.NODE_ENV === 'development' ? require('./Lexical.dev.js') : require('./Lexical.prod.js')\r\nmodule.exports = Lexical;"],
  "mappings": "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",
  "names": ["mutatedNodes", "leftTree", "rightTree", "anchorNode", "dirtyElements", "dirtyLeaves", "resolvedNode", "activeEditor"]
}
